===BEGIN FILE: package.json===
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "type-check": "tsc --noEmit",
    "type-check:watch": "tsc --noEmit --watch",
    "check": "npm run type-check && npm run lint",
    "test:ui": "vitest --ui"
  },
  "dependencies": {
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.3.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slider": "^1.3.5",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-toggle": "^1.1.9",
    "@radix-ui/react-toggle-group": "^1.1.11",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@types/react-router-dom": "^5.3.3",
    "autoprefixer": "^10.4.21",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.536.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-markdown": "^9.0.1",
    "react-resizable-panels": "^3.0.4",
    "react-router-dom": "^7.8.0",
    "remark-gfm": "^4.0.0",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "zustand": "^5.0.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.30.1",
    "@testing-library/jest-dom": "^6.7.0",
    "@testing-library/react": "^16.3.0",
    "@types/node": "^24.1.0",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "^4.6.0",
    "eslint": "^9.30.1",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "jsdom": "^26.1.0",
    "puppeteer": "^24.16.2",
    "typescript": "^5.9.2",
    "vite": "^6.0.0",
    "vitest": "^3.2.4"
  }
}

===END FILE===

===BEGIN FILE: tsconfig.json===
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["DOM", "ESNext"],
    "jsx": "react-jsx",
    "strict": false,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleResolution": "Bundler",
    "isolatedModules": true,
    "noEmit": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}



===END FILE===

===BEGIN FILE: tailwind.config.js===
/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ["class"],
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	fontFamily: {
  		sans: ['Segoe UI', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Helvetica Neue', 'Arial', 'sans-serif'],
  		mono: ['Segoe UI', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Helvetica Neue', 'Arial', 'sans-serif'],
  	},
  	extend: {
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			sidebar: {
  				DEFAULT: 'hsl(var(--sidebar-background))',
  				foreground: 'hsl(var(--sidebar-foreground))',
  				primary: 'hsl(var(--sidebar-primary))',
  				'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
  				accent: 'hsl(var(--sidebar-accent))',
  				'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
  				border: 'hsl(var(--sidebar-border))',
  				ring: 'hsl(var(--sidebar-ring))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			},
  			shimmer: {
  				'0%': { transform: 'translateX(-100%)' },
  				'100%': { transform: 'translateX(100%)' }
  			},
  			'liquid-wave': {
  				'0%, 100%': { 
  					transform: 'translateY(0px) scaleY(1)',
  					opacity: '0.3'
  				},
  				'50%': { 
  					transform: 'translateY(-20px) scaleY(1.1)',
  					opacity: '0.5'
  				}
  			},
  			'liquid-wave-reverse': {
  				'0%, 100%': { 
  					transform: 'translateY(0px) scaleX(1)',
  					opacity: '0.3'
  				},
  				'50%': { 
  					transform: 'translateY(20px) scaleX(1.1)',
  					opacity: '0.5'
  				}
  			},
  			'liquid-rotate': {
  				'0%': { 
  					transform: 'rotate(0deg) scale(1)',
  					opacity: '0.5'
  				},
  				'50%': { 
  					transform: 'rotate(180deg) scale(1.2)',
  					opacity: '0.3'
  				},
  				'100%': { 
  					transform: 'rotate(360deg) scale(1)',
  					opacity: '0.5'
  				}
  			},
  			'float': {
  				'0%, 100%': { transform: 'translateY(0px)' },
  				'50%': { transform: 'translateY(-3px)' }
  			},
  			'pulse-flow': {
  				'0%': { 
  					transform: 'translateX(-100%)',
  					opacity: '0'
  				},
  				'50%': { 
  					opacity: '1'
  				},
  				'100%': { 
  					transform: 'translateX(100%)',
  					opacity: '0'
  				}
  			},
  			'pulse-delayed': {
  				'0%, 100%': { opacity: '0.5' },
  				'50%': { opacity: '1' }
  			},
  			'flow-particle-1': {
  				'0%': { 
  					left: '0%',
  					opacity: '0'
  				},
  				'10%': {
  					opacity: '1'
  				},
  				'90%': {
  					opacity: '1'
  				},
  				'100%': { 
  					left: '100%',
  					opacity: '0'
  				}
  			},
  			'flow-particle-2': {
  				'0%': { 
  					left: '0%',
  					opacity: '0'
  				},
  				'15%': {
  					opacity: '0.8'
  				},
  				'85%': {
  					opacity: '0.8'
  				},
  				'100%': { 
  					left: '100%',
  					opacity: '0'
  				}
  			},
  			'flow-particle-3': {
  				'0%': { 
  					left: '0%',
  					opacity: '0'
  				},
  				'20%': {
  					opacity: '0.6'
  				},
  				'80%': {
  					opacity: '0.6'
  				},
  				'100%': { 
  					left: '100%',
  					opacity: '0'
  				}
  			},
  			'flow-dash': {
  				'0%': {
  					strokeDashoffset: '0'
  				},
  				'100%': {
  					strokeDashoffset: '-10'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out',
  			'pulse-once': 'pulse 0.5s ease-in-out 1',
  			shimmer: 'shimmer 3s ease-in-out infinite',
  			'liquid-wave': 'liquid-wave 4s ease-in-out infinite',
  			'liquid-wave-reverse': 'liquid-wave-reverse 4s ease-in-out infinite 2s',
  			'liquid-rotate': 'liquid-rotate 6s ease-in-out infinite',
  			'float': 'float 2s ease-in-out infinite',
  			'pulse-flow': 'pulse-flow 2s ease-in-out infinite',
  			'pulse-delayed': 'pulse-delayed 2s ease-in-out infinite 1s',
  			'flow-particle-1': 'flow-particle-1 3s ease-in-out infinite',
  			'flow-particle-2': 'flow-particle-2 3s ease-in-out infinite 0.5s',
  			'flow-particle-3': 'flow-particle-3 3s ease-in-out infinite 1s',
  			'flow-dash': 'flow-dash 1s linear infinite'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
}
===END FILE===

===BEGIN FILE: postcss.config.js===
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
===END FILE===

===BEGIN FILE: index.html===
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/hsbc-logo.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HSBC Contact Center - Agent Portal</title>
    <!-- Load Segoe UI from CDN for cross-platform consistency -->
    <link href="https://fonts.cdnfonts.com/css/segoe-ui-4" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

===END FILE===

===BEGIN FILE: ARCHITECTURE.md===
# Frontend Architecture

## Technology Stack

- **React 19.1** - UI framework with concurrent features
- **TypeScript 5.9** - Type safety and developer experience  
- **Vite 6.0** - Fast build tool and dev server
- **Zustand 5.0** - State management with persistence
- **Tailwind CSS 3.4** - Utility-first styling
- **shadcn/ui** - Component library built on Radix UI
- **Lucide React** - Icon library

## Project Structure

```
src/
├── components/          # UI components
│   ├── auth/           # Authentication components
│   ├── columns/        # 3-column layout components
│   ├── layout/         # Layout components
│   ├── chat/           # Chat interface
│   ├── call-controls/  # Call management
│   └── ui/            # shadcn/ui base components
├── contexts/           # React contexts
│   ├── auth-context    # Authentication state
│   ├── websocket-context # WebSocket connection
│   ├── role-context    # Role-based features
│   └── theme-context   # Theme management
├── stores/            # Zustand stores
│   ├── agent-store    # Agent dashboard data
│   └── agent-status-store # Call state & status
├── hooks/             # Custom React hooks
├── config/            # App configuration
├── lib/              # Utilities
└── pages/            # Route components
```

## Key Design Decisions

### 1. State Management

**Zustand over Redux/Context API**
- Simpler API with less boilerplate
- Built-in persistence middleware for localStorage
- Better TypeScript support
- Selective subscriptions prevent unnecessary re-renders

### 2. WebSocket Architecture

**Native WebSocket over Socket.io**
- Lighter weight, no additional protocol overhead
- Direct message passing without event emitters
- Automatic reconnection with exponential backoff
- Heartbeat mechanism for connection health

### 3. Component Architecture

**Compound Components Pattern**
- Column components manage their own state
- Collapsible behavior via custom hook
- Persistent column visibility in localStorage

**Composition over Inheritance**
- Functional components exclusively
- Custom hooks for shared logic
- Props drilling minimized via context

### 4. Authentication

**Mock Authentication (Development)**
- Simple username/password for testing
- Protected routes with requireAuth flag
- Session persistence in localStorage
- WebSocket disconnect on logout

### 5. Real-time Data Flow

```
Gateway WebSocket → WebSocket Context → Zustand Store → UI Components
```

**Message Types Consumed:**
- `sentiment` - Customer sentiment analysis
- `priority` - Call priority and queue position
- `summary` - AI-generated call summary
- `intent` - Customer intent detection
- `actions` - Recommended agent actions
- `knowledge` - Knowledge base articles
- `transcript` - Call transcription
- `customer` - Customer data from PostgreSQL

### 6. Performance Optimizations

**Code Splitting**
- Route-based lazy loading
- Dynamic imports for heavy components

**Memoization**
- React.memo for expensive components
- useMemo for computed values
- useCallback for stable function references

**Virtual Scrolling**
- Long transcript lists virtualized
- Prevents DOM node explosion

## Critical Components

### WebSocketProvider
- Manages WebSocket lifecycle
- Handles reconnection logic
- Routes messages to store
- Provides connection status

### ProtectedRoute
- Guards authenticated routes
- Default requireAuth = true (security fix)
- Redirects to login when unauthorized

### ColumnLayout
- 3-column responsive layout
- Collapsible columns with animation
- Persistent visibility state
- Mobile-responsive behavior

### AgentStatusStore
- Call state management
- Media control bar state
- Persisted with Zustand middleware
- Cleared on logout

## Data Flow

### Customer Context
1. Customer data fetched from PostgreSQL
2. Sent via WebSocket message type `customer`
3. Stored in agent-store
4. UI components subscribe to updates
5. Embedded apps notified via custom event

### AI Processing Pipeline

#### Current Implementation
- **AI Simulation Service** (Port 8000): Python FastAPI service that simulates call processing
- **Embedded Apps** (Ports 3001-3003): Intent-specific micro frontends
- Generates mock transcriptions and AI analysis
- Publishes to Kafka topics for real-time updates
- Will be replaced by Genesys integration in production

#### Production Flow (Future Genesys Integration)
1. Audio → Genesys transcription service
2. Transcript → AI service for analysis
3. Results broadcast via Kafka topics:
   - `sentiment_analysis`
   - `priority_scoring`
   - `call_summary`
   - `intent_classification`
   - `recommended_actions`
   - `knowledge_suggestions`
   - `call_transcription`

## Security Considerations

- All routes protected by default
- WebSocket requires agentId and callerId
- Input sanitization in forms
- No sensitive data in localStorage
- CORS configured for production domains

## Testing Strategy

- Unit tests with Vitest
- Component testing with React Testing Library
- E2E tests with Playwright (planned)
- Type checking with TypeScript strict mode

## Future Improvements

- Implement real authentication (JWT/OAuth)
- Add WebSocket message encryption
- Implement proper error boundaries
- Add performance monitoring (Sentry)
- Migrate to React Server Components
- Add offline support with Service Workers
===END FILE===

===BEGIN FILE: components.json===
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": false,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}
===END FILE===

===BEGIN FILE: docs/architecture.md===
# HSBC CCAAS Platform - Frontend Architecture

## Overview

The HSBC CCAAS Platform frontend is a modern React-based ccaas center application built with TypeScript, providing a comprehensive agent interface for handling customer interactions across multiple channels.

## Technology Stack

### Core Technologies
- **React 19.1** - Component-based UI framework
- **TypeScript 5.9** - Type-safe JavaScript
- **Vite 6.0** - Fast build tool and development server
- **TailwindCSS 3.4** - Utility-first CSS framework
- **Zustand 5.0** - Lightweight state management
- **WebSocket** - Real-time bidirectional communication

### Key Libraries
- **Shadcn/UI** - Accessible component library
- **Radix UI** - Unstyled, accessible components
- **React Query** - Server state management
- **React Hook Form** - Form validation and handling
- **Lucide React** - Icon library
- **Recharts** - Data visualization

## Application Structure

```
frontend/
├── src/
│   ├── components/       # React components
│   ├── stores/           # Zustand state stores
│   ├── services/         # Business logic and API services
│   ├── hooks/            # Custom React hooks
│   ├── contexts/         # React context providers
│   ├── utils/            # Utility functions
│   ├── lib/              # Third-party integrations
│   ├── config/           # Application configuration
│   └── types/            # TypeScript type definitions
├── public/
│   └── config/           # Externalized JSON configurations
├── docs/                 # Documentation
└── dist/                 # Production build output
```

## Core Architecture Principles

### 1. Component-Based Architecture
- **Atomic Design Pattern**: Components organized from atoms to organisms
- **Single Responsibility**: Each component handles one specific concern
- **Composition over Inheritance**: Complex UI built through component composition

### 2. State Management Strategy
- **Zustand for Global State**: Centralized store for agent status, call state, and application data
- **React Query for Server State**: Caching and synchronization of server data
- **Local Component State**: UI-specific state kept in components
- **Context for Cross-Cutting Concerns**: WebSocket connections, themes, authentication

### 3. Real-Time Communication
- **WebSocket Architecture**: Persistent connections for real-time updates
- **Event-Driven Updates**: Message-based communication pattern
- **Connection Resilience**: Automatic reconnection with exponential backoff
- **Message Queue**: Buffering for offline scenarios

### 4. Performance Optimization
- **Code Splitting**: Dynamic imports for route-based splitting
- **Lazy Loading**: Components loaded on demand
- **Memoization**: Strategic use of React.memo and useMemo
- **Virtual Scrolling**: Efficient rendering of large lists

## Key Architectural Patterns

### 1. Container/Presenter Pattern
```typescript
// Container Component - Handles logic
const CustomerListContainer = () => {
  const customers = useCustomerStore()
  const { filter, sort } = useFilterStore()
  
  return <CustomerList data={customers} filter={filter} sort={sort} />
}

// Presenter Component - Pure UI
const CustomerList = ({ data, filter, sort }) => {
  // Pure rendering logic
}
```

### 2. Custom Hook Pattern
```typescript
// Encapsulate complex logic in hooks
const useCallManagement = () => {
  const { callState, startCall, endCall } = useAgentStatusStore()
  const { connect, disconnect } = useWebSocket()
  
  // Complex call handling logic
  return { callState, handleCall, handleEndCall }
}
```

### 3. Service Layer Pattern
```typescript
// Services handle external communication
class CustomerService {
  async getCustomer(id: string): Promise<Customer> {
    // API calls, caching, error handling
  }
}
```

## Data Flow Architecture

### 1. Unidirectional Data Flow
```
User Action → Event Handler → Store Action → State Update → UI Re-render
```

### 2. WebSocket Message Flow
```
Server Message → WebSocket Context → Message Router → Store Updates → Component Updates
```

### 3. API Request Flow
```
Component → Service Layer → HTTP Client → API → Response Processing → State Update
```

## Module Organization

### Component Categories
1. **Layout Components**: Frame, headers, navigation
2. **Feature Components**: Call controls, chat interface, customer details
3. **Widget Components**: Metrics, sentiment, actions, transcripts
4. **Common Components**: Buttons, inputs, modals, cards

### Service Categories
1. **API Services**: REST API communication
2. **WebSocket Services**: Real-time messaging
3. **Storage Services**: Local/session storage management
4. **Utility Services**: Audio, notifications, formatting

## Build and Deployment

### Development Build
```bash
npm run dev        # Start development server on port 5173
npm run dev:host  # Expose to network for testing
```

### Production Build
```bash
npm run build     # Create optimized production build
npm run preview   # Preview production build locally
```

### Build Optimization
- **Tree Shaking**: Removes unused code
- **Minification**: Reduces file sizes
- **Compression**: Gzip/Brotli compression
- **Asset Optimization**: Image and font optimization

## Environment Configuration

### Environment Variables
```
VITE_API_BASE_URL          # Backend API endpoint
VITE_WS_URL                # WebSocket server URL
VITE_AI_SERVICE_URL        # AI service endpoint
VITE_ENABLE_MOCK_DATA      # Toggle mock data mode
VITE_ENABLE_DEBUG_LOGGING  # Control debug output
```

### Configuration Hierarchy
1. Environment variables (highest priority)
2. Configuration files (app-config.ts)
3. Default values (fallback)

## Security Considerations

### 1. Authentication & Authorization
- JWT token-based authentication
- Role-based access control (RBAC)
- Secure token storage (httpOnly cookies)

### 2. Data Protection
- Input validation and sanitization
- XSS prevention through React's built-in escaping
- CSRF protection via tokens

### 3. Communication Security
- HTTPS enforcement in production
- WSS (WebSocket Secure) for real-time data
- API request signing for sensitive operations

## Performance Metrics

### Target Metrics
- **Initial Load**: < 3 seconds
- **Time to Interactive**: < 5 seconds
- **API Response**: < 500ms (p95)
- **WebSocket Latency**: < 100ms
- **Frame Rate**: 60 FPS for animations

### Monitoring
- Performance monitoring via browser APIs
- Error tracking and reporting
- User session recording for debugging
- Real-time performance dashboards

## Scalability Considerations

### Horizontal Scaling
- Stateless application design
- CDN for static assets
- Load balancing for API requests

### Vertical Scaling
- Efficient memory management
- Optimized bundle sizes
- Progressive enhancement

## Future Architecture Enhancements

### Planned Improvements
1. **Micro-Frontend Architecture**: Independent deployment of features
2. **Module Federation**: Dynamic module loading
3. **Service Workers**: Offline capabilities
4. **WebAssembly Integration**: Performance-critical computations
5. **Server-Side Rendering**: Initial page load optimization

### Technology Upgrades
1. Migration to React Server Components
2. Adoption of React Suspense for data fetching
3. Implementation of React Concurrent Features
4. Progressive Web App capabilities

## Architecture Decision Records (ADRs)

### ADR-001: Zustand for State Management
**Decision**: Use Zustand instead of Redux
**Rationale**: Simpler API, smaller bundle size, TypeScript-first design
**Consequences**: Less ecosystem, custom middleware needed

### ADR-002: Vite as Build Tool
**Decision**: Use Vite instead of Webpack
**Rationale**: Faster development builds, better HMR, simpler configuration
**Consequences**: Less mature ecosystem, some plugin compatibility

### ADR-003: Component Library Strategy
**Decision**: Use Shadcn/UI with Radix primitives
**Rationale**: Full control over components, accessibility built-in
**Consequences**: More setup required, custom theming needed
===END FILE===

===BEGIN FILE: docs/component-guide.md===
# HSBC CCAAS Platform - Component Development Guide

## Component Structure Overview

The HSBC CCAAS Platform uses a hierarchical component structure based on atomic design principles, organizing components from simple atoms to complex organisms.

## Component Categories

### 1. Layout Components
Location: `src/components/layout/`

#### SingleAgentLayout
- **Purpose**: Main container for single agent view
- **Key Props**: `children: ReactNode`
- **State Dependencies**: Agent status, call state
- **Usage**:
```typescript
<SingleAgentLayout>
  <Dashboard />
</SingleAgentLayout>
```

#### DashboardLayout
- **Purpose**: Grid-based layout for widget arrangement
- **Key Props**: `columns: number`, `gap: number`
- **State Dependencies**: Layout preferences
- **Features**: Responsive grid, collapsible sections

### 2. Call Control Components
Location: `src/components/call-controls/`

#### MediaControlBarV2
- **Purpose**: Primary call control interface
- **State Management**: Zustand (agent-status-store)
- **Key Features**:
  - Accept/reject incoming calls
  - Mute/hold controls
  - Call transfer capabilities
  - End call with confirmation
- **WebSocket Events**: 
  - `accept_call`
  - `end_call`
  - `transfer_call`

#### InlineCallNotification
- **Purpose**: Floating call notification UI
- **State Management**: Zustand (agent-status-store)
- **Features**:
  - Draggable positioning
  - Auto-accept timer
  - Priority visualization

### 3. Widget Components
Location: `src/components/widgets/`

#### CustomerWidget
- **Purpose**: Display customer information
- **Data Source**: WebSocket messages, PostgreSQL data
- **Key Fields**:
  - Customer details (name, email, phone)
  - Account information
  - History summary
- **Update Frequency**: On call start, real-time updates

#### SentimentWidget
- **Purpose**: Real-time sentiment analysis display
- **Data Source**: AI service via WebSocket
- **Visualization**: Gauge chart with color coding
- **Update Frequency**: Every 5 seconds during active call

#### TranscriptWidget
- **Purpose**: Live call transcription display
- **Features**:
  - Speaker identification
  - Auto-scroll
  - Search functionality
  - Export capability
- **Performance**: Virtual scrolling for long transcripts

#### ActionsWidget
- **Purpose**: Track and manage call actions
- **Features**:
  - Action checklist
  - Completion tracking
  - Priority indicators
  - Notes capability

#### IntentWidget
- **Purpose**: Display detected customer intent
- **AI Integration**: Intent classification from conversation
- **Categories**: 
  - Account inquiry
  - Technical support
  - Billing
  - General inquiry

#### SummaryWidget
- **Purpose**: AI-generated conversation summary
- **Update Trigger**: Every 30 seconds or on demand
- **Format**: Bullet points with key topics

#### MetricsWidget
- **Purpose**: Call and performance metrics
- **Metrics Tracked**:
  - Call duration
  - Handle time
  - Customer satisfaction prediction
  - First call resolution likelihood

#### KnowledgeWidget
- **Purpose**: Relevant knowledge base articles
- **Features**:
  - Context-aware suggestions
  - Search integration
  - Quick copy snippets

### 4. Chat Components
Location: `src/components/chat/`

#### ChatInterface
- **Purpose**: Customer chat interaction
- **Features**:
  - Message history
  - Typing indicators
  - File attachments
  - Quick responses
- **State Management**: Local state with WebSocket sync

#### ResponseTemplates
- **Purpose**: Pre-configured response templates
- **Categories**:
  - Greetings
  - Common issues
  - Escalation
  - Closing
- **Customization**: Editable templates with variables

### 5. Agent Status Components
Location: `src/components/agent-status/`

#### AgentStatusToggle
- **Purpose**: Agent availability control
- **States**: 
  - Available
  - On Call
  - Break
  - After Call Work
  - Do Not Disturb
  - Offline
- **Features**:
  - Timer for ACW and DND
  - Auto-status changes
  - Status history

### 6. Search Components
Location: `src/components/search/`

#### SearchBar
- **Purpose**: Unified search interface
- **Search Scope**:
  - Customers
  - Knowledge base
  - Transaction history
  - Notes
- **Features**:
  - Auto-complete
  - Recent searches
  - Filters

#### SearchResultsOptimized
- **Purpose**: Display paginated search results
- **Performance**: 
  - Virtual scrolling
  - Lazy loading
  - Result caching

### 7. Settings Components
Location: `src/components/settings/`

#### SettingsPanel
- **Purpose**: Application configuration UI
- **Settings Categories**:
  - Call preferences
  - Notification settings
  - Display options
  - Shortcuts
- **Persistence**: Local storage with sync

### 8. Embedded App Components
Location: `src/components/columns/`

#### EmbeddedAppColumn
- **Purpose**: Iframe container for external applications
- **Security**: 
  - Origin validation
  - Sandboxing
  - Message validation
- **Communication**: PostMessage API

## Component Development Standards

### TypeScript Requirements

#### Interface Definition
```typescript
interface ComponentProps {
  // Required props
  id: string
  data: DataType
  
  // Optional props
  className?: string
  onUpdate?: (data: DataType) => void
  
  // Children
  children?: ReactNode
}
```

#### Component Template
```typescript
import { FC, useState, useEffect } from 'react'
import { cn } from '@/lib/utils'

interface MyComponentProps {
  // Props definition
}

export const MyComponent: FC<MyComponentProps> = ({
  prop1,
  prop2,
  className,
  ...props
}) => {
  // State management
  const [state, setState] = useState<StateType>()
  
  // Store subscriptions
  const storeValue = useStore(state => state.value)
  
  // Effects
  useEffect(() => {
    // Side effects
  }, [dependencies])
  
  // Event handlers
  const handleEvent = () => {
    // Handler logic
  }
  
  // Render
  return (
    <div className={cn('base-classes', className)} {...props}>
      {/* Component content */}
    </div>
  )
}
```

### Styling Guidelines

#### TailwindCSS Usage
```typescript
// Prefer utility classes
<div className="flex items-center gap-4 p-4 bg-white rounded-lg shadow-sm">

// Use cn() for conditional classes
<div className={cn(
  "base-class",
  isActive && "active-class",
  isDisabled && "disabled-class"
)}>
```

#### Responsive Design
```typescript
// Mobile-first approach
<div className="p-2 sm:p-4 md:p-6 lg:p-8">
  <span className="text-sm md:text-base lg:text-lg">
    Responsive text
  </span>
</div>
```

### Performance Optimization

#### Memoization
```typescript
// Memoize expensive computations
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(data)
}, [data])

// Memoize components
export const MyComponent = memo(({ prop1, prop2 }) => {
  // Component implementation
})
```

#### Lazy Loading
```typescript
// Lazy load heavy components
const HeavyComponent = lazy(() => import('./HeavyComponent'))

// Use with Suspense
<Suspense fallback={<Loading />}>
  <HeavyComponent />
</Suspense>
```

### State Management Integration

#### Zustand Store Usage
```typescript
// Subscribe to store
const { value, setValue } = useAgentStatusStore(state => ({
  value: state.value,
  setValue: state.setValue
}))

// Selective subscriptions for performance
const callState = useAgentStatusStore(state => state.callState)
```

#### Local vs Global State
```typescript
// Local state for UI-only concerns
const [isOpen, setIsOpen] = useState(false)

// Global state for shared data
const agentStatus = useAgentStatusStore(state => state.status)
```

### Testing Requirements

#### Component Testing
```typescript
import { render, screen, fireEvent } from '@testing-library/react'

describe('MyComponent', () => {
  it('renders correctly', () => {
    render(<MyComponent prop1="value" />)
    expect(screen.getByText('Expected text')).toBeInTheDocument()
  })
  
  it('handles user interaction', () => {
    const handleClick = jest.fn()
    render(<MyComponent onClick={handleClick} />)
    
    fireEvent.click(screen.getByRole('button'))
    expect(handleClick).toHaveBeenCalled()
  })
})
```

### Accessibility Standards

#### ARIA Attributes
```typescript
<button
  aria-label="End call"
  aria-pressed={isActive}
  role="button"
  tabIndex={0}
>
  <PhoneOff />
</button>
```

#### Keyboard Navigation
```typescript
const handleKeyDown = (e: KeyboardEvent) => {
  switch(e.key) {
    case 'Enter':
    case ' ':
      handleAction()
      break
    case 'Escape':
      handleCancel()
      break
  }
}
```

## Component Communication Patterns

### Props Drilling Prevention
```typescript
// Use context for deeply nested data
const ThemeContext = createContext<Theme>('light')

// Or use Zustand store
const useThemeStore = create<ThemeState>()
```

### Event Bubbling
```typescript
// Child component
const Child = ({ onAction }) => {
  const handleClick = () => {
    onAction({ type: 'CHILD_ACTION', payload: data })
  }
}

// Parent component
const Parent = () => {
  const handleChildAction = (action) => {
    // Handle action from child
  }
  
  return <Child onAction={handleChildAction} />
}
```

### WebSocket Integration
```typescript
const MyComponent = () => {
  const { sendMessage, lastMessage } = useWebSocket()
  
  useEffect(() => {
    if (lastMessage?.type === 'relevant_type') {
      // Handle message
    }
  }, [lastMessage])
  
  const sendUpdate = () => {
    sendMessage({
      type: 'component_update',
      data: componentData
    })
  }
}
```

## Common Patterns and Solutions

### Loading States
```typescript
const MyComponent = () => {
  const { data, isLoading, error } = useQuery()
  
  if (isLoading) return <Skeleton />
  if (error) return <ErrorMessage error={error} />
  
  return <Content data={data} />
}
```

### Error Boundaries
```typescript
class ErrorBoundary extends Component {
  componentDidCatch(error, errorInfo) {
    // Log error to service
    console.error('Component error:', error, errorInfo)
  }
  
  render() {
    if (this.state.hasError) {
      return <ErrorFallback />
    }
    
    return this.props.children
  }
}
```

### Optimistic Updates
```typescript
const MyComponent = () => {
  const [items, setItems] = useState([])
  
  const addItem = async (newItem) => {
    // Optimistic update
    setItems(prev => [...prev, newItem])
    
    try {
      await api.addItem(newItem)
    } catch (error) {
      // Revert on error
      setItems(prev => prev.filter(item => item.id !== newItem.id))
    }
  }
}
```
===END FILE===

===BEGIN FILE: docs/embedded-apps-integration.md===
# Embedded Apps Integration Guide

Complete guide for integrating external applications into the HSBC CCAAS Platform with dynamic intent mapping, context passing, state management, and troubleshooting.

## Table of Contents
- [Overview](#overview)
- [Complete Architecture Flow](#complete-architecture-flow)
- [State Management Architecture](#state-management-architecture)
- [Intent-to-App Mapping System](#intent-to-app-mapping-system)
- [Tab Lifecycle Management](#tab-lifecycle-management)
- [Context Propagation](#context-propagation)
- [Role-based Access Control](#role-based-access-control)
- [Integration Steps](#integration-steps)
- [Code Implementation](#code-implementation)
- [Performance Considerations](#performance-considerations)
- [Advanced Debugging](#advanced-debugging)
- [Troubleshooting Guide](#troubleshooting-guide)
- [Common Issues & Solutions](#common-issues--solutions)
- [Developer Tools](#developer-tools)

## Overview

The HSBC CCAAS Platform supports embedding external applications that automatically load based on detected customer intents. These apps receive full customer context and can communicate bidirectionally with the main platform.

### Key Features
- **Automatic Intent Detection**: Apps load automatically when specific intents are detected
- **WebSocket Enrichment**: Real-time intent-to-app mapping via Gateway service
- **Context Preservation**: Customer data flows seamlessly to embedded apps
- **Tab Management**: Multiple apps can run simultaneously in tabs
- **Resilient Architecture**: Main app remains functional even if embedded apps fail

## Complete Architecture Flow

### System Overview

The embedded apps system follows a sophisticated multi-layer architecture with real-time state management, WebSocket enrichment, and dynamic tab management:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           HSBC CCAAS Platform                              │
│                                                                             │
│  ┌─────────────────────────┐    ┌─────────────────────────┐                 │
│  │     AI Service          │    │    Gateway Service      │                 │
│  │  • Intent Detection     │    │  • WebSocket Router     │                 │
│  │  • Confidence Scoring   │────┤  • App URL Enrichment   │                 │
│  │  • Real-time Analysis   │    │  • Database Queries     │                 │
│  └─────────────────────────┘    └──────────┬──────────────┘                 │
│                                            │                                │
│  ┌─────────────────────────────────────────▼─────────────────────────────┐  │
│  │                    Frontend State Management                          │  │
│  │                                                                       │  │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────┐   │  │
│  │  │   Agent Store   │  │  Intent Store   │  │  WebSocket Context  │   │  │
│  │  │ • Customer Data │  │ • Available     │  │ • Connection Mgmt   │   │  │
│  │  │ • Call Context  │  │   Intents       │  │ • Message Routing   │   │  │
│  │  │ • Sentiment     │  │ • Embedded App  │  │ • Intent Enrichment │   │  │
│  │  │ • Transcripts   │  │   Intent        │  │ • Context Updates   │   │  │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────────┘   │  │
│  └───────────────────────────────┬───────────────────────────────────────┘  │
│                                  │                                          │
│  ┌───────────────────────────────▼───────────────────────────────────────┐  │
│  │                    EmbeddedAppColumn Component                        │  │
│  │                                                                       │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐ │  │
│  │  │                   Tab Management System                         │ │  │
│  │  │  • Dynamic Tab Creation     • Context Propagation              │ │  │
│  │  │  • Lifecycle Management     • Error Recovery                   │ │  │
│  │  │  • User Interactions        • Performance Optimization         │ │  │
│  │  └─────────────────────────────────────────────────────────────────┘ │  │
│  │                                                                       │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                   │  │
│  │  │  Tab 1      │  │  Tab 2      │  │  Tab N      │                   │  │
│  │  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │                   │  │
│  │  │ │ iframe  │ │  │ │ iframe  │ │  │ │ iframe  │ │                   │  │
│  │  │ │ App A   │ │  │ │ App B   │ │  │ │ App C   │ │                   │  │
│  │  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │                   │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                   │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Communication Channels                           │ │
│  │  • URL Parameters (Initial Load)                                       │ │
│  │  • postMessage API (Real-time Updates)                                 │ │
│  │  • Custom Events (Cross-Component Communication)                       │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Data Flow Sequence

1. **Intent Detection**: AI Service detects customer intent (e.g., "credit_card_transactions")
2. **Gateway Enrichment**: Gateway queries `embedded_apps` table and enriches intent with `appUrl` and `appTitle`
3. **WebSocket Delivery**: Enriched intent sent via WebSocket to frontend
4. **State Updates**: Intent and Agent stores updated with new data
5. **Tab Creation**: EmbeddedAppColumn creates new tab if needed
6. **URL Building**: Context-aware URL built with customer data
7. **Iframe Loading**: Embedded app loads in iframe with full context
8. **Handshake**: App signals ready, parent sends current state
9. **Real-time Updates**: Context changes propagate to all active tabs

## State Management Architecture

The embedded apps system uses a sophisticated state management architecture based on Zustand stores with reactive updates and cross-component communication.

### Core Stores Overview

```typescript
┌─────────────────────────────────────────────────────────────────┐
│                     Zustand Store Architecture                   │
│                                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   AgentStore    │  │  IntentStore    │  │ WebSocketContext│ │
│  │                 │  │                 │  │                 │ │
│  │ • Customer Data │  │ • Available     │  │ • Connection    │ │
│  │ • Call Context  │  │   Intents       │  │   Management    │ │
│  │ • Sentiment     │◄─┤ • Current Intent│◄─┤ • Message       │ │
│  │ • Summary       │  │ • Embedded App  │  │   Routing       │ │
│  │ • Actions       │  │   Intent        │  │ • Intent        │ │
│  │ • Transcripts   │  │ • Intent History│  │   Enrichment    │ │
│  │ • Knowledge     │  │                 │  │                 │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
│           │                     │                     │        │
│           └─────────────────────┼─────────────────────┘        │
│                                 │                              │
│  ┌─────────────────────────────▼─────────────────────────────┐ │
│  │              EmbeddedAppColumn Component                  │ │
│  │  • Subscribes to all stores                              │ │
│  │  • Manages tab state locally                             │ │
│  │  • Propagates context to iframes                         │ │
│  └───────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

### AgentStore (Primary Context Provider)

**Purpose**: Central repository for all call-related data and customer context.

```typescript
interface AgentData {
  // Agent Information
  agentId: string
  agentName: string
  department: string
  role?: 'call' | 'chat' | 'supervisor' | 'manager'
  status: 'active' | 'idle' | 'offline'
  
  // Call Information
  callerId: string
  callDuration: number
  queuePosition: number
  
  // Real-time Analytics
  sentiment: {
    score: number
    label: 'positive' | 'neutral' | 'negative'
    trend: 'up' | 'down' | 'stable'
    change: number
  }
  
  // WebSocket Enriched Intent (contains appUrl/appTitle)
  intent: {
    type: string
    confidence: number
    appUrl?: string      // From Gateway: "/embedded-apps/credit_card_management"
    appTitle?: string    // From Gateway: "Credit Card Management"
  }
  
  // Customer Context (Primary data for embedded apps)
  customer: {
    id: string
    name: string
    tier: string
    accountNumber: string
    email: string
    phone: string
    location: string
    // ... additional fields
  }
  
  // AI-Generated Content
  summary: { text: string, category: string, confidence: number }
  actions: Array<{ id: string, action: string, completed: boolean }>
  transcript: Array<{ speaker: string, text: string, timestamp: Date }>
  knowledgeArticles: Array<{ title: string, relevance: number, url: string }>
}
```

**Key Methods**:
- `updateCustomer()` - Triggers customer context updates to all embedded apps
- `updateIntent()` - Receives WebSocket enriched intent data
- `clearAll()` - Resets all data when call ends

### IntentStore (App Selection Manager)

**Purpose**: Manages available intents and tracks which intent is displayed in embedded apps.

```typescript
interface IntentStore {
  availableIntents: Intent[]      // All detected intents
  currentIntent: string | null    // Selected in dropdown
  embeddedAppIntent: string | null // Actually displayed in embedded app
  intentHistory: Intent[]         // Past intents for this call
  
  // Key distinction: currentIntent ≠ embeddedAppIntent
  // User can select different intent in dropdown without changing embedded app
}

interface Intent {
  id: string
  name: string
  confidence: number
  appUrl?: string    // WebSocket enriched data
  appTitle?: string  // WebSocket enriched data
}
```

**Key Behaviors**:
```typescript
// New intent detected → Auto-set as embeddedAppIntent (creates tab)
setAvailableIntents([newIntent]) 
// ↓
// embeddedAppIntent = newIntent.id (triggers tab creation)

// User manually selects intent → Only updates dropdown
selectIntent(intentId) 
// ↓  
// currentIntent = intentId (no tab change)

// User explicitly launches intent → Updates both
setEmbeddedAppIntent(intentId)
// ↓
// embeddedAppIntent = intentId (creates/switches tab)
// currentIntent = intentId (updates dropdown)
```

### WebSocketContext (Communication Layer)

**Purpose**: Manages WebSocket connection and intent enrichment from Gateway.

```typescript
interface WebSocketContextValue {
  connect: (agentId: string, callerId: string) => void
  disconnect: () => void
  sendMessage: (message: any) => void
  isConnected: boolean
  hasCustomerContext: boolean
}
```

**Intent Enrichment Process**:
```typescript
// In handleMessage function (websocket-context.tsx)
case 'intent': {
  // Raw intent from AI Service
  const intentData = {
    type: data.intent || 'UNKNOWN',
    confidence: data.confidence || 0,
    
    // Gateway enrichment (if available)
    appUrl: data.appUrl,      // "/embedded-apps/credit_card_management"  
    appTitle: data.appTitle   // "Credit Card Management"
  }
  
  // Update AgentStore with enriched intent
  updateIntent(intentData)
  break
}
```

### State Flow Examples

#### 1. New Intent Detection Flow
```typescript
// 1. WebSocket receives enriched intent
WebSocketContext: handleMessage('intent') 
↓
// 2. AgentStore updated with enriched data
AgentStore: updateIntent({ 
  type: 'credit_card_transactions',
  appUrl: '/embedded-apps/credit_card_management',
  appTitle: 'Credit Card Management'
})
↓
// 3. EmbeddedAppColumn detects new intent
EmbeddedAppColumn: useEffect([websocketIntent]) 
↓
// 4. Tab created with enriched URL
createTabForIntent('credit_card_transactions')
URL: http://localhost:5175/embedded-apps/credit_card_management?customerId=123...
```

#### 2. Customer Context Update Flow
```typescript
// 1. Customer identified via WebSocket
WebSocketContext: handleMessage('customer')
↓ 
// 2. AgentStore updated
AgentStore: updateCustomer(customerData)
↓
// 3. Custom event dispatched
window.dispatchEvent('customer-context:updated', { customer, hasContext: true })
↓
// 4. All tabs receive new context
EmbeddedAppColumn: handleCustomerContextUpdate()
↓
// 5. URLs rebuilt with customer data
buildAppUrl(appKey, true, customerContext) // Switch to context mode
↓
// 6. Iframes reload with customer context
iframe.src = newContextualUrl
```

#### 3. User Manual Intent Selection Flow
```typescript
// 1. User clicks intent dropdown
IntentWidget: onClick(intentId)
↓
// 2. Intent store updated (dropdown only)
IntentStore: selectIntent(intentId) // currentIntent = intentId
↓
// 3. User clicks "Launch App" button  
IntentWidget: onLaunchApp(intentId)
↓
// 4. Embedded app intent updated
IntentStore: setEmbeddedAppIntent(intentId) // embeddedAppIntent = intentId
↓
// 5. Tab created/switched
EmbeddedAppColumn: createTabForIntent(intentId, switchToTab: true)
```

### Performance Optimizations

#### Memoization and Selective Updates
```typescript
// Only re-render when specific fields change
const customer = useAgentStore(state => state.customer)
const intent = useAgentStore(state => state.intent)

// Avoid full re-renders on unrelated updates
const contextData = useMemo(() => ({
  customerId: customer?.id,
  customerName: customer?.name,
  intent: intent?.type
}), [customer?.id, customer?.name, intent?.type])
```

#### Ref-based State Access
```typescript
// Avoid stale closures in event listeners
const agentDataRef = useRef(agentData)
useEffect(() => { agentDataRef.current = agentData }, [agentData])

const handleMessage = useCallback((event) => {
  // Always access current state
  const currentCustomer = agentDataRef.current.customer
}, [])
```

## Tab Lifecycle Management

The tab management system handles the complete lifecycle of embedded apps from creation to cleanup, with sophisticated state tracking and error recovery.

### Tab State Model

```typescript
interface EmbeddedAppTab {
  id: string                    // Unique identifier
  intent: string               // Associated intent
  label: string                // Display name
  url: string                  // Full iframe URL with context
  isLoading: boolean           // Loading state
  error: string | null         // Error message
  handshakeComplete: boolean   // Communication established
  appKey?: string              // For search-launched apps
  context?: any                // Additional metadata
}
```

### Tab Creation Triggers

1. **Intent Detection** (Automatic)
```typescript
// In embedded-app-column.tsx
useEffect(() => {
  const currentIntent = websocketIntent?.type || embeddedAppIntent
  
  if (currentIntent && !closedIntents.has(currentIntent)) {
    createTabForIntent(currentIntent, false) // Don't auto-switch
  }
}, [websocketIntent, embeddedAppIntent])
```

2. **Manual App Launch** (Search)
```typescript
// Global event listener
window.addEventListener('embedded-app:launch', (event) => {
  const app = event.detail
  const newTab = createTabFromSearchResult(app)
  setActiveTabId(newTab.id) // Switch to new tab
})
```

3. **Dropdown Selection** (User Choice)
```typescript
// Intent dropdown interaction
window.addEventListener('intent:dropdown-clicked', (event) => {
  const intentId = event.detail.intent
  
  if (closedIntents.has(intentId)) {
    // Reopen previously closed tab
    closedIntents.delete(intentId)
    createTabForIntent(intentId, true) // Switch to reopened tab
  }
})
```

### Tab Lifecycle Phases

#### 1. Creation Phase
```typescript
const createTabForIntent = (intent: string, switchToTab: boolean) => {
  // Check for duplicates
  const existingTab = tabs.find(tab => tab.intent === intent)
  if (existingTab) return existingTab.id
  
  // Build URL with current context
  const appUrl = buildAppUrl(intent, hasContext, customerContext)
  
  // Create tab object
  const newTab: EmbeddedAppTab = {
    id: `tab-${intent}-${Date.now()}`,
    intent,
    label: getIntentLabel(intent),
    url: appUrl,
    isLoading: true,
    error: null,
    handshakeComplete: false
  }
  
  setTabs(prev => [...prev, newTab])
  if (switchToTab) setActiveTabId(newTab.id)
}
```

#### 2. Loading Phase
```typescript
const handleIframeLoad = (tabId: string) => {
  // Send ping to establish communication
  setTimeout(() => {
    const pingMessage = { type: 'host.ping', tabId }
    iframe.contentWindow?.postMessage(pingMessage, '*')
  }, 300)
  
  // Set handshake timeout (3 seconds)
  handshakeTimeoutRefs.current[tabId] = setTimeout(() => {
    setTabs(prev => prev.map(t => 
      t.id === tabId 
        ? { ...t, error: 'Banking service temporarily unavailable', isLoading: false }
        : t
    ))
  }, 3000)
}
```

#### 3. Ready Phase
```typescript
// When iframe signals ready
case 'embed.ready':
  setTabs(prev => prev.map(tab => 
    tab.id === tabId 
      ? { ...tab, handshakeComplete: true, isLoading: false, error: null }
      : tab
  ))
  
  // Clear timeout
  clearTimeout(handshakeTimeoutRefs.current[tabId])
  
  // Send initial context
  const contextMessage = {
    type: 'host.state',
    context: {
      customerId: agentData.customer?.id,
      customerName: agentData.customer?.name,
      mode: hasContext ? 'context' : 'manual',
      // ... full context
    }
  }
  iframe.contentWindow.postMessage(contextMessage, '*')
```

#### 4. Active Phase
```typescript
// Handle ongoing communication
case 'kms.open':
  // Open knowledge article request
  window.dispatchEvent(new CustomEvent('kms:open-article', {
    detail: { articleId: event.data.articleId }
  }))
  break

case 'action.execute':
  // Execute action in parent context
  handleActionExecution(event.data.action, event.data.params)
  break
```

#### 5. Cleanup Phase
```typescript
const handleCloseTab = (tabId: string) => {
  // Track closed intent
  const tab = tabs.find(t => t.id === tabId)
  if (tab) {
    setClosedIntents(prev => new Set([...prev, tab.intent]))
  }
  
  // Clean up resources
  clearTimeout(handshakeTimeoutRefs.current[tabId])
  delete handshakeTimeoutRefs.current[tabId]
  delete iframeRefs.current[tabId]
  
  // Remove tab
  setTabs(prev => prev.filter(t => t.id !== tabId))
  
  // Switch to another tab if this was active
  if (activeTabId === tabId) {
    const remainingTabs = tabs.filter(t => t.id !== tabId)
    setActiveTabId(remainingTabs[0]?.id || null)
  }
}
```

### Error Recovery Mechanisms

#### 1. Handshake Timeout Recovery
```typescript
const handleRetry = (tabId: string) => {
  // Reset tab state
  setTabs(prev => prev.map(tab => 
    tab.id === tabId 
      ? { ...tab, error: null, isLoading: true, handshakeComplete: false }
      : tab
  ))
  
  // Clear existing timeout
  clearTimeout(handshakeTimeoutRefs.current[tabId])
  
  // Reload iframe
  const iframe = iframeRefs.current[tabId]
  if (iframe) iframe.src = iframe.src
}
```

#### 2. Context Update Recovery
```typescript
// When customer context changes, update all tabs
const handleCustomerContextUpdate = (event: CustomEvent) => {
  const { customer, hasContext } = event.detail
  
  setTabs(prev => prev.map(tab => {
    const newUrl = buildAppUrl(tab.appKey || tab.intent, hasContext, customerContext)
    
    // Only reload if URL actually changed
    if (newUrl !== tab.url) {
      return {
        ...tab,
        url: newUrl,
        isLoading: true,
        handshakeComplete: false // Will re-establish communication
      }
    }
    return tab
  }))
}
```

#### 3. Connection Cleanup
```typescript
// Clean up all tabs when call ends
useEffect(() => {
  if (!isConnected) {
    setTabs([])
    setActiveTabId(null)
    setClosedIntents(new Set())
    
    // Clear all timeouts
    Object.values(handshakeTimeoutRefs.current).forEach(timeout => {
      if (timeout) clearTimeout(timeout)
    })
    handshakeTimeoutRefs.current = {}
    iframeRefs.current = {}
  }
}, [isConnected])
```

## Intent-to-App Mapping System

### Database Schema

Apps are registered in the `embedded_apps` table:

```sql
CREATE TABLE embedded_apps (
    id SERIAL PRIMARY KEY,
    app_key VARCHAR(100) UNIQUE NOT NULL,      -- Unique identifier (e.g., 'credit_card_management')
    title VARCHAR(200) NOT NULL,               -- Display title
    description TEXT,                           -- App description
    category VARCHAR(100),                      -- Category (Cards, Loans, etc.)
    tags TEXT[],                               -- Search tags
    keywords TEXT[],                           -- Search keywords
    search_phrases TEXT[],                      -- Common search phrases
    allowed_roles TEXT[],                       -- ['agent', 'supervisor', 'manager']
    supported_intents TEXT[],                   -- ['credit_card_transactions', 'fraud_alert']
    display_mode VARCHAR(50) DEFAULT 'tab',     -- 'tab', 'modal', 'sidebar'
    priority INTEGER DEFAULT 100,               -- Display priority
    active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Gateway Enrichment Process

The Gateway service (`BroadcastMessageRouter.java`) enriches intents in real-time:

```java
// 1. Intent detected by AI Service
String intent = "credit_card_transactions";

// 2. Gateway queries database
Optional<EmbeddedApp> app = embeddedAppRepository.findByIntentAndRole(intent, "agent");

// 3. Enriches WebSocket message
if (app.isPresent()) {
    message.put("appUrl", "/embedded-apps/" + app.getAppKey());
    message.put("appTitle", app.getTitle());
}

// 4. Sends to frontend with enrichment
websocket.send(enrichedMessage);
```

## Context Propagation

The context propagation system ensures embedded apps receive customer data through multiple synchronized channels with automatic fallback and real-time updates.

### Three-Channel Context Delivery

#### 1. URL Parameters (Initial Bootstrap)
**Purpose**: Provide immediate context when iframe loads
**Timing**: During iframe creation/reload
**Content**: Essential customer identifiers and metadata

```typescript
// URL structure example
http://localhost:5175/embedded-apps/credit_card_management?
  customerId=CUST-123456&
  customerName=Sophie%20Anderson&
  email=sophie@example.com&
  phone=%2B44%2020%207123%204567&
  accountNumber=ACC-789012&
  accountType=PREMIUM&
  customerTier=GOLD&
  intent=credit_card_transactions&
  callerId=CALL-567890&
  mode=context&
  role=agent&
  tabId=tab-credit_card_transactions-1692188400123
```

#### 2. PostMessage API (Real-time Updates)
**Purpose**: Deliver full context object and handle updates
**Timing**: After iframe handshake completion
**Content**: Complete customer object plus system state

```typescript
// Message structure sent to iframe
{
  type: 'host.state',
  context: {
    // Customer identification
    customerId: 'CUST-123456',
    customerName: 'Sophie Anderson',
    email: 'sophie@example.com',
    phone: '+44 20 7123 4567',
    location: 'London, UK',
    
    // Account details
    accountNumber: 'ACC-789012',
    accountType: 'PREMIUM',
    customerTier: 'GOLD',
    cin: 'CIN-345678',
    
    // Call context
    agentId: 'HSB-001',
    callerId: 'CALL-567890',
    intent: 'credit_card_transactions',
    
    // System state
    mode: 'context', // or 'manual'
    hasCustomerContext: true,
    
    // App-specific metadata
    appKey: 'credit_card_management',
    launchedFromSearch: false,
    tabId: 'tab-credit_card_transactions-1692188400123',
    
    // Additional context for advanced apps
    additionalContext: {
      // Intent confidence, detection time, etc.
    }
  }
}
```

#### 3. Custom Events (System-wide Updates)
**Purpose**: Broadcast context changes to all components
**Timing**: When customer identification state changes
**Content**: Delta updates and mode transitions

```typescript
// Dispatched when customer context changes
window.dispatchEvent(new CustomEvent('customer-context:updated', {
  detail: {
    customer: newCustomerData,
    hasContext: true, // Changed from false to true
    previousMode: 'manual',
    newMode: 'context'
  }
}))
```

### Context Update Flow Examples

#### Scenario 1: Customer Identification During Call
```typescript
// 1. Call starts - no customer identified yet
Initial State: { hasContext: false, mode: 'manual' }
URL: http://localhost:5175/embedded-apps/credit_card_management?mode=manual&appKey=credit_card_management

// 2. Customer provides ID - WebSocket receives customer data
WebSocket Message: { type: 'customer', customer: { id: 'CUST-123', name: 'John' } }

// 3. AgentStore updated
AgentStore.updateCustomer(customerData)

// 4. Custom event dispatched
window.dispatchEvent('customer-context:updated', { hasContext: true })

// 5. All tabs receive new context-aware URLs
New URL: http://localhost:5175/embedded-apps/credit_card_management?customerId=CUST-123&customerName=John&mode=context

// 6. Iframes reload with customer context
// 7. New postMessage sent with full customer object
```

#### Scenario 2: Customer Details Updated
```typescript
// Customer address or phone changes during call
// No iframe reload needed - postMessage only

// 1. WebSocket receives updated customer data
WebSocket: { type: 'customer', customer: { ...existing, phone: 'new-number' } }

// 2. AgentStore updates customer object
AgentStore.customer = { ...existing, phone: 'new-number' }

// 3. PostMessage sent to all active tabs
tabs.forEach(tab => {
  iframe.postMessage({
    type: 'host.state',
    context: { ...fullContext, phone: 'new-number' }
  })
})
```

### URL Parameter Structure

Customer context is passed via URL parameters to embedded apps:

```typescript
// URL builder service (url-builder.service.ts)
export function buildAppUrl(
  appKey: string,
  hasContext: boolean,
  context: CustomerContext,
  additionalParams?: Record<string, string>
): string {
  const baseUrl = EMBEDDED_APP_URL || 'http://localhost:5175'
  const params = new URLSearchParams()
  
  // Core context parameters
  if (hasContext && context) {
    params.append('customerId', context.customerId || '')
    params.append('customerName', context.customerName || '')
    params.append('email', context.email || '')
    params.append('phone', context.phone || '')
    params.append('location', context.location || '')
    params.append('accountNumber', context.accountNumber || '')
    params.append('accountType', context.accountType || '')
    params.append('customerTier', context.customerTier || '')
    params.append('cin', context.cin || '')
  }
  
  // Intent and metadata
  params.append('intent', context.intent || appKey)
  params.append('callerId', context.callerId || '')
  params.append('mode', hasContext ? 'context' : 'manual')
  
  // Additional parameters
  if (additionalParams) {
    Object.entries(additionalParams).forEach(([key, value]) => {
      params.append(key, value)
    })
  }
  
  return `${baseUrl}/embedded-apps/${appKey}?${params.toString()}`
}
```

### Available Context Fields

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `customerId` | string | Unique customer ID | `CUST-123456` |
| `customerName` | string | Full name | `Sophie Anderson` |
| `email` | string | Email address | `sophie@example.com` |
| `phone` | string | Phone number | `+44 20 7123 4567` |
| `location` | string | Customer location | `London, UK` |
| `accountNumber` | string | Bank account | `ACC-789012` |
| `accountType` | string | Account type | `PREMIUM` |
| `customerTier` | string | Service tier | `GOLD`, `SILVER`, `BRONZE` |
| `cin` | string | Customer ID number | `CIN-345678` |
| `intent` | string | Current intent | `credit_card_transactions` |
| `callerId` | string | Call session ID | `CALL-567890` |
| `mode` | string | Operation mode | `context` or `manual` |

## Role-based Access Control

The embedded apps system implements sophisticated role-based access control at multiple layers to ensure agents only access appropriate applications for their role and customer tier.

### Role Hierarchy and App Access

```typescript
// Role definitions with app access levels
interface RoleDefinition {
  role: string
  displayName: string
  allowedApps: string[]
  restrictedCustomerTiers?: string[]
  permissions: string[]
}

const ROLE_DEFINITIONS: RoleDefinition[] = [
  {
    role: 'chat_agent',
    displayName: 'Chat Agent',
    allowedApps: [
      'quick_balance',
      'chat_templates', 
      'faq_assistant',
      'account_balance_inquiry'
    ],
    permissions: ['view_basic_info', 'create_support_tickets']
  },
  {
    role: 'agent',
    displayName: 'Call Agent', 
    allowedApps: [
      'credit_card_management',
      'fraud_alert',
      'mortgage_application',
      'account_balance_inquiry',
      'international_transfer',
      'student_loan',
      'account_upgrade',
      'business_loan'
    ],
    permissions: ['view_customer_details', 'process_transactions', 'create_disputes']
  },
  {
    role: 'supervisor',
    displayName: 'Supervisor',
    allowedApps: [
      'wealth_management',
      'escalation_hub',
      'team_overview',
      'credit_card_management',
      'fraud_alert'
    ],
    restrictedCustomerTiers: ['PLATINUM', 'DIAMOND'],
    permissions: ['view_all_customers', 'approve_transactions', 'manage_escalations']
  },
  {
    role: 'manager',
    displayName: 'Manager',
    allowedApps: [
      'team_performance',
      'quality_assurance', 
      'audit_dashboard',
      'escalation_hub'
    ],
    permissions: ['view_reports', 'manage_team', 'approve_policies']
  },
  {
    role: 'admin',
    displayName: 'Administrator',
    allowedApps: [
      'system_admin',
      'user_management',
      'audit_logs',
      'security_center'
    ],
    permissions: ['full_access']
  }
]
```

### Multi-layer Access Control

#### 1. Database Level (Gateway Service)
```java
// In BroadcastMessageRouter.java
Optional<EmbeddedApp> app = embeddedAppRepository.findByIntentAndRole(intent, userRole);

// SQL query with role filtering
SELECT * FROM embedded_apps 
WHERE 'credit_card_transactions' = ANY(supported_intents)
AND 'agent' = ANY(allowed_roles)
AND active = true;
```

#### 2. Frontend Search Filtering
```typescript
// In use-embedded-app-search.ts
const userContext: UserContext = useMemo(() => {
  const mapAuthRoleToSearchRole = (authRole?: string) => {
    switch (authRole) {
      case 'chat_agent': return 'chat_agent'
      case 'supervisor': return 'supervisor'  
      case 'manager': return 'manager'
      case 'admin': return 'admin'
      case 'agent':
      default: return 'agent'
    }
  }

  return {
    role: mapAuthRoleToSearchRole(currentRole || user?.role),
    customerTier: agentData?.customer?.tier || 'standard',
    currentIntent: embeddedAppIntent
  }
}, [currentRole, user?.role, agentData?.customer?.tier, embeddedAppIntent])
```

#### 3. Component Level Access
```typescript
// In embedded-app-column.tsx - Role-based app availability check
const isAppAvailableForRole = useCallback((appKey: string, role: string) => {
  const roleApps: Record<string, string[]> = {
    'chat_agent': ['quick_balance', 'chat_templates'],
    'agent': ['credit_card_management', 'fraud_alert', 'mortgage_application'], 
    'supervisor': ['wealth_management', 'escalation_hub', 'team_overview'],
    'manager': ['team_performance', 'quality_assurance'],
    'admin': ['system_admin', 'user_management']
  }
  
  return roleApps[role]?.includes(appKey) || false
}, [])
```

### Customer Tier-based Restrictions

```typescript
// Enhanced role checking with customer tier validation
const validateAppAccess = (appKey: string, userRole: string, customerTier: string) => {
  // Check basic role access
  if (!isAppAvailableForRole(appKey, userRole)) {
    return { allowed: false, reason: 'INSUFFICIENT_ROLE' }
  }
  
  // Check customer tier restrictions
  const tierRestrictions = {
    'wealth_management': ['PLATINUM', 'DIAMOND'], // Supervisor+ only for high-value customers
    'private_banking': ['DIAMOND'],               // Manager+ only for ultra-high-value
    'business_loan': ['BUSINESS', 'CORPORATE']    // Only for business customers
  }
  
  const requiredTiers = tierRestrictions[appKey]
  if (requiredTiers && !requiredTiers.includes(customerTier)) {
    return { allowed: false, reason: 'CUSTOMER_TIER_RESTRICTION' }
  }
  
  return { allowed: true }
}
```

### Role Context Propagation

#### 1. URL Parameters
```typescript
// Role included in app URLs
const appUrl = buildAppUrl(appKey, hasContext, customerContext, {
  role: currentRole, // 'agent', 'supervisor', etc.
  tabId: `tab-${intent}-${Date.now()}`
})
```

#### 2. PostMessage Context
```typescript
// Role sent via postMessage to embedded apps
const contextMessage = {
  type: 'host.state',
  context: {
    // ... customer data
    agentRole: currentRole,
    permissions: getRolePermissions(currentRole),
    allowedActions: getAllowedActions(currentRole, customerTier)
  }
}
```

#### 3. Search Headers
```typescript
// Role-based search filtering
const headers: Record<string, string> = {
  'Content-Type': 'application/json',
  'X-Agent-Role': userContext.role,
  'X-Customer-Tier': userContext.customerTier
}
```

### Access Control Examples

#### Example 1: Chat Agent Restrictions
```typescript
// Chat agent tries to access wealth management
Role: 'chat_agent'
Requested App: 'wealth_management'
Customer Tier: 'PLATINUM'

// Validation result
validateAppAccess('wealth_management', 'chat_agent', 'PLATINUM')
// Returns: { allowed: false, reason: 'INSUFFICIENT_ROLE' }

// Available apps for chat agent
getAllowedApps('chat_agent')
// Returns: ['quick_balance', 'chat_templates', 'faq_assistant']
```

#### Example 2: Supervisor with High-Value Customer
```typescript
// Supervisor accessing wealth management for platinum customer
Role: 'supervisor'
Requested App: 'wealth_management'  
Customer Tier: 'PLATINUM'

// Validation result
validateAppAccess('wealth_management', 'supervisor', 'PLATINUM')
// Returns: { allowed: true }

// App loads with full wealth management features
```

#### Example 3: Agent with Business Customer
```typescript
// Agent trying to access business loan app
Role: 'agent'
Requested App: 'business_loan'
Customer Tier: 'BUSINESS'

// Validation result  
validateAppAccess('business_loan', 'agent', 'BUSINESS')
// Returns: { allowed: true }

// Business-specific features enabled in app
```

### Security Headers and Validation

```typescript
// Enhanced security validation in WebSocket context
const validateWebSocketAccess = (userRole: string, requestedAction: string) => {
  const rolePermissions = {
    'chat_agent': ['view_basic_info', 'create_tickets'],
    'agent': ['view_customer_details', 'process_basic_transactions'],
    'supervisor': ['view_all_customers', 'approve_transactions'],
    'manager': ['view_reports', 'manage_team'],
    'admin': ['full_access']
  }
  
  const permissions = rolePermissions[userRole] || []
  return permissions.includes(requestedAction) || permissions.includes('full_access')
}
```

## Integration Steps

### Step 1: Register Your App in Database

```sql
-- Add your app to embedded_apps table
INSERT INTO embedded_apps (
    app_key,
    title,
    description,
    category,
    supported_intents,
    allowed_roles,
    priority
) VALUES (
    'your_app_key',           -- Unique identifier
    'Your App Title',         -- Display name
    'App description',        -- Description
    'Category',              -- Category
    ARRAY['intent1', 'intent2'],  -- Supported intents
    ARRAY['agent', 'supervisor'],  -- Allowed roles
    100                      -- Priority
);
```

### Step 2: Create Your Embedded App

Create a React app that reads URL parameters:

```jsx
// App.jsx in your embedded app
import React, { useState, useEffect } from 'react';

export const AppContext = React.createContext({});

function App() {
  const [context, setContext] = useState({});
  const [isReady, setIsReady] = useState(false);
  
  useEffect(() => {
    // Parse URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    
    const initialContext = {
      customerId: urlParams.get('customerId') || '',
      customerName: urlParams.get('customerName') || '',
      email: urlParams.get('email') || '',
      phone: urlParams.get('phone') || '',
      location: urlParams.get('location') || '',
      accountNumber: urlParams.get('accountNumber') || '',
      accountType: urlParams.get('accountType') || '',
      customerTier: urlParams.get('customerTier') || '',
      intent: urlParams.get('intent') || '',
      mode: urlParams.get('mode') || 'manual',
    };
    
    setContext(initialContext);
    
    // Send ready signal to parent
    window.parent.postMessage({ type: 'embed.ready' }, '*');
    
    // Listen for updates from parent
    const handleMessage = (event) => {
      if (event.data.type === 'host.state') {
        setContext(prev => ({ ...prev, ...event.data.context }));
      }
    };
    
    window.addEventListener('message', handleMessage);
    setIsReady(true);
    
    return () => window.removeEventListener('message', handleMessage);
  }, []);
  
  if (!isReady) {
    return <div>Loading...</div>;
  }
  
  return (
    <AppContext.Provider value={{ context, setContext }}>
      <YourAppContent />
    </AppContext.Provider>
  );
}
```

### Step 3: Handle Communication

```jsx
// Component in your embedded app
import { useContext } from 'react';
import { AppContext } from './App';

function YourComponent() {
  const { context } = useContext(AppContext);
  
  // Send message to parent
  const openKnowledgeArticle = (articleId) => {
    window.parent.postMessage({
      type: 'kms.open',
      articleId: articleId
    }, '*');
  };
  
  // Execute action in parent
  const executeAction = (action, params) => {
    window.parent.postMessage({
      type: 'action.execute',
      action: action,
      params: params
    }, '*');
  };
  
  return (
    <div>
      <h1>Welcome {context.customerName || 'Guest'}</h1>
      <p>Email: {context.email || 'Not provided'}</p>
      <p>Mode: {context.mode}</p>
      
      <button onClick={() => openKnowledgeArticle('ARTICLE-123')}>
        Open Help Article
      </button>
    </div>
  );
}
```

## Code Implementation

### Frontend Integration (embedded-app-column.tsx)

Key sections of the integration code:

```typescript
// 1. Listen for intent detection
useEffect(() => {
  const currentIntent = websocketIntent?.type || embeddedAppIntent;
  const hasEnrichedAppData = !!(websocketIntent?.appUrl && websocketIntent?.appTitle);
  
  if (!currentIntent || !isConnected) return;
  
  // Check if user closed this intent
  if (closedIntents.has(currentIntent)) return;
  
  // Check for existing tab
  const existingTab = tabs.find(tab => tab.intent === currentIntent);
  if (existingTab) return;
  
  let appUrl: string;
  let appTitle: string;
  
  if (hasEnrichedAppData) {
    // Use WebSocket enriched data
    appUrl = `${EMBEDDED_APP_URL}${websocketIntent.appUrl}`;
    appTitle = websocketIntent.appTitle!;
    
    // Prevent duplicate tabs for same app
    const existingAppTab = tabs.find(tab => 
      tab.url.startsWith(`${EMBEDDED_APP_URL}${websocketIntent.appUrl}`)
    );
    if (existingAppTab) return;
  } else {
    // Fallback to traditional URL building
    const customerContext: CustomerContext = {
      customerId: agentData.customer?.id || '',
      customerName: agentData.customer?.name,
      email: agentData.customer?.email,
      phone: agentData.customer?.phone,
      location: agentData.customer?.location,
      // ... other fields
    };
    
    appUrl = buildAppUrl(currentIntent, hasContext, customerContext, {
      role: 'agent',
      tabId: `tab-${currentIntent}-${Date.now()}`
    });
    appTitle = getIntentLabel(currentIntent);
  }
  
  // Create new tab
  const newTab: EmbeddedAppTab = {
    id: `tab-${currentIntent}-${Date.now()}`,
    intent: currentIntent,
    label: appTitle,
    url: appUrl,
    isLoading: true,
    error: null,
    handshakeComplete: false
  };
  
  setTabs(prev => [...prev, newTab]);
}, [embeddedAppIntent, websocketIntent, isConnected]);

// 2. Handle iframe communication
useEffect(() => {
  const handleMessage = (event: MessageEvent) => {
    // Verify origin
    if (!ALLOWED_ORIGINS.includes(event.origin)) return;
    
    switch (event.data.type) {
      case 'embed.ready':
        // App loaded successfully
        setTabs(prev => prev.map(tab => 
          tab.id === event.data.tabId 
            ? { ...tab, handshakeComplete: true, isLoading: false }
            : tab
        ));
        
        // Send initial state
        const message = {
          type: 'host.state',
          context: {
            customerId: agentData.customer?.id,
            customerName: agentData.customer?.name,
            // ... other context
          }
        };
        iframe.contentWindow.postMessage(message, '*');
        break;
        
      case 'kms.open':
        // Open knowledge article
        window.dispatchEvent(new CustomEvent('kms:open-article', {
          detail: { articleId: event.data.articleId }
        }));
        break;
    }
  };
  
  window.addEventListener('message', handleMessage);
  return () => window.removeEventListener('message', handleMessage);
}, [agentData]);
```

## Troubleshooting Guide

### Enable Debug Mode

Add debug logging to track issues:

```typescript
// In embedded-app-column.tsx
const DEBUG = import.meta.env.DEV || window.location.search.includes('debug=true');

if (DEBUG) {
  console.log('[EmbeddedAppColumn] Intent detected:', {
    intent: currentIntent,
    appUrl: websocketIntent?.appUrl,
    appTitle: websocketIntent?.appTitle,
    customer: agentData.customer,
    timestamp: new Date().toISOString()
  });
}
```

### Browser Console Commands

```javascript
// Check current tabs
document.querySelectorAll('iframe').forEach(f => console.log(f.src))

// Check WebSocket connection
window.__WEBSOCKET_STATE__ // If exposed by app

// Manually trigger intent
window.dispatchEvent(new CustomEvent('intent:detected', {
  detail: { intent: 'credit_card_transactions' }
}));

// Check postMessage communication
window.addEventListener('message', (e) => console.log('Message:', e.data));
```

## Common Issues & Solutions

### Issue 1: App Not Loading

**Symptoms**: Blank iframe or loading spinner stuck

**Debugging Steps**:
```javascript
// 1. Check if app is registered in database
SELECT * FROM embedded_apps WHERE app_key = 'your_app_key';

// 2. Check WebSocket enrichment
// In browser console, look for:
[EmbeddedAppColumn] Using WebSocket enriched app data: {
  intent: "credit_card_transactions",
  appUrl: "/embedded-apps/credit_card_management",
  appTitle: "Credit Card Management"
}

// 3. Check iframe URL
// Should be: http://localhost:5175/embedded-apps/your_app?customerId=123&...
```

**Solutions**:
- Ensure app is registered in `embedded_apps` table
- Verify `supported_intents` includes the detected intent
- Check if embedded service is running (port 5175)
- Verify CORS/origin settings

### Issue 2: No Customer Context

**Symptoms**: App shows "Guest" or default values

**Debugging Steps**:
```javascript
// 1. Check URL parameters
const urlParams = new URLSearchParams(window.location.search);
console.log('Customer ID:', urlParams.get('customerId'));
console.log('Customer Name:', urlParams.get('customerName'));

// 2. Check parent context
// In parent app console:
console.log('Agent Data:', agentData.customer);

// 3. Verify mode
console.log('Mode:', urlParams.get('mode')); // Should be 'context' if customer identified
```

**Solutions**:
- Ensure customer is identified before intent detection
- Check if `buildAppUrl` is called with `hasContext = true`
- Verify customer data is available in `agentData.customer`

### Issue 3: Duplicate Tabs

**Symptoms**: Same app opens multiple times

**Debugging**:
```javascript
// Check for duplicate prevention
const existingAppTab = tabs.find(tab => 
  tab.url.startsWith(`${EMBEDDED_APP_URL}${websocketIntent.appUrl}`)
);
console.log('Existing tab found:', existingAppTab);
```

**Solutions**:
- Ensure deduplication check is in place (lines 331-337 in embedded-app-column.tsx)
- Verify `appUrl` is consistent for same app
- Check if multiple intents map to same app

### Issue 4: Communication Failures

**Symptoms**: postMessage not working

**Debugging**:
```javascript
// In embedded app:
window.parent.postMessage({ type: 'test' }, '*');

// In parent:
window.addEventListener('message', (e) => {
  console.log('Origin:', e.origin);
  console.log('Data:', e.data);
});
```

**Solutions**:
- Check ALLOWED_ORIGINS configuration
- Verify iframe sandbox attributes allow scripts
- Ensure both apps are on same protocol (http/https)

### Issue 5: WebSocket Not Enriching

**Symptoms**: No appUrl/appTitle in intent

**Debugging**:
```java
// Check Gateway logs
[BroadcastRouter] Intent enriched: credit_card_transactions -> /embedded-apps/credit_card_management

// Check database query
SELECT * FROM embedded_apps 
WHERE 'credit_card_transactions' = ANY(supported_intents)
AND 'agent' = ANY(allowed_roles);
```

**Solutions**:
- Restart Gateway service after database changes
- Clear intent cache in Gateway (if implemented)
- Verify role matches allowed_roles in database

## Debugging Tools

### 1. Network Inspector

Monitor iframe loading:
```javascript
// Add to embedded-app-column.tsx
const monitorIframe = (iframe) => {
  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (entry.name.includes('embedded-apps')) {
        console.log('Iframe load time:', entry.duration, 'ms');
      }
    }
  });
  observer.observe({ entryTypes: ['resource'] });
};
```

### 2. Context Validator

Validate context completeness:
```javascript
// Add to embedded app
const validateContext = (context) => {
  const required = ['customerId', 'customerName', 'intent'];
  const missing = required.filter(field => !context[field]);
  
  if (missing.length > 0) {
    console.warn('Missing required context fields:', missing);
    console.log('Current context:', context);
  }
  
  return missing.length === 0;
};
```

### 3. Intent Flow Tracer

Track intent through the system:
```javascript
// Add trace logging
const traceIntent = (intent, stage) => {
  console.log(`[TRACE] Intent: ${intent} | Stage: ${stage} | Time: ${new Date().toISOString()}`);
};

// Use throughout the flow:
traceIntent('credit_card_transactions', 'AI_DETECTED');
traceIntent('credit_card_transactions', 'GATEWAY_ENRICHED');
traceIntent('credit_card_transactions', 'FRONTEND_RECEIVED');
traceIntent('credit_card_transactions', 'TAB_CREATED');
traceIntent('credit_card_transactions', 'IFRAME_LOADED');
```

### 4. Database Verification Script

```sql
-- Check app configuration
SELECT 
  app_key,
  title,
  supported_intents,
  allowed_roles,
  active
FROM embedded_apps
WHERE active = true
ORDER BY priority DESC;

-- Check intent coverage
SELECT 
  unnest(supported_intents) as intent,
  COUNT(*) as app_count,
  array_agg(app_key) as apps
FROM embedded_apps
WHERE active = true
GROUP BY intent
ORDER BY app_count DESC;

-- Find unmapped intents (requires intent list)
WITH all_intents AS (
  SELECT unnest(ARRAY[
    'credit_card_transactions',
    'fraud_alert',
    'loan_application',
    -- ... add all intents
  ]) as intent
)
SELECT 
  ai.intent,
  ea.app_key
FROM all_intents ai
LEFT JOIN embedded_apps ea 
  ON ai.intent = ANY(ea.supported_intents)
WHERE ea.app_key IS NULL;
```

## Performance Optimization

### 1. Lazy Loading

Load apps only when needed:
```typescript
const loadApp = async (appKey: string) => {
  // Dynamic import for code splitting
  const module = await import(`./apps/${appKey}`);
  return module.default;
};
```

### 2. Context Caching

Cache customer context to avoid redundant fetches:
```typescript
const contextCache = new Map();

const getCachedContext = (customerId: string) => {
  if (contextCache.has(customerId)) {
    const cached = contextCache.get(customerId);
    if (Date.now() - cached.timestamp < 60000) { // 1 minute cache
      return cached.data;
    }
  }
  return null;
};
```

### 3. Iframe Pooling

Reuse iframes for better performance:
```typescript
const iframePool = [];
const MAX_POOL_SIZE = 5;

const getIframe = () => {
  return iframePool.pop() || createNewIframe();
};

const releaseIframe = (iframe) => {
  if (iframePool.length < MAX_POOL_SIZE) {
    iframe.src = 'about:blank';
    iframePool.push(iframe);
  }
};
```

## Security Considerations

### Origin Validation

Always validate message origins:
```typescript
const ALLOWED_ORIGINS = [
  'http://localhost:5175',
  'https://embedded.hsbc.com'
];

window.addEventListener('message', (event) => {
  if (!ALLOWED_ORIGINS.includes(event.origin)) {
    console.warn('Rejected message from untrusted origin:', event.origin);
    return;
  }
  // Process message
});
```

### Input Sanitization

Sanitize URL parameters:
```javascript
const sanitizeParam = (value) => {
  return value
    .replace(/[<>]/g, '')  // Remove potential HTML
    .replace(/javascript:/gi, '')  // Remove JS protocol
    .substring(0, 200);  // Limit length
};
```

### Content Security Policy

Set appropriate CSP headers:
```html
<meta http-equiv="Content-Security-Policy" 
      content="frame-src 'self' http://localhost:5175 https://embedded.hsbc.com;">
```

## Performance Considerations

### Memory Management

Monitor memory usage with multiple tabs:
```typescript
// Memory leak prevention
const cleanupTab = (tabId: string) => {
  // Clear iframe references
  delete iframeRefs.current[tabId]
  
  // Clear timeout references
  if (handshakeTimeoutRefs.current[tabId]) {
    clearTimeout(handshakeTimeoutRefs.current[tabId])
    delete handshakeTimeoutRefs.current[tabId]
  }
  
  // Force garbage collection hint
  if (window.gc && process.env.NODE_ENV === 'development') {
    window.gc()
  }
}
```

### Bundle Size Optimization

Keep embedded apps lightweight:
```json
// package.json optimization
{
  "scripts": {
    "analyze": "npm run build && npx webpack-bundle-analyzer build/static/js/*.js"
  },
  "dependencies": {
    // Prefer lighter alternatives
    "date-fns": "^2.0.0", // instead of moment.js
    "react-virtual": "^2.0.0" // for large lists
  }
}
```

### Connection Pooling

Optimize WebSocket connections:
```typescript
// Shared connection management
class ConnectionManager {
  private static instance: ConnectionManager
  private connections: Map<string, WebSocket> = new Map()
  
  getConnection(url: string): WebSocket {
    if (!this.connections.has(url)) {
      const ws = new WebSocket(url)
      this.connections.set(url, ws)
    }
    return this.connections.get(url)!
  }
  
  closeConnection(url: string) {
    const ws = this.connections.get(url)
    if (ws) {
      ws.close()
      this.connections.delete(url)
    }
  }
}
```

### Performance Monitoring

Track key metrics:
```typescript
// Performance monitoring
const performanceMonitor = {
  trackTabLoad: (tabId: string, startTime: number) => {
    const loadTime = Date.now() - startTime
    
    // Report to analytics
    if (window.gtag) {
      window.gtag('event', 'embedded_app_load', {
        custom_parameter_1: tabId,
        custom_parameter_2: loadTime,
        custom_parameter_3: loadTime > 3000 ? 'slow' : 'fast'
      })
    }
    
    // Log for debugging
    console.log(`Tab ${tabId} loaded in ${loadTime}ms`)
  },
  
  trackHandshakeTimeout: (tabId: string) => {
    console.warn(`Handshake timeout for tab ${tabId}`)
    
    // Report timeout issue
    if (window.gtag) {
      window.gtag('event', 'embedded_app_timeout', {
        custom_parameter_1: tabId
      })
    }
  }
}
```

## Advanced Debugging

### Debug Mode Configuration

Enable comprehensive debugging:
```typescript
// Debug configuration
const DEBUG_CONFIG = {
  enabled: process.env.NODE_ENV === 'development' || localStorage.getItem('debug-embedded-apps') === 'true',
  logLevel: 'trace', // 'error', 'warn', 'info', 'debug', 'trace'
  enablePerformanceTracking: true,
  enableNetworkMonitoring: true
}

// Enhanced trace logging
export const traceLog = (message: string, data?: any) => {
  if (!DEBUG_CONFIG.enabled) return
  
  const timestamp = new Date().toISOString()
  const caller = new Error().stack?.split('\n')[2]?.trim()
  
  console.group(`🔍 [TRACE] ${timestamp}`)
  console.log(message)
  if (data) console.log('Data:', data)
  if (caller) console.log('Caller:', caller)
  console.groupEnd()
}
```

### Development Tools

Browser extension for debugging:
```typescript
// Developer tools integration
declare global {
  interface Window {
    __HSBC_DEBUG__: {
      embeddedApps: {
        tabs: EmbeddedAppTab[]
        activeTabId: string | null
        closedIntents: Set<string>
        getTabState: (tabId: string) => EmbeddedAppTab | undefined
        forceReload: (tabId: string) => void
        simulateIntent: (intent: string) => void
        clearAllTabs: () => void
      }
    }
  }
}

// Expose debug interface
if (DEBUG_CONFIG.enabled) {
  window.__HSBC_DEBUG__ = {
    embeddedApps: {
      get tabs() { return tabs },
      get activeTabId() { return activeTabId },
      get closedIntents() { return closedIntents },
      getTabState: (tabId: string) => tabs.find(t => t.id === tabId),
      forceReload: (tabId: string) => handleRetry(tabId),
      simulateIntent: (intent: string) => createTabForIntent(intent, true),
      clearAllTabs: () => {
        setTabs([])
        setActiveTabId(null)
        setClosedIntents(new Set())
      }
    }
  }
}
```

### Network Monitoring

Track iframe communication:
```typescript
// Message logging
const originalPostMessage = window.postMessage
window.postMessage = function(message, targetOrigin, transfer) {
  if (DEBUG_CONFIG.enableNetworkMonitoring) {
    console.log('📤 [IFRAME] Outgoing message:', {
      message,
      targetOrigin,
      timestamp: new Date().toISOString()
    })
  }
  return originalPostMessage.call(this, message, targetOrigin, transfer)
}

// Incoming message logging
window.addEventListener('message', (event) => {
  if (DEBUG_CONFIG.enableNetworkMonitoring) {
    console.log('📥 [IFRAME] Incoming message:', {
      type: event.data.type,
      origin: event.origin,
      data: event.data,
      timestamp: new Date().toISOString()
    })
  }
})
```

### Error Tracking

Comprehensive error monitoring:
```typescript
// Error boundary for embedded apps
class EmbeddedAppErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false, error: null }
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error }
  }
  
  componentDidCatch(error, errorInfo) {
    // Log error details
    console.error('🚨 [EMBEDDED-APP] Error boundary caught:', {
      error: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      tabId: this.props.tabId,
      timestamp: new Date().toISOString()
    })
    
    // Report to error tracking service
    if (window.Sentry) {
      window.Sentry.captureException(error, {
        tags: {
          component: 'embedded-app-column',
          tabId: this.props.tabId
        },
        extra: errorInfo
      })
    }
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <Alert className="m-4">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            Banking service encountered an error. 
            <Button onClick={() => this.setState({ hasError: false, error: null })}>
              Reset View
            </Button>
          </AlertDescription>
        </Alert>
      )
    }
    
    return this.props.children
  }
}
```

### Diagnostic Commands

Console commands for debugging:
```typescript
// Diagnostic utilities
const debugCommands = {
  // Get system state
  getState: () => ({
    tabs: tabs.length,
    activeTab: activeTabId,
    connectedApps: tabs.filter(t => t.handshakeComplete).length,
    erroredApps: tabs.filter(t => t.error).length,
    loadingApps: tabs.filter(t => t.isLoading).length,
    closedIntents: Array.from(closedIntents),
    agentData: {
      hasCustomer: !!agentData.customer?.id,
      customerTier: agentData.customer?.tier,
      intent: agentData.intent?.type
    }
  }),
  
  // Test handshake
  testHandshake: (tabId: string) => {
    const iframe = iframeRefs.current[tabId]
    if (iframe?.contentWindow) {
      iframe.contentWindow.postMessage({ type: 'host.ping', tabId }, '*')
      console.log(`🏓 Sent ping to tab ${tabId}`)
    }
  },
  
  // Simulate context change
  simulateContext: (customerId: string, customerName: string) => {
    window.dispatchEvent(new CustomEvent('customer-context:updated', {
      detail: {
        customer: { id: customerId, name: customerName },
        hasContext: true
      }
    }))
  }
}

// Expose to console
if (DEBUG_CONFIG.enabled) {
  Object.assign(window, { debugEmbeddedApps: debugCommands })
}
```

## Testing Checklist

Before deploying a new embedded app:

- [ ] App registered in `embedded_apps` table
- [ ] Supported intents configured correctly
- [ ] URL parameter parsing works
- [ ] Context displays correctly
- [ ] postMessage handshake completes
- [ ] App loads in under 3 seconds
- [ ] Error states handled gracefully
- [ ] Works in both context and manual modes
- [ ] Tab closing/reopening works
- [ ] No duplicate tabs created
- [ ] Security origins validated
- [ ] Performance acceptable with multiple tabs

## Support

For additional help:
- Check browser console for detailed logs
- Review Gateway logs for enrichment issues
- Verify database configuration
- Test with debug mode enabled
- CCAAS platform team for infrastructure issues
===END FILE===

===BEGIN FILE: docs/mock-data-configuration.md===
# HSBC CCAAS Platform - Mock Data Configuration Guide

## Overview

The HSBC CCAAS Platform supports both production and mock data modes, allowing developers to work without backend dependencies and enabling comprehensive testing scenarios. All mock data has been externalized to JSON configuration files for easy modification.

## Configuration Structure

### Directory Layout
```
frontend/
└── public/
    └── config/
        ├── chat-ai-responses.json      # AI personality and responses
        ├── mock-agents.json             # Team agent data
        ├── response-templates.json      # Quick response templates
        └── sample-notifications.json   # Notification examples
```

## Enabling Mock Data Mode

### Environment Configuration
Set the following environment variable to enable mock data:

```bash
# .env.local or .env
VITE_ENABLE_MOCK_DATA=true
VITE_ENABLE_DEBUG_LOGGING=false
```

### Runtime Toggle
Mock data can be toggled at runtime through the settings panel:

```typescript
// Access via settings panel or programmatically
const enableMockData = import.meta.env.VITE_ENABLE_MOCK_DATA === 'true'
```

## Mock Data Files

### 1. Chat AI Responses
Location: `public/config/chat-ai-responses.json`

Structure:
```json
{
  "personalities": {
    "professional": {
      "traits": ["formal", "efficient", "knowledgeable"],
      "responses": {
        "greeting": ["Good day", "Hello"],
        "acknowledgment": ["Understood", "Certainly"],
        "closing": ["Thank you for ccaasing us", "Have a great day"]
      }
    },
    "friendly": {
      "traits": ["warm", "conversational", "helpful"],
      "responses": {
        "greeting": ["Hi there", "Hello"],
        "acknowledgment": ["Got it", "Sure thing"],
        "closing": ["Thanks for reaching out", "Take care"]
      }
    }
  },
  "scenarios": {
    "credit_card_fraud": {
      "customer_messages": [
        "I see a charge I didn't make",
        "There's a fraudulent transaction on my card"
      ],
      "agent_responses": [
        "I'll help you with that suspicious charge immediately",
        "Let me secure your account and investigate this transaction"
      ],
      "resolution_steps": [
        "Block the card",
        "Initiate dispute",
        "Issue replacement card"
      ]
    }
  },
  "customers": [
    {
      "id": "CUST001",
      "name": "Jonathan Mitchell",
      "email": "j.mitchell@example.com",
      "phone": "+44-20-7946-0958",
      "accountType": "Premier Banking",
      "accountNumber": "****4521",
      "location": "London, UK",
      "segment": "High Value",
      "history": {
        "lastCCAAS": "2024-01-10",
        "totalCCAASs": 12,
        "satisfactionScore": 4.8
      }
    }
  ]
}
```

### 2. Mock Agents
Location: `public/config/mock-agents.json`

Structure:
```json
{
  "agents": [
    {
      "id": "AGT001",
      "name": "Sarah Johnson",
      "status": "available",
      "team": "Premier Support",
      "skills": ["premier_banking", "investments", "loans"],
      "metrics": {
        "callsHandled": 45,
        "avgHandleTime": 240,
        "satisfaction": 4.8,
        "availability": 0.92
      },
      "currentActivity": {
        "type": "idle",
        "duration": 0,
        "customer": null
      }
    }
  ],
  "teams": [
    {
      "id": "TEAM001",
      "name": "Premier Support",
      "agentCount": 12,
      "activeAgents": 10,
      "queueSize": 3,
      "avgWaitTime": 45
    }
  ]
}
```

### 3. Response Templates
Location: `public/config/response-templates.json`

Structure:
```json
{
  "categories": [
    {
      "id": "greetings",
      "name": "Greetings",
      "templates": [
        {
          "id": "welcome_premier",
          "title": "Premier Welcome",
          "text": "Good [time_of_day], thank you for ccaasing HSBC Premier Banking. My name is [agent_name]. How may I assist you today?",
          "variables": ["time_of_day", "agent_name"],
          "tags": ["greeting", "premier"],
          "usage_count": 1250
        }
      ]
    },
    {
      "id": "common_issues",
      "name": "Common Issues",
      "templates": [
        {
          "id": "card_block",
          "title": "Card Blocked",
          "text": "I've successfully blocked your card ending in [card_last_four]. A replacement card will be sent to your registered address within [delivery_days] business days.",
          "variables": ["card_last_four", "delivery_days"],
          "tags": ["card", "security"],
          "usage_count": 890
        }
      ]
    }
  ]
}
```

### 4. Sample Notifications
Location: `public/config/sample-notifications.json`

Structure:
```json
{
  "notifications": [
    {
      "id": "NOT001",
      "type": "system",
      "priority": "high",
      "title": "System Maintenance",
      "message": "Scheduled maintenance window: Tonight 2 AM - 4 AM GMT",
      "timestamp": "2024-01-15T14:00:00Z",
      "actions": [
        {
          "label": "View Details",
          "action": "view_maintenance"
        }
      ]
    },
    {
      "id": "NOT002",
      "type": "customer",
      "priority": "medium",
      "title": "VIP Customer in Queue",
      "message": "Jonathan Mitchell (Premier Banking) is waiting - Priority: URGENT",
      "timestamp": "2024-01-15T14:30:00Z",
      "actions": [
        {
          "label": "Accept Call",
          "action": "accept_priority_call"
        }
      ]
    }
  ]
}
```

## Loading Mock Data

### Automatic Loading
Mock data is automatically loaded when enabled:

```typescript
// src/services/config.service.ts
export class ConfigService {
  private static async loadMockData() {
    if (import.meta.env.VITE_ENABLE_MOCK_DATA === 'true') {
      const responses = await Promise.all([
        fetch('/config/chat-ai-responses.json'),
        fetch('/config/mock-agents.json'),
        fetch('/config/response-templates.json'),
        fetch('/config/sample-notifications.json')
      ])
      
      return {
        chatResponses: await responses[0].json(),
        agents: await responses[1].json(),
        templates: await responses[2].json(),
        notifications: await responses[3].json()
      }
    }
    return null
  }
}
```

### Manual Loading
Load specific mock data on demand:

```typescript
// Load specific mock data file
const loadMockAgents = async () => {
  const response = await fetch('/config/mock-agents.json')
  const data = await response.json()
  return data.agents
}

// Use in component
useEffect(() => {
  if (useMockData) {
    loadMockAgents().then(agents => {
      setAgents(agents)
    })
  }
}, [useMockData])
```

## Mock Data Scenarios

### 1. Simulating Incoming Calls
```typescript
const simulateIncomingCall = () => {
  const mockCallers = mockData.chatResponses.customers
  const randomCaller = mockCallers[Math.floor(Math.random() * mockCallers.length)]
  
  startCall(randomCaller.phone, {
    id: randomCaller.id,
    name: randomCaller.name,
    phone: randomCaller.phone,
    priority: randomCaller.segment === 'High Value' ? 'high' : 'medium',
    issueCategory: 'general',
    issueDescription: 'Customer inquiry'
  })
}
```

### 2. Generating AI Responses
```typescript
const generateAIResponse = (customerMessage: string) => {
  const scenario = detectScenario(customerMessage)
  const responses = mockData.chatResponses.scenarios[scenario].agent_responses
  return responses[Math.floor(Math.random() * responses.length)]
}
```

### 3. Populating Team Status
```typescript
const populateTeamStatus = () => {
  const teams = mockData.agents.teams
  return teams.map(team => ({
    ...team,
    agents: mockData.agents.agents.filter(a => a.team === team.name)
  }))
}
```

## Customizing Mock Data

### Adding New Customers
Edit `public/config/chat-ai-responses.json`:

```json
{
  "customers": [
    {
      "id": "CUST999",
      "name": "New Customer",
      "email": "new.customer@example.com",
      "phone": "+44-20-7999-9999",
      "accountType": "Personal Banking",
      "accountNumber": "****9999",
      "location": "Manchester, UK",
      "segment": "Standard",
      "history": {
        "lastCCAAS": "2024-01-15",
        "totalCCAASs": 1,
        "satisfactionScore": 0
      }
    }
  ]
}
```

### Creating Custom Scenarios
Add new scenarios to handle specific cases:

```json
{
  "scenarios": {
    "custom_scenario": {
      "trigger_keywords": ["specific", "issue"],
      "customer_messages": [
        "I have a specific issue with..."
      ],
      "agent_responses": [
        "I'll help you with that specific issue..."
      ],
      "resolution_steps": [
        "Step 1",
        "Step 2"
      ],
      "estimated_duration": 300
    }
  }
}
```

### Modifying Response Templates
Customize templates for your organization:

```json
{
  "templates": [
    {
      "id": "custom_greeting",
      "title": "Custom Greeting",
      "text": "Welcome to [company_name]. This is [agent_name], how can I help?",
      "variables": ["company_name", "agent_name"],
      "tags": ["greeting", "custom"]
    }
  ]
}
```

## Mock WebSocket Messages

### Simulating Real-time Updates
```typescript
class MockWebSocketService {
  private interval: NodeJS.Timeout
  
  startSimulation() {
    this.interval = setInterval(() => {
      this.sendMockMessage()
    }, 5000)
  }
  
  sendMockMessage() {
    const messageTypes = [
      'sentiment_update',
      'transcript_entry',
      'customer_data',
      'metrics_update'
    ]
    
    const type = messageTypes[Math.floor(Math.random() * messageTypes.length)]
    const message = this.generateMockMessage(type)
    
    this.broadcast(message)
  }
  
  generateMockMessage(type: string) {
    switch(type) {
      case 'sentiment_update':
        return {
          type,
          data: {
            score: Math.random() * 2 - 1,
            trend: Math.random() > 0.5 ? 'improving' : 'declining',
            confidence: Math.random() * 0.3 + 0.7
          }
        }
      case 'transcript_entry':
        return {
          type,
          data: {
            speaker: Math.random() > 0.5 ? 'agent' : 'customer',
            text: this.getRandomTranscriptText(),
            timestamp: new Date().toISOString()
          }
        }
      default:
        return { type, data: {} }
    }
  }
}
```

## Testing with Mock Data

### Unit Tests
```typescript
describe('Mock Data Integration', () => {
  beforeEach(() => {
    // Enable mock mode
    process.env.VITE_ENABLE_MOCK_DATA = 'true'
  })
  
  it('loads mock customers correctly', async () => {
    const customers = await loadMockCustomers()
    expect(customers).toHaveLength(16)
    expect(customers[0].name).toBe('Jonathan Mitchell')
  })
  
  it('generates appropriate AI responses', () => {
    const response = generateAIResponse('credit card fraud')
    expect(response).toContain('secure your account')
  })
})
```

### E2E Tests
```typescript
describe('Mock Call Flow', () => {
  it('simulates complete call lifecycle', async () => {
    // Enable mock data
    await page.evaluate(() => {
      localStorage.setItem('use-mock-data', 'true')
    })
    
    // Trigger mock call
    await page.click('[data-testid="simulate-call"]')
    
    // Verify call appears
    await expect(page.locator('.incoming-call')).toBeVisible()
    
    // Accept call
    await page.click('[data-testid="accept-call"]')
    
    // Verify mock data populates
    await expect(page.locator('.customer-name')).toContainText('Jonathan Mitchell')
  })
})
```

## Performance Considerations

### Caching Mock Data
```typescript
class MockDataCache {
  private cache = new Map<string, any>()
  private timestamps = new Map<string, number>()
  private ttl = 5 * 60 * 1000 // 5 minutes
  
  async get(key: string, loader: () => Promise<any>) {
    const cached = this.cache.get(key)
    const timestamp = this.timestamps.get(key)
    
    if (cached && timestamp && Date.now() - timestamp < this.ttl) {
      return cached
    }
    
    const data = await loader()
    this.cache.set(key, data)
    this.timestamps.set(key, Date.now())
    return data
  }
  
  clear() {
    this.cache.clear()
    this.timestamps.clear()
  }
}
```

### Lazy Loading Mock Data
```typescript
const useMockData = (type: string) => {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(false)
  
  useEffect(() => {
    if (import.meta.env.VITE_ENABLE_MOCK_DATA === 'true') {
      setLoading(true)
      import(`/config/${type}.json`)
        .then(module => setData(module.default))
        .finally(() => setLoading(false))
    }
  }, [type])
  
  return { data, loading }
}
```

## Transitioning to Production

### Feature Flags
```typescript
const features = {
  useMockData: import.meta.env.VITE_ENABLE_MOCK_DATA === 'true',
  mockDataFallback: import.meta.env.VITE_MOCK_FALLBACK === 'true'
}

// Use mock data as fallback when API fails
const fetchCustomerData = async (id: string) => {
  try {
    const response = await api.getCustomer(id)
    return response.data
  } catch (error) {
    if (features.mockDataFallback) {
      const mockData = await loadMockCustomers()
      return mockData.find(c => c.id === id)
    }
    throw error
  }
}
```

### Gradual Migration
```typescript
const DataService = {
  async getData(type: string) {
    if (features.useMockData) {
      return this.getMockData(type)
    }
    
    try {
      return await this.getApiData(type)
    } catch (error) {
      if (features.mockDataFallback) {
        console.warn('API failed, using mock data', error)
        return this.getMockData(type)
      }
      throw error
    }
  }
}
```
===END FILE===

===BEGIN FILE: docs/README.md===
# Frontend Documentation

## Core Documentation

- [Architecture Overview](./architecture.md) - System design and key decisions
- [WebSocket Messages](./websocket-messages.md) - Real-time message formats and flow
- [State Management](./state-management.md) - Zustand stores and patterns
- [Three Column Layout](./three-column-architecture.md) - UI layout architecture
- [Component Guide](./component-guide.md) - Component development patterns

## Integration Guides

- [Embedded Apps](./embedded-apps-integration.md) - Integrating embedded applications
- [Mock Data Configuration](./mock-data-configuration.md) - Development data setup

## Technology Stack

- **React 19.1** - UI framework
- **TypeScript 5.9** - Type safety
- **Vite 6.0** - Build tool
- **Zustand 5.0** - State management
- **Tailwind CSS 3.4** - Styling
- **shadcn/ui** - Component library

## Key Features

### Real-time Updates
The frontend maintains a WebSocket connection to the gateway service for real-time data:
- Customer information from PostgreSQL
- AI-powered call analysis (sentiment, intent, summary)
- Recommended actions and knowledge articles
- Live call transcription

### State Management
Two primary Zustand stores manage application state:
- **Agent Store** - Dashboard data from WebSocket
- **Agent Status Store** - Call state and availability (persisted)

### Authentication
- Protected routes with default `requireAuth=true`
- Mock authentication for development
- WebSocket disconnect on logout
- Session persistence in localStorage

### UI Architecture
- 3-column responsive layout
- Collapsible columns with persistence
- Dark theme support
- Professional design with shadcn/ui

## Message Flow

```
Customer Call → AI Simulation (Python) → Kafka Topics → Gateway → WebSocket → Frontend
                                             ↓
                                        PostgreSQL
                                             ↓
                                       Customer Data
```

**Note**: The Python AI simulation service (`start-app.sh`/`stop-app.sh`) is used for development and will be replaced by Genesys integration in production.

## Kafka Topics Consumed

The gateway service processes these Kafka topics and forwards to frontend:

1. `sentiment_analysis` - Customer sentiment
2. `priority_scoring` - Call priority level
3. `call_summary` - AI-generated summary
4. `intent_classification` - Customer intent
5. `recommended_actions` - Agent guidance
6. `knowledge_suggestions` - Relevant articles
7. `call_transcription` - Real-time transcript

Note: Customer data comes from PostgreSQL, not Kafka.

## Development

```bash
# Install dependencies
npm install

# Start development
npm run dev

# Type checking
npm run type-check

# Build for production
npm run build
```

The frontend connects to:
- Gateway WebSocket (port 8080)
- AI simulation service (port 8000)
- Embedded apps (ports 3001-3003)

## Security Considerations

- All routes protected by default
- Input sanitization in forms
- No sensitive data in localStorage
- WebSocket requires agentId and callerId
- Message validation in gateway service
===END FILE===

===BEGIN FILE: docs/state-management.md===
# State Management Guide

## Overview

The frontend uses **Zustand 5.0** for state management, chosen for its simplicity, TypeScript support, and built-in persistence middleware.

## Stores

### 1. Agent Store (`agent-store.ts`)

Primary store for agent dashboard data received via WebSocket.

#### State Structure
```typescript
interface AgentState {
  agentData: {
    agentName: string
    agentId: string
    callerId: string
    status: 'available' | 'busy' | 'offline'
    callDuration: number
    queuePosition: number
    department: string
    customer?: Customer
    sentiment?: Sentiment
    priority?: Priority
    summary?: Summary
    intent?: Intent
    actions: Action[]
    knowledgeArticles: KnowledgeArticle[]
    transcript: TranscriptEntry[]
  }
  connectionStatus: 'connected' | 'connecting' | 'disconnected' | 'error'
  isConnected: boolean
}
```

#### Key Actions
- `updateCustomer(customer)` - Update customer information
- `updateSentiment(sentiment)` - Update sentiment analysis
- `updatePriority(priority)` - Update call priority
- `updateSummary(summary)` - Update call summary
- `updateIntent(intent)` - Update intent classification
- `updateActions(actions)` - Update recommended actions
- `addTranscriptEntry(entry)` - Add transcript entry
- `setConnectionStatus(status)` - Update WebSocket connection status

#### Usage Example
```typescript
import { useAgentStore } from '@/stores/agent-store'

function CustomerInfo() {
  // Subscribe to specific slice
  const customer = useAgentStore(state => state.agentData.customer)
  
  // Get multiple values
  const { sentiment, priority } = useAgentStore(state => ({
    sentiment: state.agentData.sentiment,
    priority: state.agentData.priority
  }))
  
  // Get actions
  const updateCustomer = useAgentStore(state => state.updateCustomer)
  
  return <div>{customer?.name}</div>
}
```

### 2. Agent Status Store (`agent-status-store.ts`)

Manages agent availability and call state with localStorage persistence.

#### State Structure
```typescript
interface AgentStatusState {
  status: 'available' | 'on-call' | 'break' | 'offline' | 'do-not-disturb'
  callState: 'idle' | 'incoming' | 'ringing' | 'active' | 'hold' | 'ended'
  currentCallerId: string | null
  callerInfo: CallerInfo | null
  isOnCall: boolean
  isMuted: boolean
  isOnHold: boolean
  callStartTime: Date | null
  callDuration: number
}
```

#### Persistence
```typescript
persist(
  (set, get) => ({...}),
  {
    name: 'agent-status-storage',
    partialize: (state) => ({
      status: state.status,
      // Excludes call-specific data
    })
  }
)
```

#### Key Actions
- `setStatus(status)` - Update agent availability
- `startCall(callerId, callerInfo)` - Begin new call
- `acceptCall()` - Accept incoming call
- `endCall()` - End current call
- `toggleMute()` - Toggle mute state
- `toggleHold()` - Toggle hold state

#### Usage Example
```typescript
import { useAgentStatusStore } from '@/stores/agent-status-store'

function CallControls() {
  const { 
    callState, 
    acceptCall, 
    endCall,
    toggleMute,
    isMuted 
  } = useAgentStatusStore()
  
  if (callState === 'incoming') {
    return <Button onClick={acceptCall}>Accept</Button>
  }
  
  if (callState === 'active') {
    return (
      <>
        <Button onClick={toggleMute}>
          {isMuted ? 'Unmute' : 'Mute'}
        </Button>
        <Button onClick={endCall}>End Call</Button>
      </>
    )
  }
}
```

## Best Practices

### 1. Selective Subscriptions
```typescript
// ✅ Good - Only re-renders when customer changes
const customer = useAgentStore(state => state.agentData.customer)

// ❌ Bad - Re-renders on any state change
const store = useAgentStore()
const customer = store.agentData.customer
```

### 2. Multiple Selections
```typescript
// ✅ Good - Single subscription with shallow equality
const { sentiment, priority } = useAgentStore(
  state => ({
    sentiment: state.agentData.sentiment,
    priority: state.agentData.priority
  }),
  shallow // Import from 'zustand/shallow'
)
```

### 3. Actions Outside Components
```typescript
// ✅ Can call actions outside React
import { useAgentStore } from '@/stores/agent-store'

// In WebSocket handler
function handleCustomerUpdate(data) {
  useAgentStore.getState().updateCustomer(data)
}
```

### 4. Computed Values
```typescript
// ✅ Use selectors for derived state
const hasCustomerContext = useAgentStore(
  state => !!state.agentData.customer?.id
)

// Or with custom hook
function useHasCustomerContext() {
  return useAgentStore(state => !!state.agentData.customer?.id)
}
```

## Persistence

### Local Storage
Agent status persists across sessions:
```typescript
// Saved to localStorage
{
  "agent-status-storage": {
    "state": {
      "status": "available"
    },
    "version": 0
  }
}
```

### Clearing on Logout
```typescript
// In logout hook
localStorage.removeItem('agent-status-storage')
useAgentStatusStore.getState().endCall()
useAgentStatusStore.getState().setStatus('offline')
```

## WebSocket Integration

### Message Flow
```
WebSocket Message → WebSocket Context → Store Action → UI Update
```

### Example Handler
```typescript
// In websocket-context.tsx
const handleMessage = useCallback((event: MessageEvent) => {
  const data = JSON.parse(event.data)
  
  switch (data.type) {
    case 'customer':
      updateCustomer(data.customer)
      break
    case 'sentiment':
      updateSentiment({
        score: Math.round(data.confidence * 100),
        label: data.sentiment,
        trend: data.trend || 'stable'
      })
      break
  }
}, [updateCustomer, updateSentiment])
```

## TypeScript Integration

### Store Types
```typescript
// Define types
interface Customer {
  id: string
  name: string
  email: string
  // ...
}

// Type-safe store
interface AgentState {
  agentData: {
    customer?: Customer
  }
  updateCustomer: (customer: Customer) => void
}

// Full type safety in components
const customer = useAgentStore(state => state.agentData.customer)
// customer is typed as Customer | undefined
```

### Custom Hooks with Types
```typescript
export function useCustomer(): Customer | undefined {
  return useAgentStore(state => state.agentData.customer)
}

export function useUpdateCustomer(): (customer: Customer) => void {
  return useAgentStore(state => state.updateCustomer)
}
```

## Performance Tips

1. **Use shallow equality for multiple selections**
2. **Create custom hooks for complex selectors**
3. **Avoid unnecessary spreads in actions**
4. **Use `immer` middleware for complex updates (if needed)**
5. **Implement proper memoization in components**

## Testing

### Testing Stores
```typescript
import { renderHook, act } from '@testing-library/react'
import { useAgentStore } from '@/stores/agent-store'

test('updates customer', () => {
  const { result } = renderHook(() => useAgentStore())
  
  act(() => {
    result.current.updateCustomer({
      id: '123',
      name: 'John Doe'
    })
  })
  
  expect(result.current.agentData.customer?.name).toBe('John Doe')
})
```

### Mocking in Tests
```typescript
// Mock the store
jest.mock('@/stores/agent-store', () => ({
  useAgentStore: jest.fn()
}))

// Provide mock implementation
useAgentStore.mockReturnValue({
  agentData: { customer: mockCustomer },
  updateCustomer: jest.fn()
})
```

## Migration Notes

### From Context API
```typescript
// Before (Context)
const { customer } = useAgentContext()

// After (Zustand)
const customer = useAgentStore(state => state.agentData.customer)
```

### From Redux
```typescript
// Before (Redux)
const customer = useSelector(state => state.agent.customer)
const dispatch = useDispatch()
dispatch(updateCustomer(data))

// After (Zustand)  
const customer = useAgentStore(state => state.agentData.customer)
const updateCustomer = useAgentStore(state => state.updateCustomer)
updateCustomer(data)
```
===END FILE===

===BEGIN FILE: docs/three-column-architecture.md===
# Three-Column Architecture

## Overview

The HSBC CCAAS Platform uses a sophisticated three-column layout architecture that provides agents with an organized, efficient workspace. This architecture divides the interface into three distinct functional areas while maintaining flexibility through collapsible columns and responsive behavior.

## Layout Structure

### Column Organization

```
┌─────────────────────────────────────────────────────────┐
│                    Global Header                         │
├─────────────┬─────────────────────┬────────────────────┤
│             │                     │                      │
│  Customer   │    Main Content     │   Space Copilot     │
│   Column    │      Column         │      Column         │
│             │                     │                      │
│   (Left)    │     (Center)        │      (Right)        │
│             │                     │                      │
│  - Info     │  - Transcript       │  - Knowledge Base   │
│  - History  │  - Summary          │  - AI Assistant     │
│             │  - Sentiment        │  - Embedded Apps    │
│             │  - Actions          │                      │
│             │                     │                      │
└─────────────┴─────────────────────┴────────────────────┘
```

### Column Responsibilities

#### 1. Customer Column (Left)
- **Purpose**: Display customer context and history
- **Components**:
  - Customer information card
  - Interaction history timeline
  - Verification status
  - Account details
- **Width**: Fixed 380px (desktop), collapsible

#### 2. Main Content Column (Center)
- **Purpose**: Primary workspace for active interactions
- **Components**:
  - Live call transcript
  - AI-generated summary
  - Sentiment analysis
  - Intent detection
  - Recommended actions
  - Priority indicators
- **Width**: Flexible, expands when side columns collapse

#### 3. Space Copilot Column (Right)
- **Purpose**: AI assistance and knowledge resources
- **Components**:
  - Knowledge base search
  - Quick actions
  - Embedded application frames
  - AI suggestions
- **Width**: Fixed 400px (desktop), collapsible

## Implementation Details

### Component Structure

```typescript
// src/components/layout/column-layout.tsx
export function ColumnLayout() {
  const { 
    isCustomerColumnCollapsed,
    isSpaceCopilotCollapsed,
    toggleCustomerColumn,
    toggleSpaceCopilotColumn
  } = useColumnLayout()

  return (
    <div className="flex h-screen">
      {!isCustomerColumnCollapsed && (
        <div className="w-[380px] border-r">
          <CustomerColumn />
        </div>
      )}
      
      <div className="flex-1">
        <MainContent />
      </div>
      
      {!isSpaceCopilotCollapsed && (
        <div className="w-[400px] border-l">
          <SpaceCopilotColumn />
        </div>
      )}
    </div>
  )
}
```

### State Management

The column layout state is managed through a custom hook:

```typescript
// src/hooks/use-column-layout.ts
export function useColumnLayout() {
  const [state, setState] = useState(() => {
    // Load saved preferences from localStorage
    const saved = localStorage.getItem('column-layout')
    return saved ? JSON.parse(saved) : defaultState
  })

  const toggleCustomerColumn = () => {
    setState(prev => {
      const updated = {
        ...prev,
        isCustomerColumnCollapsed: !prev.isCustomerColumnCollapsed
      }
      localStorage.setItem('column-layout', JSON.stringify(updated))
      return updated
    })
  }

  // Similar for other columns...
  return { ...state, toggleCustomerColumn, toggleSpaceCopilotColumn }
}
```

## Responsive Behavior

### Breakpoint Strategy

```css
/* Desktop (>1440px) */
- All three columns visible by default
- Full functionality enabled
- Optimal spacing and sizing

/* Laptop (1024px - 1440px) */
- Space Copilot column auto-collapses
- Customer column remains visible
- Main content takes priority

/* Tablet (768px - 1024px) */
- Only main content visible by default
- Side columns accessible via toggle
- Overlays instead of side-by-side

/* Mobile (<768px) */
- Single column view
- Tab navigation between sections
- Optimized touch interactions
```

### Responsive Implementation

```typescript
const useResponsiveColumns = () => {
  const screenSize = useMediaQuery()
  
  useEffect(() => {
    if (screenSize < 1024) {
      collapseSpaceCopilot()
    }
    if (screenSize < 768) {
      collapseCustomer()
    }
  }, [screenSize])
}
```

## Collapsible Columns

### Collapse Controls

Each column has a collapse button in its header:

```typescript
<button
  onClick={toggleColumn}
  className="p-1 hover:bg-gray-100 rounded"
  aria-label="Toggle column visibility"
>
  {isCollapsed ? <ChevronRight /> : <ChevronLeft />}
</button>
```

### Animation

Smooth transitions using Tailwind CSS:

```css
.column-transition {
  transition: width 300ms cubic-bezier(0.4, 0, 0.2, 1);
}

.column-collapsed {
  width: 0;
  overflow: hidden;
}
```

### Collapsed State Indicators

When collapsed, a vertical tab shows the column can be expanded:

```typescript
{isCollapsed && (
  <CollapsedColumnIndicator
    title="Customer Info"
    onClick={toggleColumn}
    position="left"
  />
)}
```

## State Persistence

### localStorage Integration

Column preferences are automatically saved:

```typescript
const STORAGE_KEY = 'hsbc-column-layout'

const saveLayout = (layout: LayoutState) => {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(layout))
}

const loadLayout = (): LayoutState => {
  const saved = localStorage.getItem(STORAGE_KEY)
  return saved ? JSON.parse(saved) : defaultLayout
}
```

### Persisted Properties

- Column visibility states
- Column widths (if resizable)
- User preferences
- Last active tab

## Keyboard Shortcuts

### Global Shortcuts

```typescript
const keyboardShortcuts = {
  'Alt+1': toggleCustomerColumn,
  'Alt+2': focusMainContent,
  'Alt+3': toggleSpaceCopilotColumn,
  'Alt+0': resetLayout
}
```

### Implementation

```typescript
useEffect(() => {
  const handleKeyPress = (e: KeyboardEvent) => {
    if (e.altKey) {
      switch(e.key) {
        case '1':
          toggleCustomerColumn()
          break
        case '3':
          toggleSpaceCopilotColumn()
          break
      }
    }
  }
  
  window.addEventListener('keydown', handleKeyPress)
  return () => window.removeEventListener('keydown', handleKeyPress)
}, [])
```

## Performance Optimizations

### Lazy Loading

Side columns load content only when visible:

```typescript
{!isCustomerColumnCollapsed && (
  <Suspense fallback={<ColumnSkeleton />}>
    <CustomerColumn />
  </Suspense>
)}
```

### Memoization

Prevent unnecessary re-renders:

```typescript
const CustomerColumn = memo(() => {
  // Component implementation
}, (prevProps, nextProps) => {
  // Custom comparison logic
  return prevProps.isCollapsed === nextProps.isCollapsed
})
```

### Virtual Scrolling

Long lists use virtual scrolling:

```typescript
<VirtualList
  height={600}
  itemCount={interactions.length}
  itemSize={80}
  renderItem={renderInteraction}
/>
```

## Accessibility

### ARIA Attributes

```html
<div role="region" aria-label="Customer Information">
  <button aria-expanded="false" aria-controls="customer-panel">
    Toggle Customer Information
  </button>
  <div id="customer-panel" aria-hidden="true">
    <!-- Content -->
  </div>
</div>
```

### Focus Management

```typescript
const handleColumnToggle = (columnId: string) => {
  toggleColumn(columnId)
  
  // Move focus to newly visible content
  if (!isCollapsed) {
    const element = document.getElementById(columnId)
    element?.focus()
  }
}
```

### Screen Reader Support

- Proper heading hierarchy
- Descriptive labels
- Status announcements
- Keyboard navigation

## Customization

### Configuration Options

```typescript
interface ColumnConfig {
  customerColumn: {
    width: number
    collapsible: boolean
    defaultCollapsed: boolean
  }
  mainColumn: {
    minWidth: number
  }
  spaceCopilotColumn: {
    width: number
    collapsible: boolean
    defaultCollapsed: boolean
  }
}
```

### Theme Integration

Columns respect the application theme:

```css
.column-container {
  @apply bg-background border-border;
}

.dark .column-container {
  @apply bg-background border-border;
}
```

## Best Practices

### 1. Content Priority
- Most important information in main column
- Supporting context in side columns
- Progressive disclosure for complex data

### 2. Responsive Design
- Test on multiple screen sizes
- Ensure touch-friendly controls
- Maintain functionality when columns collapse

### 3. Performance
- Lazy load heavy components
- Use virtual scrolling for long lists
- Minimize re-renders with proper memoization

### 4. User Experience
- Remember user preferences
- Provide clear visual feedback
- Smooth animations and transitions
- Intuitive keyboard shortcuts

## Troubleshooting

### Common Issues

1. **Column not collapsing**
   - Check localStorage permissions
   - Verify state management hooks
   - Ensure CSS transitions are applied

2. **Layout breaking on resize**
   - Review responsive breakpoints
   - Check flexbox/grid configurations
   - Verify media query listeners

3. **Performance issues**
   - Profile component renders
   - Check for unnecessary re-renders
   - Implement proper memoization

## Future Enhancements

### Planned Features
- Resizable column widths
- Drag-and-drop column reordering
- Custom column configurations per role
- Column presets/templates
- Multi-monitor support

### Under Consideration
- Floating/detachable columns
- Column content tabs
- Horizontal column splits
- Picture-in-picture mode
- Column sharing between agents
===END FILE===

===BEGIN FILE: docs/websocket-messages.md===
# WebSocket Message Documentation

## Connection

### URL Format
```
ws://localhost:8080/ws/agent?callerId={callerId}&agentId={agentId}&role={role}
```

### Parameters
- `callerId` - Unique identifier for the call session
- `agentId` - Agent identifier
- `role` - Optional role (agent, supervisor, manager)

## Incoming Messages (Gateway → Frontend)

### sentiment
Customer sentiment analysis from AI service.

```json
{
  "type": "sentiment",
  "sentiment": "positive", // positive, negative, neutral
  "confidence": 0.85,
  "trend": "stable",
  "change": 0
}
```

### priority
Call priority and queue information.

```json
{
  "type": "priority",
  "level": "HIGH", // HIGH, MEDIUM, LOW
  "waitTime": 120,
  "estimatedResolution": 300,
  "escalation": false,
  "queuePosition": 3
}
```

### summary
AI-generated call summary.

```json
{
  "type": "summary",
  "summary": "Customer calling about billing issue",
  "category": "Billing",
  "confidence": 0.92
}
```

### intent
Customer intent classification with embedded app mapping.

```json
{
  "type": "intent",
  "intent": "CHECK_BALANCE",
  "confidence": 0.88,
  "accuracy": "High",
  "appUrl": "/embedded/billing",
  "appTitle": "Billing Dashboard",
  "timestamp": "2025-01-17T10:30:00Z"
}
```

### actions
Recommended actions for the agent.

```json
{
  "type": "actions",
  "actions": [
    {
      "id": "1",
      "action": "Verify customer identity",
      "priority": "HIGH",
      "completed": false
    },
    {
      "id": "2", 
      "action": "Check account status",
      "priority": "MEDIUM",
      "completed": false
    }
  ]
}
```

### knowledge_articles
Relevant knowledge base articles.

```json
{
  "type": "knowledge_articles",
  "articles": [
    {
      "id": "KB001",
      "title": "How to reset password",
      "relevance": 0.95,
      "url": "/kb/reset-password"
    }
  ]
}
```

### transcript
Real-time call transcription.

```json
{
  "type": "transcript",
  "speaker": "customer", // customer or agent
  "text": "I need help with my account",
  "timestamp": "2025-01-17T10:30:45Z"
}
```

### customer
Customer information from PostgreSQL.

```json
{
  "type": "customer",
  "customer": {
    "id": "CUST-12345",
    "customerId": "12345",
    "name": "John Smith",
    "email": "john.smith@example.com",
    "phone": "+1-555-0123",
    "accountType": "Premium",
    "accountNumber": "ACC-98765",
    "memberSince": "2020-01-15",
    "lifetimeValue": 15000,
    "riskScore": 10,
    "preferredChannel": "phone",
    "lastInteraction": "2025-01-10"
  }
}
```

## Outgoing Messages (Frontend → Gateway)

### heartbeat
Keep-alive message sent every 15 seconds.

```json
{
  "type": "heartbeat"
}
```

### accept_call
Accept an incoming call.

```json
{
  "type": "accept_call",
  "callerId": "call-123",
  "agentId": "agent-001",
  "callerName": "John Smith" // Optional, triggers customer data refresh
}
```

### end_call
End the current call.

```json
{
  "type": "end_call",
  "callerId": "call-123",
  "agentId": "agent-001"
}
```

## Connection Management

### Reconnection
- Automatic reconnection with exponential backoff
- Max 5 reconnection attempts
- Delays: 3s, 6s, 12s, 24s, 30s

### Connection States
- `connecting` - WebSocket connecting
- `connected` - WebSocket open
- `disconnected` - WebSocket closed
- `error` - Connection error

### Heartbeat
- Sent every 15 seconds
- Maintains connection health
- Prevents timeout disconnection

## Error Handling

Connection errors result in automatic reconnection unless:
- Intentional disconnect (logout)
- Max reconnection attempts reached
- Service shutdown in progress
- Rate limit exceeded

## Data Flow

1. **Connection established** with agentId and callerId
2. **Initial data** sent:
   - Customer data from PostgreSQL
   - Agent metrics from database
3. **Real-time updates** via Kafka topics:
   - AI analysis results
   - Transcription updates
   - Knowledge suggestions
4. **User actions** sent to gateway:
   - Accept/end call
   - Heartbeat for connection health

## Security

- Parameters validated for injection attacks
- Message size limited to 10KB
- Rate limiting per IP address
- Malicious pattern detection
- Control character filtering
===END FILE===

===BEGIN FILE: public/config/agent-profiles.json===
{
  "agentProfiles": {
    "agent-001": {
      "agentName": "Sarah Mitchell",
      "department": "Premier Banking",
      "agentId": "HSB-001",
      "specialization": "High-net-worth customer service",
      "languages": ["English", "French"],
      "experience": "5 years",
      "certifications": ["Financial Planning", "Investment Advisory"]
    },
    "agent-002": {
      "agentName": "David Chen",
      "department": "Business Banking",
      "agentId": "HSB-002",
      "specialization": "Corporate accounts and business loans",
      "languages": ["English", "Mandarin"],
      "experience": "7 years",
      "certifications": ["Business Analysis", "Risk Assessment"]
    },
    "agent-003": {
      "agentName": "Emma Thompson",
      "department": "Wealth Management",
      "agentId": "HSB-003",
      "specialization": "Investment portfolio management",
      "languages": ["English", "German"],
      "experience": "10 years",
      "certifications": ["CFA", "Wealth Management"]
    },
    "agent-004": {
      "agentName": "Michael Rodriguez",
      "department": "Fraud Prevention",
      "agentId": "HSB-004",
      "specialization": "Security and fraud detection",
      "languages": ["English", "Spanish"],
      "experience": "6 years",
      "certifications": ["Cybersecurity", "Fraud Investigation"]
    },
    "agent-005": {
      "agentName": "Lisa Anderson",
      "department": "Customer Support",
      "agentId": "HSB-005",
      "specialization": "General customer service",
      "languages": ["English"],
      "experience": "3 years",
      "certifications": ["Customer Service Excellence"]
    }
  },
  "defaultAgent": {
    "agentName": "HSBC Agent",
    "department": "Customer Service",
    "agentId": "HSB-000",
    "specialization": "General customer service",
    "languages": ["English"],
    "experience": "1 year",
    "certifications": ["Basic Customer Service"]
  }
}
===END FILE===

===BEGIN FILE: public/config/chat-ai-responses.json===
{
  "personalityResponses": {
    "frustrated": {
      "greeting": [
        "Finally! I've been waiting forever. This better not take long.",
        "About time! I've been having this issue for days.",
        "I hope you can actually help me, unlike the last person I talked to.",
        "This is really frustrating. I shouldn't have to wait this long for help."
      ],
      "clarification": [
        "I already explained this! Weren't you listening?",
        "Do I really have to repeat everything again?",
        "This is exactly what I told the last agent. Can't you see my account?",
        "I don't have time to go through all this again."
      ],
      "solution_positive": [
        "Finally! That's what I needed. Why couldn't the other agent do this?",
        "Good. That should have been done from the start.",
        "Thank you. I hope this doesn't happen again.",
        "Alright, that works. But this whole process was way too complicated."
      ],
      "solution_negative": [
        "That doesn't make any sense! Why is it so complicated?",
        "This is ridiculous. There has to be a better way.",
        "I'm not satisfied with that answer. I want to speak to a manager.",
        "This is unacceptable. I'm considering switching banks."
      ]
    },
    "polite": {
      "greeting": [
        "Hello, thank you for helping me today. I appreciate your time.",
        "Hi there, I hope you're having a good day. I need some assistance please.",
        "Good morning/afternoon, thank you for connecting with me.",
        "Hello, I'm hoping you can help me with an issue I'm having."
      ],
      "clarification": [
        "Of course, let me provide more details about that.",
        "Sure, I'd be happy to clarify that for you.",
        "Absolutely, here's more information about my situation.",
        "Certainly, let me explain that better."
      ],
      "solution_positive": [
        "That's perfect, thank you so much for your help!",
        "Wonderful! I really appreciate you taking the time to resolve this.",
        "That's exactly what I needed. Thank you for being so helpful.",
        "Great! You've been very professional and helpful throughout this."
      ],
      "solution_negative": [
        "I understand, but is there perhaps another option we could explore?",
        "I see. While that's not ideal, I appreciate you explaining the situation.",
        "That's disappointing, but I understand the limitations. Thank you for trying.",
        "I was hoping for a different outcome, but I understand your position."
      ]
    },
    "confused": {
      "greeting": [
        "Hi, I'm not really sure what's going on with my account. Can you help?",
        "Hello, I'm a bit confused about something and hoping you can explain it to me.",
        "Hi there, I don't understand what happened and I'm hoping you can help me figure it out.",
        "Good morning/afternoon, I'm not sure I understand what's going on."
      ],
      "clarification": [
        "I'm sorry, I don't really understand. Can you explain that differently?",
        "Could you walk me through that step by step? I'm not following.",
        "I'm not sure what you mean by that. Could you explain it in simpler terms?",
        "I'm lost. Can you help me understand what that means?"
      ],
      "solution_positive": [
        "Oh, I see now! That makes much more sense. Thank you for explaining.",
        "Ah, okay! I understand now. That's really helpful.",
        "That clears it up for me. Thank you for being so patient with my questions.",
        "Now I get it! Thank you for taking the time to explain everything."
      ],
      "solution_negative": [
        "I still don't really understand why this is happening. Is there someone else who can help?",
        "This is all very confusing to me. Maybe I should come into a branch?",
        "I'm still not clear on this. Could you maybe have someone call me?",
        "This is too complicated for me to understand. What should I do?"
      ]
    },
    "impatient": {
      "greeting": [
        "Hi, I need this resolved quickly. I don't have much time.",
        "Hello, I need to get this sorted out fast. What do you need from me?",
        "I'm in a hurry, can we please get this fixed right away?",
        "Hi, I need this handled immediately. Can you help me now?"
      ],
      "clarification": [
        "Can we speed this up? I already gave you the information.",
        "Look, I don't have time for all these questions. Just fix it.",
        "Do we really need to go through all of this? Can't you just see what's wrong?",
        "I'm running late. Can you please just tell me what I need to do?"
      ],
      "solution_positive": [
        "Good! That's what I needed. Thanks for getting it done quickly.",
        "Perfect. Finally! Thank you for resolving this fast.",
        "Great, that's sorted. I appreciate you handling this promptly.",
        "Excellent! That's exactly what I needed. Thanks for being efficient."
      ],
      "solution_negative": [
        "This is taking too long. I need a faster solution.",
        "I don't have time for this. Can you escalate it to someone who can fix it?",
        "This is wasting my time. There has to be a quicker way.",
        "I can't wait any longer. I'll have to handle this some other way."
      ]
    },
    "friendly": {
      "greeting": [
        "Hi there! Hope you're having a great day. I could use some help with something.",
        "Hello! Thanks for taking my call. I've got a quick question for you.",
        "Hi! I'm sure you can help me sort this out. You seem very knowledgeable.",
        "Good morning/afternoon! I love the service here. Could you help me with something?"
      ],
      "clarification": [
        "Oh absolutely! I'd be happy to give you more details about that.",
        "Sure thing! Let me explain that a bit better for you.",
        "Of course! I should have been clearer about that from the start.",
        "No problem at all! Here's what's been happening with my account."
      ],
      "solution_positive": [
        "That's fantastic! You've been incredibly helpful. Thank you so much!",
        "Perfect! I really appreciate how friendly and professional you've been.",
        "Amazing! You made that look so easy. Thanks for all your help!",
        "Wonderful! You're the best. Thank you for sorting that out for me."
      ],
      "solution_negative": [
        "Oh well, that's okay! I understand these things happen sometimes.",
        "No worries at all! I appreciate you trying your best to help me.",
        "That's alright! Maybe we can try again another time. Thanks anyway!",
        "I understand! You've been very helpful despite not being able to fix it."
      ]
    }
  },
  "issueResponses": {
    "account": {
      "details": [
        "It happened around [time] and I noticed it when I checked my balance online.",
        "I've been monitoring my account daily and this just appeared yesterday.",
        "The transaction shows up as [amount] on [date] but I have no record of it.",
        "I checked my statements and this discrepancy goes back about a week."
      ],
      "resolution_request": [
        "Can you please reverse this transaction?",
        "I need this fixed as soon as possible for my records.",
        "Will this affect my other automatic payments?",
        "How long will it take to show the correct balance?"
      ]
    },
    "payments": {
      "details": [
        "The payment was supposed to go through on [date] but it's still pending.",
        "I have confirmation number [number] but the payment failed.",
        "This is affecting my credit score if payments are late.",
        "I set this up exactly like I always do, but something went wrong."
      ],
      "resolution_request": [
        "Can you process this payment manually?",
        "I need to make sure this goes through today to avoid late fees.",
        "Will you waive any late charges since this was a system error?",
        "How can I prevent this from happening again?"
      ]
    },
    "loans": {
      "details": [
        "My loan number is [number] and the payment date is usually the [date].",
        "I've been making payments on time for [years] without any issues.",
        "This affects my monthly budget planning significantly.",
        "I received a notice but I don't understand what it means."
      ],
      "resolution_request": [
        "Can you update my payment schedule?",
        "I need to understand all my options before deciding.",
        "Will this change affect my interest rate?",
        "How will this impact my loan terms?"
      ]
    },
    "technical": {
      "details": [
        "I tried clearing my browser cache and cookies but it still doesn't work.",
        "The error message says [error] but I don't know what that means.",
        "It was working fine yesterday and I haven't changed anything.",
        "I've tried on both my phone and computer with the same problem."
      ],
      "resolution_request": [
        "Can you reset something on your end?",
        "Is this a known issue that you're working on?",
        "Do I need to update my app or browser?",
        "How long until this gets fixed?"
      ]
    },
    "cards": {
      "details": [
        "My card number ends in [number] and expires [date].",
        "I used the card successfully yesterday at [location].",
        "I haven't reported it lost or stolen, so I'm not sure why it's not working.",
        "The transaction amount was [amount] at [merchant]."
      ],
      "resolution_request": [
        "Can you unlock my card right now?",
        "Do I need to get a replacement card?",
        "Will the new card have the same number?",
        "How long will shipping take?"
      ]
    },
    "general": {
      "details": [
        "I've been a customer for [years] and never had this issue before.",
        "This is really important for my [business/personal] finances.",
        "I tried calling but the wait time was too long.",
        "Your website says one thing but I'm experiencing something different."
      ],
      "resolution_request": [
        "What are my options here?",
        "Can you escalate this to someone who can help?",
        "Is there any documentation you can send me?",
        "What's the best way to prevent this in the future?"
      ]
    }
  },
  "stageResponses": {
    "greeting": "initial_greeting",
    "problem_identification": "providing_details",
    "troubleshooting": "working_through_solution",
    "resolution": "accepting_solution",
    "closing": "ending_conversation"
  },
  "closingResponses": [
    "Perfect! Thank you so much for your help today.",
    "Great, that's all I needed. I appreciate your assistance.",
    "That solves my problem. Thanks for being so helpful!",
    "Excellent! You've been very helpful. Have a great day!",
    "That's exactly what I needed. Thank you for your time."
  ],
  "thankYouMessages": {
    "frustrated": [
      "Alright, thanks for finally getting that sorted out.",
      "Good. I hope this doesn't happen again. Thanks.",
      "Fine. Thanks for resolving it, though it took longer than it should have."
    ],
    "polite": [
      "Thank you so much for your help today. I really appreciate your time and patience.",
      "That was exactly what I needed. Thank you for being so professional and helpful.",
      "Perfect! Thank you for taking care of this so efficiently."
    ],
    "confused": [
      "Okay, I think I understand now. Thank you for explaining everything so clearly.",
      "That makes sense now. Thank you for being so patient with all my questions.",
      "Great! Thanks for helping me figure this out."
    ],
    "impatient": [
      "Perfect! Thanks for getting this done quickly.",
      "Good, that's what I needed. Thanks for handling it fast.",
      "Excellent! Thanks for resolving this promptly."
    ],
    "friendly": [
      "You've been absolutely wonderful! Thank you so much for all your help today!",
      "That's perfect! You guys always provide such great service. Thanks a million!",
      "Fantastic! Thank you for being so helpful and friendly throughout this whole process!"
    ]
  },
  "responseDelays": {
    "frustrated": {
      "base": 1500,
      "variation": 500
    },
    "impatient": {
      "base": 1500,
      "variation": 300
    },
    "polite": {
      "base": 1500,
      "variation": 1500
    },
    "confused": {
      "base": 1500,
      "variation": 2000
    },
    "friendly": {
      "base": 1500,
      "variation": 1000
    }
  },
  "variables": {
    "[time]": "dynamic_time",
    "[date]": "dynamic_date",
    "[amount]": "dynamic_amount",
    "[number]": "dynamic_number",
    "[location]": ["the grocery store", "a gas station", "Target", "Amazon", "the mall"],
    "[merchant]": ["Amazon", "Walmart", "Target", "Starbucks", "Shell Gas"],
    "[years]": "dynamic_years",
    "[error]": "Error Code 500: Internal Server Error"
  }
}
===END FILE===

===BEGIN FILE: public/config/customer-profiles.json===
{
  "customerProfiles": [
    {
      "id": "cust-001",
      "name": "Mr James Smith",
      "cin": "1234567890",
      "tier": "Premier",
      "accountNumber": "XXXX-XXXX-XXXX-4567",
      "email": "james.s@outlook.com",
      "phone": "07885 485694",
      "location": "London, UK",
      "joinDate": "2015-03-15",
      "totalInteractions": 47,
      "lastCCAASDate": "2024-07-25",
      "segment": "Premier",
      "gender": "Male",
      "careNeed": true
    },
    {
      "id": "cust-002",
      "name": "Ms Sarah Johnson",
      "cin": "2345678901",
      "tier": "Business",
      "accountNumber": "XXXX-XXXX-XXXX-8912",
      "email": "sarah.johnson@techcorp.com",
      "phone": "07712 345678",
      "location": "Manchester, UK",
      "joinDate": "2018-11-22",
      "totalInteractions": 23,
      "lastCCAASDate": "2024-08-01",
      "segment": "Business",
      "gender": "Female",
      "careNeed": false
    },
    {
      "id": "cust-003",
      "name": "Dr Michael Chen",
      "cin": "3456789012",
      "tier": "Private",
      "accountNumber": "XXXX-XXXX-XXXX-3456",
      "email": "m.chen@medicalcenter.co.uk",
      "phone": "07923 567890",
      "location": "Edinburgh, UK",
      "joinDate": "2020-02-14",
      "totalInteractions": 15,
      "lastCCAASDate": "2024-07-30",
      "segment": "Private",
      "gender": "Male",
      "careNeed": false
    },
    {
      "id": "cust-004",
      "name": "Mrs Emma Williams",
      "cin": "4567890123",
      "tier": "Standard",
      "accountNumber": "XXXX-XXXX-XXXX-7890",
      "email": "emma.williams@gmail.com",
      "phone": "07834 123456",
      "location": "Birmingham, UK",
      "joinDate": "2019-09-05",
      "totalInteractions": 31,
      "lastCCAASDate": "2024-08-10",
      "segment": "Standard",
      "gender": "Female",
      "careNeed": true
    },
    {
      "id": "cust-005",
      "name": "Mr David Rodriguez",
      "cin": "5678901234",
      "tier": "Premier",
      "accountNumber": "XXXX-XXXX-XXXX-2345",
      "email": "d.rodriguez@startup.io",
      "phone": "07756 789012",
      "location": "Bristol, UK",
      "joinDate": "2021-06-18",
      "totalInteractions": 8,
      "lastCCAASDate": "2024-08-05",
      "segment": "Premier",
      "gender": "Male",
      "careNeed": false
    }
  ],
  "randomCustomerTemplate": {
    "id": "generated",
    "name": "Generated Customer",
    "cin": "0000000000",
    "tier": "Standard",
    "accountNumber": "XXXX-XXXX-XXXX-0000",
    "email": "customer@example.com",
    "phone": "07000 000000",
    "location": "UK",
    "joinDate": "2024-01-01",
    "totalInteractions": 1,
    "lastCCAASDate": "2024-08-15",
    "segment": "Standard",
    "gender": "Unknown",
    "careNeed": false
  }
}
===END FILE===

===BEGIN FILE: public/config/interaction-templates.json===
{
  "interactionTemplates": [
    {
      "id": "int-active",
      "type": "call",
      "title": "Active call in progress",
      "status": "active",
      "date": null,
      "details": "Current conversation with customer regarding their inquiry.",
      "icon": "PhoneCall",
      "duration": null,
      "priority": "normal"
    },
    {
      "id": "int-001",
      "type": "chat",
      "title": "Overseas withdrawal inquiry",
      "status": "completed",
      "date": "Jul 25 2025 14:23",
      "details": "Customer requested information about overseas withdrawal limits and fees. Provided standard rates and enabled travel notification.",
      "icon": "MessageSquare",
      "duration": "12 minutes",
      "priority": "low"
    },
    {
      "id": "int-002",
      "type": "call",
      "title": "Card replacement request",
      "status": "completed",
      "date": "Jul 18 2025 10:15",
      "details": "Customer reported damaged card. Ordered replacement card with expedited delivery.",
      "icon": "PhoneCall",
      "duration": "8 minutes",
      "priority": "high"
    },
    {
      "id": "int-003",
      "type": "transaction",
      "title": "Large purchase authorization",
      "status": "completed",
      "date": "Jul 10 2025 16:45",
      "details": "Authorized large purchase of £2,500 at electronics store after security verification.",
      "icon": "CreditCard",
      "duration": "5 minutes",
      "priority": "medium"
    },
    {
      "id": "int-004",
      "type": "email",
      "title": "Account statement request",
      "status": "completed",
      "date": "Jul 05 2025 09:30",
      "details": "Customer requested electronic statements for the past 6 months. Sent via secure email.",
      "icon": "Mail",
      "duration": "3 minutes",
      "priority": "low"
    },
    {
      "id": "int-005",
      "type": "call",
      "title": "Investment consultation",
      "status": "completed",
      "date": "Jun 28 2025 15:20",
      "details": "Discussed investment options for ISA contribution. Scheduled follow-up meeting with wealth advisor.",
      "icon": "PhoneCall",
      "duration": "25 minutes",
      "priority": "medium"
    }
  ],
  "interactionTypes": [
    {
      "type": "call",
      "icon": "PhoneCall",
      "label": "Phone Call",
      "color": "blue"
    },
    {
      "type": "chat",
      "icon": "MessageSquare",
      "label": "Live Chat",
      "color": "green"
    },
    {
      "type": "email",
      "icon": "Mail",
      "label": "Email",
      "color": "purple"
    },
    {
      "type": "transaction",
      "icon": "CreditCard",
      "label": "Transaction",
      "color": "orange"
    },
    {
      "type": "branch",
      "icon": "MapPin",
      "label": "Branch Visit",
      "color": "red"
    }
  ],
  "statusTypes": [
    {
      "status": "active",
      "label": "Active",
      "color": "green",
      "description": "Currently in progress"
    },
    {
      "status": "completed",
      "label": "Completed",
      "color": "blue",
      "description": "Successfully resolved"
    },
    {
      "status": "pending",
      "label": "Pending",
      "color": "yellow",
      "description": "Awaiting action"
    },
    {
      "status": "escalated",
      "label": "Escalated",
      "color": "red",
      "description": "Escalated to supervisor"
    }
  ]
}
===END FILE===

===BEGIN FILE: public/config/knowledge-articles.json===
{
  "knowledgeArticles": [
    {
      "id": "kb-001",
      "title": "Querying recurring or continuous day loan transactions on a Credit Card",
      "category": "Credit Cards",
      "relevance": 95,
      "excerpt": "This procedure helps establish if a transaction is a recurring transaction or a day loan transaction...",
      "url": "/kb/recurring-transactions",
      "content": "Step-by-step guide for identifying and handling recurring transactions on credit cards.",
      "lastUpdated": "2024-08-01",
      "tags": ["credit cards", "recurring payments", "transactions"]
    },
    {
      "id": "kb-002",
      "title": "How to cancel recurring transactions",
      "category": "Payments",
      "relevance": 87,
      "excerpt": "Step-by-step guide to cancelling continuous payment authorities and subscriptions...",
      "url": "/kb/cancel-recurring",
      "content": "Detailed process for helping customers cancel unwanted recurring payments.",
      "lastUpdated": "2024-07-28",
      "tags": ["payments", "cancellation", "subscriptions"]
    },
    {
      "id": "kb-003",
      "title": "Credit card dispute process",
      "category": "Disputes",
      "relevance": 72,
      "excerpt": "Process for disputing unauthorized or incorrect credit card transactions...",
      "url": "/kb/dispute-process",
      "content": "Complete guide for handling credit card disputes and chargebacks.",
      "lastUpdated": "2024-07-25",
      "tags": ["disputes", "chargebacks", "unauthorized transactions"]
    },
    {
      "id": "kb-004",
      "title": "Setting up transaction alerts",
      "category": "Security",
      "relevance": 68,
      "excerpt": "How to configure SMS and email alerts for card transactions...",
      "url": "/kb/transaction-alerts",
      "content": "Guide for setting up various types of transaction notifications.",
      "lastUpdated": "2024-08-05",
      "tags": ["alerts", "notifications", "security"]
    },
    {
      "id": "kb-005",
      "title": "Account upgrade procedures",
      "category": "Account Management",
      "relevance": 80,
      "excerpt": "Process for upgrading customer accounts to higher tiers...",
      "url": "/kb/account-upgrade",
      "content": "Step-by-step process for account tier upgrades and eligibility requirements.",
      "lastUpdated": "2024-08-10",
      "tags": ["account management", "upgrades", "tiers"]
    },
    {
      "id": "kb-006",
      "title": "International transfer limits and fees",
      "category": "International Banking",
      "relevance": 75,
      "excerpt": "Information about international transfer limits, fees, and processing times...",
      "url": "/kb/international-transfers",
      "content": "Comprehensive guide to international banking services and fees.",
      "lastUpdated": "2024-08-08",
      "tags": ["international banking", "transfers", "fees"]
    }
  ],
  "categories": [
    "Credit Cards",
    "Payments",
    "Disputes",
    "Security",
    "Account Management",
    "International Banking",
    "Loans",
    "Investments",
    "Mobile Banking"
  ]
}
===END FILE===

===BEGIN FILE: public/config/response-templates.json===
{
  "templates": [
    {
      "id": "1",
      "title": "Welcome Greeting",
      "content": "Hello! Welcome to HSBC. I'm here to help you today. How may I assist you?",
      "category": "greeting",
      "usage": 45,
      "favorite": true
    },
    {
      "id": "2",
      "title": "Account Balance",
      "content": "I can help you check your account balance. For security purposes, could you please provide your account number?",
      "category": "account",
      "usage": 32,
      "favorite": false
    },
    {
      "id": "3",
      "title": "Password Reset",
      "content": "I'll help you reset your password. For security, I'll need to verify your identity first. Can you confirm your full name and date of birth?",
      "category": "technical",
      "usage": 28,
      "favorite": true
    },
    {
      "id": "4",
      "title": "Transfer Information",
      "content": "To process your transfer, I'll need the recipient's account details and the amount you'd like to send. What's the destination account?",
      "category": "account",
      "usage": 18,
      "favorite": false
    },
    {
      "id": "5",
      "title": "Technical Issue",
      "content": "I understand you're experiencing technical difficulties. Let me help troubleshoot this for you. Can you describe what exactly is happening?",
      "category": "technical",
      "usage": 15,
      "favorite": false
    },
    {
      "id": "6",
      "title": "Closing - Resolved",
      "content": "I'm glad I could help resolve your issue today. Is there anything else I can assist you with before we end this chat?",
      "category": "closing",
      "usage": 41,
      "favorite": true
    }
  ]
}
===END FILE===

===BEGIN FILE: public/config/sample-notifications.json===
{
  "notifications": [
    {
      "delay": 2000,
      "type": "system",
      "title": "System Update",
      "description": "New notification system active with enhanced UX",
      "icon": "info"
    },
    {
      "delay": 3500,
      "type": "success",
      "title": "Connection Established",
      "description": "Successfully connected to all services",
      "icon": "check"
    },
    {
      "delay": 5000,
      "type": "knowledge",
      "title": "Knowledge Base Updated",
      "description": "3 new articles matching current conversation context",
      "icon": "sparkles",
      "actionLabel": "View Articles"
    },
    {
      "delay": 6500,
      "type": "ai_coaching",
      "title": "AI Coaching Available",
      "description": "Real-time guidance for customer interaction",
      "icon": "bot"
    }
  ]
}
===END FILE===

===BEGIN FILE: public/config/team-agents.json===
{
  "agents": [
    {
      "id": "1",
      "name": "Sarah Thompson",
      "role": "call",
      "status": "busy",
      "currentCustomer": "Jennifer Liu",
      "callDuration": 325,
      "performance": {
        "callsToday": 12,
        "avgHandleTime": 180,
        "satisfaction": 94
      }
    },
    {
      "id": "2",
      "name": "Emily Rodriguez",
      "role": "chat",
      "status": "busy",
      "currentCustomer": "Robert Johnson",
      "performance": {
        "callsToday": 18,
        "avgHandleTime": 120,
        "satisfaction": 92
      }
    },
    {
      "id": "3",
      "name": "Michael Chen",
      "role": "call",
      "status": "available",
      "performance": {
        "callsToday": 8,
        "avgHandleTime": 200,
        "satisfaction": 88
      }
    },
    {
      "id": "4",
      "name": "David Wilson",
      "role": "chat",
      "status": "break",
      "performance": {
        "callsToday": 15,
        "avgHandleTime": 150,
        "satisfaction": 95
      }
    },
    {
      "id": "5",
      "name": "Lisa Anderson",
      "role": "call",
      "status": "busy",
      "currentCustomer": "Sophie Anderson",
      "callDuration": 180,
      "performance": {
        "callsToday": 10,
        "avgHandleTime": 190,
        "satisfaction": 91
      }
    },
    {
      "id": "6",
      "name": "James Martinez",
      "role": "chat",
      "status": "available",
      "performance": {
        "callsToday": 20,
        "avgHandleTime": 130,
        "satisfaction": 93
      }
    }
  ]
}
===END FILE===

===BEGIN FILE: public/config/transcript-scenarios.json===
{
  "transcriptScenarios": [
    {
      "id": "scenario-001",
      "title": "Credit Card Recurring Charges",
      "category": "Credit Cards",
      "messages": [
        {
          "id": "msg-1",
          "timestamp": "5 minutes ago",
          "speaker": "customer",
          "text": "Hi, I'm seeing multiple charges on my credit card that I don't recognize. They appear to be recurring transactions."
        },
        {
          "id": "msg-2",
          "timestamp": "4 minutes ago",
          "speaker": "agent",
          "text": "I understand your concern about the unrecognized recurring charges on your credit card. I'd be happy to help you investigate these transactions. Can you tell me the merchant names or amounts?"
        },
        {
          "id": "msg-3",
          "timestamp": "3 minutes ago",
          "speaker": "customer",
          "text": "Yes, I see charges from 'STREAMCO PREMIUM' for £12.99 and 'FITCLUB MONTHLY' for £39.99. These have been coming out every month."
        },
        {
          "id": "msg-4",
          "timestamp": "2 minutes ago",
          "speaker": "agent",
          "text": "Thank you for providing those details. I can see both subscriptions on your account. STREAMCO PREMIUM is a streaming service subscription, and FITCLUB MONTHLY appears to be a gym membership. Would you like to cancel either or both of these?"
        },
        {
          "id": "msg-5",
          "timestamp": "1 minute ago",
          "speaker": "customer",
          "text": "I definitely want to cancel the FITCLUB one - I haven't been to the gym in months. Can you help me with that?"
        }
      ]
    },
    {
      "id": "scenario-002",
      "title": "Account Upgrade Request",
      "category": "Account Management",
      "messages": [
        {
          "id": "msg-1",
          "timestamp": "3 minutes ago",
          "speaker": "customer",
          "text": "I've been a customer for several years and I'm interested in upgrading my account to Premier status. What are the requirements?"
        },
        {
          "id": "msg-2",
          "timestamp": "2 minutes ago",
          "speaker": "agent",
          "text": "I'd be happy to help you with your account upgrade. For Premier status, you'll need a minimum monthly income of £75,000 or total relationship balance of £250,000. Let me check your current eligibility."
        },
        {
          "id": "msg-3",
          "timestamp": "1 minute ago",
          "speaker": "customer",
          "text": "That sounds reasonable. I believe I meet the income requirements. What additional benefits would I get with Premier?"
        }
      ]
    },
    {
      "id": "scenario-003",
      "title": "International Transfer Query",
      "category": "International Banking",
      "messages": [
        {
          "id": "msg-1",
          "timestamp": "4 minutes ago",
          "speaker": "customer",
          "text": "I need to send money to my daughter who's studying abroad in Australia. What are the fees and how long will it take?"
        },
        {
          "id": "msg-2",
          "timestamp": "3 minutes ago",
          "speaker": "agent",
          "text": "I can help you with that international transfer. For Australia, our standard transfer fee is £15 for amounts up to £10,000, and transfers typically arrive within 1-2 business days. How much are you looking to send?"
        },
        {
          "id": "msg-3",
          "timestamp": "2 minutes ago",
          "speaker": "customer",
          "text": "I need to send about £2,500 for her university fees. Is there a better exchange rate if I send a larger amount?"
        }
      ]
    }
  ],
  "messageTemplates": {
    "greetings": [
      "Hello, how can I help you today?",
      "Good morning, what can I assist you with?",
      "Hi there, I'm here to help with any banking questions you have."
    ],
    "clarifications": [
      "Could you provide more details about that?",
      "Let me make sure I understand correctly...",
      "Can you clarify what you mean by...?"
    ],
    "confirmations": [
      "I've completed that request for you.",
      "That's all taken care of now.",
      "I've processed that change to your account."
    ],
    "closings": [
      "Is there anything else I can help you with today?",
      "Thank you for calling HSBC Bank, have a great day!",
      "If you need any further assistance, please don't hesitate to call us."
    ]
  }
}
===END FILE===

===BEGIN FILE: README.md===
# HSBC CCAAS Platform - Frontend

Real-time agent dashboard for ccaas center operations.

## Quick Start

```bash
# Install dependencies
npm install

# Start development server
npm run dev

# Build for production
npm run build

# Run tests
npm test

# Type checking
npm run type-check
```

## Requirements

- Node.js 20+
- npm 10+

## Development

The frontend runs on http://localhost:5173 and connects to:
- WebSocket Gateway service on port 8080
- AI simulation service on port 8000 (Python FastAPI)
- Embedded apps on port 3001-3003

Note: The AI simulation service will be replaced by Genesys integration in production.

## Build

Production build outputs to `dist/` directory:

```bash
npm run build
npm run preview  # Preview production build
```

## Architecture

See [ARCHITECTURE.md](./ARCHITECTURE.md) for detailed technical documentation.
===END FILE===

===BEGIN FILE: src/App.tsx===
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import { ColumnLayout } from './components/layout/column-layout'
import { LoginPage } from './pages/login'
import { ProtectedRoute } from './components/auth/protected-route'
import { AuthProvider } from './contexts/auth-context'
import { WebSocketProvider } from './contexts/websocket-context'
import { ToastProvider } from './hooks/use-toast'
import { RoleProvider, useRoleConfig } from './contexts/role-context'
import { Toaster } from 'sonner'
import { useEffect } from 'react'

function Dashboard() {
  const { currentRole } = useRoleConfig()
  
  useEffect(() => {
  }, [currentRole])
  
  return <ColumnLayout key={`layout-${currentRole}`} />
}

function App() {
  return (
    <BrowserRouter>
      <ToastProvider>
        <RoleProvider>
          <AuthProvider>
            <WebSocketProvider>
              <Routes>
                {/* Login Route */}
                <Route path="/login" element={<LoginPage />} />
                
                {/* Dashboard Route */}
                <Route path="/dashboard" element={
                  <ProtectedRoute requireAuth={true}>
                    <Dashboard />
                  </ProtectedRoute>
                } />
                
                {/* Default Route - Redirect to login */}
                <Route path="/" element={<Navigate to="/login" replace />} />
                
                {/* Catch all - redirect to login */}
                <Route path="*" element={<Navigate to="/login" replace />} />
              </Routes>
              <Toaster 
                position="top-right" 
                richColors 
                duration={3000}
                closeButton
              />
            </WebSocketProvider>
          </AuthProvider>
        </RoleProvider>
      </ToastProvider>
    </BrowserRouter>
  )
}

export default App
===END FILE===

===BEGIN FILE: src/components/agent-status/agent-status-toggle.tsx===
import { useState, useEffect } from 'react'
import { ToggleGroup, ToggleGroupItem } from '../ui/toggle-group'
import { Badge } from '../ui/badge'
import { 
  PhoneCall, 
  Coffee, 
  Power, 
  Clock,
  Phone,
  Activity
} from 'lucide-react'
import { useAgentStatus } from '../../hooks/use-agent-status'
import { AgentStatus } from '../../stores/agent-status-store'
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '../ui/popover'
import { Button } from '../ui/button'
import { Separator } from '../ui/separator'

interface AgentStatusToggleProps {
  onAutoCall?: () => void
  compact?: boolean
}

export function AgentStatusToggle({ onAutoCall, compact = false }: AgentStatusToggleProps) {
  const {
    status,
    statusSince,
    callsHandledToday,
    averageHandleTime,
    callsInQueue,
    setStatus,
    formatTime
  } = useAgentStatus({
    onAutoCall,
    onStatusChange: () => {
      // Agent status changed
    }
  })
  
  const [timeInStatus, setTimeInStatus] = useState('0:00')
  
  // Update time in current status
  useEffect(() => {
    const updateTimer = () => {
      const now = new Date()
      const diff = Math.floor((now.getTime() - new Date(statusSince).getTime()) / 1000)
      setTimeInStatus(formatTime(diff))
    }
    
    updateTimer()
    const interval = setInterval(updateTimer, 1000)
    
    return () => clearInterval(interval)
  }, [statusSince, formatTime])
  
  // Get status details for display
  const getStatusDetails = (s: AgentStatus) => {
    switch (s) {
      case 'available':
        return {
          icon: <PhoneCall className="h-4 w-4" />,
          label: 'Available',
          description: 'Ready to receive calls',
          color: 'text-green-600 dark:text-green-400',
          bgColor: 'bg-green-50 dark:bg-green-900/20',
          borderColor: 'border-green-200 dark:border-green-800'
        }
      case 'on-call':
        return {
          icon: <Phone className="h-4 w-4 animate-pulse" />,
          label: 'On Call',
          description: 'Currently on a call',
          color: 'text-blue-600 dark:text-blue-400',
          bgColor: 'bg-blue-50 dark:bg-blue-900/20',
          borderColor: 'border-blue-200 dark:border-blue-800'
        }
      case 'break':
        return {
          icon: <Coffee className="h-4 w-4" />,
          label: 'On Break',
          description: 'Temporarily unavailable',
          color: 'text-yellow-600 dark:text-yellow-400',
          bgColor: 'bg-yellow-50 dark:bg-yellow-900/20',
          borderColor: 'border-yellow-200 dark:border-yellow-800'
        }
      case 'offline':
        return {
          icon: <Power className="h-4 w-4" />,
          label: 'Offline',
          description: 'Not accepting calls',
          color: 'text-red-600 dark:text-red-400',
          bgColor: 'bg-red-50 dark:bg-red-900/20',
          borderColor: 'border-red-200 dark:border-red-800'
        }
      case 'after-call-work':
        return {
          icon: <Coffee className="h-4 w-4" />,
          label: 'After Call Work',
          description: 'Completing call documentation',
          color: 'text-purple-600 dark:text-purple-400',
          bgColor: 'bg-purple-50 dark:bg-purple-900/20',
          borderColor: 'border-purple-200 dark:border-purple-800'
        }
      case 'do-not-disturb':
        return {
          icon: <Power className="h-4 w-4" />,
          label: 'Do Not Disturb',
          description: 'Temporarily blocking all calls',
          color: 'text-orange-600 dark:text-orange-400',
          bgColor: 'bg-orange-50 dark:bg-orange-900/20',
          borderColor: 'border-orange-200 dark:border-orange-800'
        }
      default:
        return {
          icon: <Power className="h-4 w-4" />,
          label: 'Unknown',
          description: 'Status unknown',
          color: 'text-gray-600 dark:text-gray-400',
          bgColor: 'bg-gray-50 dark:bg-gray-900/20',
          borderColor: 'border-gray-200 dark:border-gray-800'
        }
    }
  }
  
  const currentStatus = getStatusDetails(status || 'offline')  // Fallback to offline if undefined
  
  if (compact) {
    // Compact version for header
    return (
      <Popover>
        <PopoverTrigger asChild>
          <Button 
            variant="outline" 
            size="sm"
            className={`gap-2 ${currentStatus.borderColor} ${currentStatus.bgColor} ${currentStatus.color} hover:${currentStatus.bgColor} hover:${currentStatus.color}`}
          >
            <div className={`flex items-center gap-3 ${currentStatus.color}`}>
              {currentStatus.icon}
              <span className="font-medium">{currentStatus.label}</span>
            </div>
            {status === 'available' && callsInQueue > 0 && (
              <Badge variant="secondary" className="ml-1 h-5 px-1.5 text-xs">
                {callsInQueue}
              </Badge>
            )}
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-80" align="end">
          <AgentStatusPanel
            status={status}
            setStatus={setStatus}
            callsHandledToday={callsHandledToday}
            averageHandleTime={averageHandleTime}
            callsInQueue={callsInQueue}
            timeInStatus={timeInStatus}
            formatTime={formatTime}
          />
        </PopoverContent>
      </Popover>
    )
  }
  
  // Full version
  return (
    <div className="flex items-center gap-4">
        <ToggleGroup 
          type="single" 
        value={status}
        onValueChange={(value) => value && setStatus(value as AgentStatus)}
        className="border rounded-lg p-1 bg-muted/50"
      >
        <ToggleGroupItem 
          value="available" 
          aria-label="Set available"
          className="data-[state=on]:bg-green-500 data-[state=on]:!text-white data-[state=on]:hover:bg-green-600 data-[state=on]:hover:!text-white hover:bg-green-50 hover:text-green-700 font-medium"
        >
          <PhoneCall className="h-4 w-4 mr-2" />
          Available
        </ToggleGroupItem>
        <ToggleGroupItem 
          value="break" 
          aria-label="On break"
          className="data-[state=on]:bg-yellow-500 data-[state=on]:!text-white data-[state=on]:hover:bg-yellow-600 data-[state=on]:hover:!text-white hover:bg-yellow-50 hover:text-yellow-700 font-medium"
        >
          <Coffee className="h-4 w-4 mr-2" />
          Break
        </ToggleGroupItem>
        <ToggleGroupItem 
          value="offline" 
          aria-label="Go offline"
          className="data-[state=on]:bg-red-500 data-[state=on]:!text-white data-[state=on]:hover:bg-red-600 data-[state=on]:hover:!text-white hover:bg-red-50 hover:text-red-700 font-medium"
        >
          <Power className="h-4 w-4 mr-2" />
          Offline
        </ToggleGroupItem>
      </ToggleGroup>
      
      {/* Status metrics */}
      <div className="flex items-center gap-3 text-sm text-muted-foreground">
        {status === 'available' && callsInQueue > 0 && (
          <Badge variant="outline" className="gap-1">
            <Phone className="h-3 w-3" />
            {callsInQueue} waiting
          </Badge>
        )}
        <span className="flex items-center gap-1">
          <Clock className="h-3 w-3" />
          {timeInStatus}
        </span>
        <span className="flex items-center gap-1">
          <Activity className="h-3 w-3" />
          {callsHandledToday} calls today
        </span>
      </div>
    </div>
  )
}

// Status panel component for popover
function AgentStatusPanel({
  status,
  setStatus,
  callsHandledToday,
  averageHandleTime,
  callsInQueue,
  timeInStatus,
  formatTime
}: {
  status: AgentStatus
  setStatus: (status: AgentStatus) => void
  callsHandledToday: number
  averageHandleTime: number
  callsInQueue: number
  timeInStatus: string
  formatTime: (seconds: number) => string
}) {
  return (
    <div className="space-y-4">
      <div>
        <h3 className="font-semibold text-sm mb-3">Agent Status</h3>
        <ToggleGroup 
          type="single" 
          value={status}
          onValueChange={(value) => value && setStatus(value as AgentStatus)}
          className="grid grid-cols-3 gap-2"
        >
          <ToggleGroupItem 
            value="available" 
            className="flex-col gap-1 h-auto py-3 data-[state=on]:bg-green-500 data-[state=on]:text-white"
          >
            <PhoneCall className="h-5 w-5" />
            <span className="text-xs font-medium">Available</span>
          </ToggleGroupItem>
          <ToggleGroupItem 
            value="break" 
            className="flex-col gap-1 h-auto py-3 data-[state=on]:bg-yellow-500 data-[state=on]:text-white"
          >
            <Coffee className="h-5 w-5" />
            <span className="text-xs font-medium">Break</span>
          </ToggleGroupItem>
          <ToggleGroupItem 
            value="offline" 
            className="flex-col gap-1 h-auto py-3 data-[state=on]:bg-red-500 data-[state=on]:text-white"
          >
            <Power className="h-5 w-5" />
            <span className="text-xs font-medium">Offline</span>
          </ToggleGroupItem>
        </ToggleGroup>
      </div>
      
      <Separator />
      
      <div className="space-y-3">
        <h4 className="font-semibold text-sm">Today's Statistics</h4>
        
        <div className="grid grid-cols-2 gap-3">
          <div className="space-y-1">
            <p className="text-xs text-muted-foreground">Calls Handled</p>
            <p className="text-xl font-semibold">{callsHandledToday}</p>
          </div>
          
          <div className="space-y-1">
            <p className="text-xs text-muted-foreground">Avg Handle Time</p>
            <p className="text-xl font-semibold">{formatTime(averageHandleTime)}</p>
          </div>
          
          <div className="space-y-1">
            <p className="text-xs text-muted-foreground">Time in Status</p>
            <p className="text-xl font-semibold">{timeInStatus}</p>
          </div>
          
          <div className="space-y-1">
            <p className="text-xs text-muted-foreground">Queue Size</p>
            <p className="text-xl font-semibold">{callsInQueue}</p>
          </div>
        </div>
      </div>
      
      {status === 'available' && callsInQueue > 0 && (
        <>
          <Separator />
          <div className="flex items-center gap-2 text-sm">
            <div className="h-2 w-2 bg-green-500 rounded-full animate-pulse" />
            <span className="text-muted-foreground">Next call incoming...</span>
          </div>
        </>
      )}
      
      {status === 'break' && (
        <>
          <Separator />
          <div className="flex items-center gap-2 text-sm">
            <Coffee className="h-4 w-4 text-yellow-600" />
            <span className="text-muted-foreground">No calls will be routed</span>
          </div>
        </>
      )}
      
      {status === 'offline' && (
        <>
          <Separator />
          <div className="flex items-center gap-2 text-sm">
            <Power className="h-4 w-4 text-red-600" />
            <span className="text-muted-foreground">Sign in when ready</span>
          </div>
        </>
      )}
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/components/auth/protected-route.tsx===
import { Navigate } from 'react-router-dom'
import { useAuth } from '../../contexts/auth-context'
import { Loader2 } from 'lucide-react'

interface ProtectedRouteProps {
  children: React.ReactNode
  requireAuth?: boolean // Defaults to true for security
}

export function ProtectedRoute({ children, requireAuth = true }: ProtectedRouteProps) {
  const { isAuthenticated, isLoading } = useAuth()

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
      </div>
    )
  }

  // If authentication is not required, allow access
  if (!requireAuth) {
    return <>{children}</>
  }

  // Redirect to login if not authenticated
  if (!isAuthenticated) {
    return <Navigate to="/login" replace />
  }

  return <>{children}</>
}
===END FILE===

===BEGIN FILE: src/components/call-controls/inline-call-notification.tsx===
import { useState, useEffect, useRef } from 'react'
import { Card, CardContent } from '../ui/card'
import { Avatar, AvatarFallback } from '../ui/avatar'
import { Phone, X } from 'lucide-react'
import { useWebSocket } from '../../contexts/websocket-context'
import { useToast } from '../../hooks/use-toast'
import { useAgentData, useClearActions, useUpdateActions } from '../../stores/selectors/agent-selectors'
import { useAgentStatusStore } from '../../stores/agent-status-store'
import { audioService } from '../../services/audio.service'
import { useAgentSettings } from '../../hooks/use-agent-settings'
import { EndCallConfirmation } from '../dialogs/end-call-confirmation'
import { getAppConfig } from '../../config/app-config'

interface InlineCallNotificationProps {
  // Props simplified - state is now managed by Zustand store
  // Components can subscribe directly to the store for state updates
}

export function InlineCallNotification({}: InlineCallNotificationProps) {
  // Use Zustand store for all call state management
  const agentStatus = useAgentStatusStore(state => state.status)
  const callState = useAgentStatusStore(state => state.callState)
  const callerInfo = useAgentStatusStore(state => state.callerInfo)
  const callDuration = useAgentStatusStore(state => state.callDuration)
  const currentCallerId = useAgentStatusStore(state => state.currentCallerId)
  
  // Zustand actions
  const acceptCall = useAgentStatusStore(state => state.acceptCall)
  const endCall = useAgentStatusStore(state => state.endCall)
  const setCallerInfo = useAgentStatusStore(state => state.setCallerInfo)
  const updateHandleTime = useAgentStatusStore(state => state.updateHandleTime)
  
  const { settings: agentSettings, updateNestedSettings } = useAgentSettings()
  const callStartTime = useRef<Date | null>(null)
  // Remove local state since we're using Zustand store
  // const currentCallerInfoRef = useRef(callerInfo)
  const [showEndCallConfirm, setShowEndCallConfirm] = useState(false)
  const { connect, disconnect, sendMessage } = useWebSocket()
  const { toast } = useToast()
  
  // Use optimized selectors to reduce re-renders
  const agentData = useAgentData()
  const clearActions = useClearActions()
  const { updatePriority, updateAgentData } = useUpdateActions()
  
  // Draggable state - position next to "Simulate Call" button initially
  const savedPosition = localStorage.getItem('callNotificationPosition')
  const defaultPosition = { x: window.innerWidth / 2 + 100, y: 65 }
  const initialPosition = savedPosition ? JSON.parse(savedPosition) : defaultPosition
  
  const [position, setPosition] = useState(initialPosition)
  const [isDragging, setIsDragging] = useState(false)
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 })
  const notificationRef = useRef<HTMLDivElement>(null)

  // No longer needed - using Zustand store directly

  // Simulate different callers, play ringtone, and auto-accept if available
  useEffect(() => {
    if (callState === 'incoming') {
      const callers = [
        // Premier Banking (High Value)
        { name: 'Jonathan Mitchell', number: '+44-20-7946-0958', location: 'London, UK', priority: 'URGENT' as const },
        { name: 'Alexander Sterling', number: '+44-20-7123-4567', location: 'Edinburgh, UK', priority: 'HIGH' as const },
        { name: 'Victoria Pemberton', number: '+44-161-234-5678', location: 'Manchester, UK', priority: 'MEDIUM' as const },
        
        // Jade Banking (Ultra High Value)
        { name: 'Sarah Chen Wei', number: '+852-2234-5678', location: 'Hong Kong', priority: 'HIGH' as const },
        { name: 'Michael Zhang', number: '+86-21-6234-5678', location: 'Shanghai, China', priority: 'URGENT' as const },
        { name: 'Jennifer Liu', number: '+65-6234-5678', location: 'Singapore', priority: 'HIGH' as const },
        
        // HSBC Advance
        { name: 'Robert Thompson', number: '+1-212-555-0198', location: 'New York, NY', priority: 'MEDIUM' as const },
        { name: 'Emily Davis', number: '+1-617-555-0234', location: 'Boston, MA', priority: 'LOW' as const },
        { name: 'James Wilson', number: '+1-312-555-0345', location: 'Chicago, IL', priority: 'MEDIUM' as const },
        
        // HSBC Personal
        { name: 'Maria Santos', number: '+34-91-123-4567', location: 'Madrid, Spain', priority: 'LOW' as const },
        { name: 'Carlos Rodriguez', number: '+34-93-234-5678', location: 'Barcelona, Spain', priority: 'MEDIUM' as const },
        { name: 'Isabella Martinez', number: '+34-96-345-6789', location: 'Valencia, Spain', priority: 'LOW' as const },
        
        // Business Banking
        { name: 'Marcus Johnson', number: '+44-20-7234-5678', location: 'London, UK', priority: 'HIGH' as const },
        { name: 'Sophie Anderson', number: '+33-1-4234-5678', location: 'Paris, France', priority: 'MEDIUM' as const },
        
        // Student Banking
        { name: 'Oliver Chen', number: '+44-1865-234567', location: 'Oxford, UK', priority: 'LOW' as const },
        { name: 'Emma Thompson', number: '+44-1223-345678', location: 'Cambridge, UK', priority: 'LOW' as const }
      ]
      const randomCaller = callers[Math.floor(Math.random() * callers.length)]
      setCallerInfo(randomCaller)
      
      // Play HSBC electro ringtone when call comes in
      audioService.playRingtone().then((result) => {
        if (!result.success) {
          // Failed to play ringtone
          // Could show a visual indicator that audio is blocked
        }
      })
      
      // Auto-accept if agent is available AND auto-accept is enabled in settings
      if (agentStatus === 'available' && agentSettings.calls.autoAccept) {
        const timer = setTimeout(() => {
          handleAccept()
        }, 5000) // 5 second delay to view call before auto-accept
        
        return () => clearTimeout(timer)
      }
    } else {
      // Stop ringtone when call state changes from incoming
      audioService.stopRingtone()
    }
    
    // Cleanup: Stop ringtone when component unmounts or call state changes
    return () => {
      audioService.stopRingtone()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [callState, agentStatus, agentSettings.calls.autoAccept])

  // Call duration timer - now handled by Zustand store
  useEffect(() => {
    // Call duration is now managed by Zustand store
    // This effect is kept for any future cleanup needs
  }, [callState, currentCallerId])

  const handleReject = () => {
    // Stop ringtone immediately when call is rejected
    audioService.forceStopAllAudio()
    
    // Use Zustand store to reset call state
    setCallerInfo(null)
    // Note: setCallState should be handled by the store's logic
    
    toast({
      title: 'Call Declined',
      description: `Declined call from ${callerInfo?.name || 'Unknown'}`,
    })
    
    // No longer need to call onReject prop - state is managed by Zustand
  }

  const handleAccept = () => {
    
    if (!callerInfo) return
    
    // Stop ringtone immediately when call is accepted (force stop all audio)
    audioService.forceStopAllAudio()
    
    callStartTime.current = new Date()
    
    // Use Zustand action to accept the call
    acceptCall()
    
    const callerId = callerInfo.number // Use phone as callerId
    
    // First disconnect any existing WebSocket connection
    disconnect()
    
    // Clear all data AFTER disconnect to ensure clean state
    setTimeout(() => {
      clearActions.clearSentiment()
      clearActions.clearSummary()
      clearActions.clearIntent()
      clearActions.clearActions()
      clearActions.clearTranscript()
      clearActions.clearCustomer()
      clearActions.clearMetrics()
      clearActions.clearKnowledgeArticles()
      updatePriority(undefined)
      updateAgentData({ queuePosition: undefined })
      
      // Connect with new callerId after clearing
      setTimeout(() => {
        connect('agent-001', callerId, 8080)
      }, 100)
    }, 50)
    
    // Try to stop any existing simulation for this caller (ignore 404 errors)
    const config = getAppConfig()
    fetch(`${config.services.aiService.baseUrl}/api/calls/stop`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        callerId: callerId
      })
    }).catch(() => {
      // Silently ignore errors - simulation might not exist (404 is expected)
    }).finally(() => {
      // Now start new AI simulation for this call
      const aiRequestBody = {
        callerId: callerId,
        agentId: 'agent-001',
        callerName: callerInfo.name,
        callerNumber: callerInfo.number,
        callerLocation: 'Location not available' // Location not part of CallerInfo type
      }
      
      fetch(`${config.services.aiService.baseUrl}/api/calls/start`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(aiRequestBody)
      }).then(async response => {
        if (response.ok) {
        } else {
          const errorText = await response.text()
          // Failed to start AI simulation
        }
      }).catch(error => {
        // Failed to start AI simulation
      })
    })
    
    // Send accept call message with current caller info
    setTimeout(() => {
      sendMessage({
        type: 'accept_call',
        callerId: callerId,
        agentId: 'agent-001',
        callerName: callerInfo.name,
        timestamp: new Date().toISOString()
      })
    }, 500)

    // Also update the store with initial priority data for demo
    updatePriority({
      level: callerInfo.priority.toUpperCase() as 'LOW' | 'MEDIUM' | 'HIGH' | 'URGENT',
      waitTime: Math.floor(Math.random() * 300) + 60, // Random wait time 1-6 minutes
      estimatedResolution: Math.floor(Math.random() * 600) + 300, // 5-15 minutes
      escalation: callerInfo.priority === 'HIGH' || callerInfo.priority === 'URGENT'
    })
    updateAgentData({ queuePosition: Math.floor(Math.random() * 5) + 1 }) // Queue position 1-5
    
    // Customer data will come from PostgreSQL via WebSocket
    // No need to create hardcoded customer data here
    // The Java service will fetch real customer data from DB and send it
    // AI simulation already started above, no need to start again

    toast({
      title: 'Call Connected',
      description: `Connected with ${callerInfo.name}`,
    })

    // No longer need to call onAccept prop - state is managed by Zustand
  }

  
  const performEndCall = async () => {
    // Calculate call duration
    let actualDuration = callDuration // Use the actual tracked duration
    if (callStartTime.current) {
      actualDuration = Math.floor((new Date().getTime() - callStartTime.current.getTime()) / 1000)
      callStartTime.current = null
    }
    
    // Stop AI simulation for this call
    if (currentCallerId) {
      const config = getAppConfig()
      fetch(`${config.services.aiService.baseUrl}/api/calls/stop`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          callerId: currentCallerId,
          agentId: 'agent-001'
        })
      }).then(response => {
        if (response.ok) {
        }
      }).catch(error => {
        // Failed to stop AI simulation
      })
    }
    
    // Update metrics in the store (calls handled is incremented by useAgentStatus hook)
    updateHandleTime(actualDuration)
    // Send end call message first
    sendMessage({
      type: 'end_call',
      callerId: currentCallerId,
      agentId: 'agent-001',
      duration: callDuration,
      timestamp: new Date().toISOString()
    })

    // Clear all agent data for fresh start
    setTimeout(() => {
      clearActions.clearSentiment()
      clearActions.clearSummary()
      clearActions.clearIntent()
      clearActions.clearActions()
      clearActions.clearTranscript()
      clearActions.clearCustomer()
      clearActions.clearMetrics()
      updatePriority(undefined)
      updateAgentData({ queuePosition: undefined })
      // Clear the stored customer data
      window.localStorage.removeItem('currentCallCustomer')
    }, 300)

    // Disconnect WebSocket after a short delay to ensure messages are sent
    setTimeout(() => {
      disconnect()
    }, 500)

    // Use Zustand action to end the call
    endCall()
    
    toast({
      title: 'Call Ended',
      description: `Call duration: ${formatDuration(callDuration)}`,
    })

    // No longer need to call onEnd prop - state is managed by Zustand
  }
  
  const handleConfirmedEndCall = () => {
    setShowEndCallConfirm(false)
    performEndCall()
  }

  const formatDuration = (seconds: number): string => {
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  // Drag handlers
  const handleMouseDown = (e: React.MouseEvent) => {
    if ((e.target as HTMLElement).classList.contains('drag-handle')) {
      setIsDragging(true)
      setDragStart({
        x: e.clientX - position.x,
        y: e.clientY - position.y
      })
      e.preventDefault()
    }
  }

  const handleMouseMove = (e: MouseEvent) => {
    if (isDragging) {
      const newX = e.clientX - dragStart.x
      const newY = e.clientY - dragStart.y
      
      // Keep within viewport bounds
      const maxX = window.innerWidth - (notificationRef.current?.offsetWidth || 400)
      const maxY = window.innerHeight - (notificationRef.current?.offsetHeight || 100)
      
      setPosition({
        x: Math.max(0, Math.min(newX, maxX)),
        y: Math.max(0, Math.min(newY, maxY))
      })
    }
  }

  const handleMouseUp = () => {
    setIsDragging(false)
    // Save position to localStorage
    localStorage.setItem('callNotificationPosition', JSON.stringify(position))
  }

  // Add global mouse event listeners for dragging
  useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove)
      document.addEventListener('mouseup', handleMouseUp)
      
      return () => {
        document.removeEventListener('mousemove', handleMouseMove)
        document.removeEventListener('mouseup', handleMouseUp)
      }
    }
  }, [isDragging, dragStart])

  // Save position when it changes (after drag ends)
  useEffect(() => {
    if (!isDragging && position !== initialPosition) {
      localStorage.setItem('callNotificationPosition', JSON.stringify(position))
    }
  }, [position, isDragging])

  if (callState === 'incoming') {
    const isAutoAccepting = agentStatus === 'available' && agentSettings.calls.autoAccept
    
    return (
      <div className="fixed inset-0 z-40 flex items-start justify-center pt-24 pointer-events-none">
        {/* Subtle dark overlay for contrast */}
        <div className="fixed inset-0 bg-black/10 pointer-events-none" />
        
        <div className="pointer-events-auto animate-in slide-in-from-top-4 duration-500">
          <div className="relative">
            {/* Soft ambient glow */}
            <div className="absolute -inset-8 bg-gradient-to-r from-blue-400/10 via-purple-400/10 to-pink-400/10 rounded-[3rem] blur-3xl" />
            
            {/* Main liquid glass card */}
            <div className="relative w-[380px] backdrop-blur-[100px] bg-white/[0.05] dark:bg-white/[0.02] border border-white/20 dark:border-white/10 shadow-2xl overflow-hidden rounded-[2rem]">
              {/* Multiple gradient layers for depth */}
              <div className="absolute inset-0 bg-gradient-to-br from-white/[0.12] via-white/[0.04] to-transparent pointer-events-none" />
              <div className="absolute inset-0 bg-gradient-to-tr from-blue-400/[0.05] via-transparent to-purple-400/[0.05] pointer-events-none" />
              
              {/* Subtle noise texture */}
              <div className="absolute inset-0 opacity-[0.01] mix-blend-overlay pointer-events-none" 
                   style={{
                     backgroundImage: `url("data:image/svg+xml,%3Csvg width='60' height='60' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' /%3E%3C/filter%3E%3Crect width='60' height='60' filter='url(%23noise)' opacity='0.4' /%3E%3C/svg%3E")`,
                   }} />
              
              <div className="relative p-6 backdrop-saturate-150">
              {/* Caller Info Section */}
              <div className="flex flex-col items-center text-center mb-6">
                {/* Liquid glass avatar */}
                <div className="w-20 h-20 mb-4 relative">
                  <div className="absolute inset-0 rounded-full bg-gradient-to-br from-blue-400/80 to-blue-600/80 blur-md" />
                  <div className="relative w-full h-full rounded-full backdrop-blur-xl bg-gradient-to-br from-blue-400/60 to-blue-600/60 ring-2 ring-white/20 shadow-xl flex items-center justify-center">
                    <span className="text-white/95 text-2xl font-semibold drop-shadow-sm">
                      {callerInfo.name.split(' ').map(n => n[0]).join('')}
                    </span>
                  </div>
                </div>
                
                <div className="space-y-1">
                  <h3 className="text-xl font-semibold text-gray-900 dark:text-white/95">
                    {callerInfo.name}
                  </h3>
                  <p className="text-sm text-gray-700 dark:text-white/75">
                    {callerInfo.number}
                  </p>
                  <p className="text-xs text-gray-600 dark:text-white/60">
                    {callerInfo.location}
                  </p>
                </div>
                
                {/* Liquid glass badge */}
                <div className="mt-3 inline-flex items-center px-3 py-1 rounded-full backdrop-blur-xl bg-white/10 border border-white/20">
                  <div className={`w-2 h-2 rounded-full mr-2 ${
                    callerInfo.priority === 'URGENT' ? 'bg-red-400' :
                    callerInfo.priority === 'HIGH' ? 'bg-orange-400' :
                    callerInfo.priority === 'MEDIUM' ? 'bg-yellow-400' : 'bg-green-400'
                  }`} />
                  <span className="text-xs font-medium text-gray-700 dark:text-white/80">
                    {callerInfo.priority} Priority
                  </span>
                </div>
              </div>
              
              {/* Auto Accept Indicator with liquid glass */}
              {isAutoAccepting ? (
                <div className="flex items-center justify-between py-3 px-4 backdrop-blur-xl bg-green-400/10 rounded-2xl mb-4 border border-green-400/20">
                  <div className="flex items-center gap-2">
                    <div className="h-2 w-2 bg-green-400 rounded-full animate-pulse" />
                    <span className="text-sm font-medium text-gray-700 dark:text-green-300/90">
                      Auto-accepting call...
                    </span>
                  </div>
                  <button
                    onClick={() => updateNestedSettings('calls', { autoAccept: false })}
                    className="text-xs px-2 py-1 rounded-lg bg-white/10 hover:bg-white/20 text-gray-700 dark:text-white/70 border border-white/20 transition-colors"
                  >
                    Cancel
                  </button>
                </div>
              ) : null}
              
              {/* Action Buttons */}
              {!isAutoAccepting && (
                <div className="flex items-center justify-center gap-6">
                  {/* Decline Button - Liquid Glass */}
                  <button
                    onClick={handleReject}
                    className="group relative w-16 h-16 rounded-full backdrop-blur-2xl bg-red-500/20 hover:bg-red-500/30 shadow-lg hover:shadow-xl transform hover:scale-110 transition-all duration-300 border border-red-400/30 hover:border-red-400/50"
                  >
                    <div className="absolute inset-0 rounded-full bg-gradient-to-b from-white/10 to-transparent" />
                    <X className="w-7 h-7 text-red-600 dark:text-red-400 absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2" />
                  </button>
                  
                  {/* Accept Button - Liquid Glass with pulse */}
                  <button
                    onClick={handleAccept}
                    data-accept-call="true"
                    className="group relative w-20 h-20 rounded-full backdrop-blur-2xl bg-green-500/20 hover:bg-green-500/30 shadow-xl hover:shadow-2xl transform hover:scale-110 transition-all duration-300 border border-green-400/30 hover:border-green-400/50"
                  >
                    <div className="absolute inset-0 rounded-full bg-gradient-to-b from-white/10 to-transparent" />
                    <div className="absolute inset-0 rounded-full animate-ping bg-green-400/20" />
                    <Phone className="w-9 h-9 text-green-600 dark:text-green-400 absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2" />
                  </button>
                </div>
              )}
              
              {/* Button Labels with better visibility */}
              {!isAutoAccepting && (
                <div className="flex items-center justify-center gap-12 mt-3">
                  <span className="text-xs text-gray-600 dark:text-white/60 font-medium">Decline</span>
                  <span className="text-xs text-gray-600 dark:text-white/60 font-medium ml-2">Accept</span>
                </div>
              )}
              </div>
            </div>
          </div>
        </div>
      </div>
    )
  }

  // Active call is now handled inline in the dashboard header
  // if (callState === 'active') {
  //   return null
  // }

  return (
    <>
      {/* End Call Confirmation Dialog */}
      <EndCallConfirmation
        isOpen={showEndCallConfirm}
        onConfirm={handleConfirmedEndCall}
        onCancel={() => setShowEndCallConfirm(false)}
        callerName={callerInfo.name}
        duration={callDuration}
        incompleteActions={agentData.actions?.filter(action => !action.completed).length || 0}
        requireActionsCompletion={agentSettings.calls.requireActionsCompletion}
      />
    </>
  )
}
===END FILE===

===BEGIN FILE: src/components/call-controls/media-control-bar.tsx===
import { useState, useEffect, useRef, useCallback } from 'react'
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { 
  Phone, 
  PhoneIncoming,
  PhoneCall,
  Mic, 
  MicOff, 
  Pause, 
  Play, 
  PhoneOff,
  PhoneForwarded,
  X
} from 'lucide-react'
import { useAgentData, useClearActions, useUpdateActions } from '../../stores/selectors/agent-selectors'
import { useAgentStatusStore, CallState } from '../../stores/agent-status-store'
import { useWebSocket } from '../../contexts/websocket-context'
import { useToast } from '../../hooks/use-toast'
import { audioService } from '../../services/audio.service'
import { useAgentSettings } from '../../hooks/use-agent-settings'
import { EndCallConfirmation } from '../dialogs/end-call-confirmation'
import { AgentStatusToggle } from '../agent-status/agent-status-toggle'
import { useAgentStatus } from '../../hooks/use-agent-status'
import { cn } from '../../lib/utils'
import { getAppConfig } from '../../config/app-config'

interface MediaControlBarProps {
  // Props will be removed as we use centralized state
}

// Sample callers for simulation
const SAMPLE_CALLERS = [
  // Premier Banking (High Value)
  { name: 'Jonathan Mitchell', number: '+44-20-7946-0958', location: 'London, UK', priority: 'URGENT' as const },
  { name: 'Alexander Sterling', number: '+44-20-7123-4567', location: 'Edinburgh, UK', priority: 'HIGH' as const },
  { name: 'Victoria Pemberton', number: '+44-161-234-5678', location: 'Manchester, UK', priority: 'MEDIUM' as const },
  
  // Jade Banking (Ultra High Value)
  { name: 'Sarah Chen Wei', number: '+852-2234-5678', location: 'Hong Kong', priority: 'HIGH' as const },
  { name: 'Michael Zhang', number: '+86-21-6234-5678', location: 'Shanghai, China', priority: 'URGENT' as const },
  { name: 'Jennifer Liu', number: '+65-6234-5678', location: 'Singapore', priority: 'HIGH' as const },
  
  // HSBC Advance
  { name: 'Robert Thompson', number: '+1-212-555-0198', location: 'New York, NY', priority: 'MEDIUM' as const },
  { name: 'Emily Davis', number: '+1-617-555-0234', location: 'Boston, MA', priority: 'LOW' as const },
  { name: 'James Wilson', number: '+1-312-555-0345', location: 'Chicago, IL', priority: 'MEDIUM' as const },
  
  // Business Banking
  { name: 'Marcus Johnson', number: '+44-20-7234-5678', location: 'London, UK', priority: 'HIGH' as const },
  { name: 'Sophie Anderson', number: '+33-1-4234-5678', location: 'Paris, France', priority: 'MEDIUM' as const },
]

export function MediaControlBar({}: MediaControlBarProps) {
  const agentData = useAgentData()
  const clearActions = useClearActions()
  const { updatePriority, updateAgentData } = useUpdateActions()
  const { settings: agentSettings } = useAgentSettings()
  const { connect, disconnect, sendMessage } = useWebSocket()
  const { toast } = useToast()
  
  // Use Zustand store for call state instead of local React state
  const callState = useAgentStatusStore(state => state.callState)
  const isMuted = useAgentStatusStore(state => state.isMuted)
  const isOnHold = useAgentStatusStore(state => state.isOnHold)
  const callDuration = useAgentStatusStore(state => state.callDuration)
  const callerInfo = useAgentStatusStore(state => state.callerInfo)
  const currentCallerId = useAgentStatusStore(state => state.currentCallerId)
  
  // Zustand actions for call state management
  const setIsMuted = useAgentStatusStore(state => state.setIsMuted)
  const setIsOnHold = useAgentStatusStore(state => state.setIsOnHold)
  const setCallDuration = useAgentStatusStore(state => state.setCallDuration)
  const setCallerInfo = useAgentStatusStore(state => state.setCallerInfo)
  const setCurrentCallerId = useAgentStatusStore(state => state.setCurrentCallerId)
  const startCall = useAgentStatusStore(state => state.startCall)
  const acceptCall = useAgentStatusStore(state => state.acceptCall)
  const endCall = useAgentStatusStore(state => state.endCall)
  
  const [showEndCallConfirm, setShowEndCallConfirm] = useState(false)
  
  const callStartTime = useRef<Date | null>(null)
  const autoAcceptTimer = useRef<NodeJS.Timeout | null>(null)
  const isProcessingCall = useRef<boolean>(false)
  const callCounter = useRef<number>(0) // Track number of calls for rotation
  
  // Refs to track current state (avoids closure issues)
  const currentCallStateRef = useRef<CallState>(callState)
  const currentCallerInfoRef = useRef<typeof callerInfo>(callerInfo)
  
  // Update refs whenever state changes
  useEffect(() => {
    currentCallStateRef.current = callState
  }, [callState])
  
  useEffect(() => {
    currentCallerInfoRef.current = callerInfo
  }, [callerInfo])
  
  // Simulate incoming call
  const simulateIncomingCall = useCallback(() => {
    // Prevent duplicate calls
    if (isProcessingCall.current) {
      return
    }
    
    if (currentCallStateRef.current !== 'idle') {
      toast({
        title: 'Call in Progress',
        description: 'Please end the current call first',
        variant: 'destructive'
      })
      return
    }
    
    // Mark as processing
    isProcessingCall.current = true
    
    // Increment call counter
    callCounter.current += 1
    
    let selectedCaller;
    
    // Every 3rd call should be Jonathan Mitchell (credit card fraud)
    if (callCounter.current % 3 === 0) {
      // Find Jonathan Mitchell in the list
      selectedCaller = SAMPLE_CALLERS.find(c => c.name === 'Jonathan Mitchell') || SAMPLE_CALLERS[0]
    } else {
      // Pick a random caller from the others (excluding Jonathan Mitchell)
      const otherCallers = SAMPLE_CALLERS.filter(c => c.name !== 'Jonathan Mitchell')
      selectedCaller = otherCallers[Math.floor(Math.random() * otherCallers.length)]
    }
    
    // Use Zustand action to start call
    startCall(selectedCaller.number, selectedCaller)
    
    // Reset processing flag after a short delay
    setTimeout(() => {
      isProcessingCall.current = false
    }, 1000)
    
    // Play ringtone
    audioService.playRingtone().then((result) => {
      if (!result.success) {
        // Failed to play ringtone
      }
    })
  }, [toast, startCall])
  
  // Create a ref for the auto-call trigger function
  const autoCallTriggerRef = useRef<(() => void) | null>(null)
  
  // Use agent status hook with ref-based auto-call
  const { 
    handleCallEnded: handleStatusCallEnded, 
    status: agentStatus, 
    getStatusColor,
    canAcceptCalls,
    getStatusLabel,
    setStatus: setAgentStatus,
    afterCallWorkSecondsRemaining,
    doNotDisturbSecondsRemaining
  } = useAgentStatus({
    onAutoCall: () => autoCallTriggerRef.current?.()
  })
  
  // Trigger auto-call when agent becomes available
  const triggerAutoCall = useCallback(() => {
    // Check if agent can accept calls (respects DND, after-call work, etc.)
    if (!canAcceptCalls()) {
      return
    }
    
    // Double-check that we're truly idle with no active caller (using refs to avoid closure issues)
    if (currentCallStateRef.current === 'idle' && !currentCallerInfoRef.current) {
      simulateIncomingCall()
    } else if (currentCallStateRef.current === 'idle' && currentCallerInfoRef.current) {
      setCallerInfo(null)
      setCurrentCallerId('')
    }
  }, [simulateIncomingCall, canAcceptCalls])
  
  // Set the auto-call trigger function in the ref
  useEffect(() => {
    autoCallTriggerRef.current = triggerAutoCall
  }, [triggerAutoCall])
  
  
  
  
  // Update call duration timer
  useEffect(() => {
    let interval: NodeJS.Timeout
    
    if (callState === 'active' && callStartTime.current) {
      interval = setInterval(() => {
        const now = new Date()
        const diff = Math.floor((now.getTime() - callStartTime.current!.getTime()) / 1000)
        setCallDuration(diff)
      }, 1000)
    } else if (callState !== 'active') {
      setCallDuration(0)
    }
    
    return () => {
      if (interval) clearInterval(interval)
    }
  }, [callState])
  
  // Format duration to MM:SS or HH:MM:SS
  const formatDuration = useCallback((seconds: number): string => {
    const hours = Math.floor(seconds / 3600)
    const mins = Math.floor((seconds % 3600) / 60)
    const secs = seconds % 60
    
    if (hours > 0) {
      return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
    }
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }, [])
  
  // Clear all widget data
  const clearAllData = useCallback(() => {
    clearActions.clearSentiment()
    clearActions.clearSummary()
    clearActions.clearIntent()
    clearActions.clearActions()
    clearActions.clearTranscript()
    clearActions.clearCustomer()
    clearActions.clearMetrics()
    clearActions.clearKnowledgeArticles()
    updatePriority(undefined)
    updateAgentData({ queuePosition: undefined })
  }, [clearActions, updatePriority, updateAgentData])
  
  // Handle accept call
  const handleAcceptCall = useCallback(() => {
    if (!callerInfo) return
    
    // Stop ringtone
    audioService.forceStopAllAudio()
    
    // Clear auto-accept timer
    if (autoAcceptTimer.current) {
      clearTimeout(autoAcceptTimer.current)
      autoAcceptTimer.current = null
    }
    
    callStartTime.current = new Date()
    const callerId = callerInfo.number // Keep original phone format for database lookup
    setCurrentCallerId(callerId)
    
    // Clear all data first
    clearAllData()
    
    // Connect WebSocket
    setTimeout(() => {
      connect('agent-001', callerId, 8080)
    }, 100)
    
    // Start AI simulation
    const config = getAppConfig()
    fetch(`${config.services.aiService.baseUrl}/api/calls/start`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        callerId: callerId,
        agentId: 'agent-001',
        callerName: callerInfo.name,
        callerNumber: callerInfo.number,
        callerLocation: callerInfo.location
      })
    }).catch(error => {
      // Failed to start AI simulation
    })
    
    // Update priority data
    updatePriority({
      level: callerInfo.priority,
      waitTime: Math.floor(Math.random() * 300) + 60,
      estimatedResolution: Math.floor(Math.random() * 600) + 300,
      escalation: callerInfo.priority === 'URGENT'
    })
    updateAgentData({ queuePosition: Math.floor(Math.random() * 5) + 1 })
    
    // Use Zustand action to accept call
    acceptCall()
    
    // IMPORTANT: Set agent status to on-call when call becomes active
    setAgentStatus('on-call')
  }, [callerInfo, clearAllData, connect, updatePriority, updateAgentData, setAgentStatus, acceptCall])
  
  // Auto-accept incoming calls if agent is available
  useEffect(() => {
    if (callState === 'incoming' && agentStatus === 'available' && agentSettings.calls.autoAccept) {
      autoAcceptTimer.current = setTimeout(() => {
        handleAcceptCall()
      }, 5000) // 5 second delay
      
      return () => {
        if (autoAcceptTimer.current) {
          clearTimeout(autoAcceptTimer.current)
          autoAcceptTimer.current = null
        }
      }
    }
  }, [callState, agentStatus, agentSettings.calls.autoAccept, handleAcceptCall])
  
  // Handle reject call
  const handleRejectCall = useCallback(() => {
    audioService.forceStopAllAudio()
    
    if (autoAcceptTimer.current) {
      clearTimeout(autoAcceptTimer.current)
      autoAcceptTimer.current = null
    }
    
    const declinedCallerName = callerInfo?.name
    
    // Use Zustand action to end call
    endCall()
    
    toast({
      title: 'Call Declined',
      description: declinedCallerName ? `Declined call from ${declinedCallerName}` : 'Call declined',
    })
    
    // Use handleCallEnded to trigger next call through the agent status hook
    // This ensures proper queue management and delay timing
    // Increased delay to ensure React has time to process state updates
    setTimeout(() => {
      handleStatusCallEnded(0) // Pass 0 duration for declined calls
    }, 500) // Increased from 100ms to 500ms
  }, [callState, callerInfo, handleStatusCallEnded, endCall])
  
  // Handle end call
  const handleEndCall = useCallback(async () => {
    const incompleteActions = agentData.actions?.filter(action => !action.completed).length || 0
    
    if (agentSettings.calls.confirmBeforeEnd || 
        (agentSettings.calls.requireActionsCompletion && incompleteActions > 0)) {
      setShowEndCallConfirm(true)
      return
    }
    
    performEndCall()
  }, [agentData.actions, agentSettings.calls])
  
  // Perform actual end call
  const performEndCall = useCallback(async () => {
    const actualDuration = callDuration
    
    // Stop AI simulation
    if (currentCallerId) {
      const config = getAppConfig()
      fetch(`${config.services.aiService.baseUrl}/api/calls/stop`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          callerId: currentCallerId,
          agentId: 'agent-001'
        })
      }).catch(error => {
        // Failed to stop AI simulation
      })
    }
    
    // Send end call message before disconnecting
    sendMessage({
      type: 'end_call',
      callerId: currentCallerId,
      agentId: 'agent-001',
      duration: actualDuration,
      timestamp: new Date().toISOString()
    })
    
    // Clear all data
    setTimeout(() => {
      clearAllData()
    }, 300)
    
    // Disconnect WebSocket
    setTimeout(() => {
      disconnect()
    }, 500)
    
    // Use Zustand action to end call (handles all state reset)
    endCall()
    callStartTime.current = null
    
    toast({
      title: 'Call Ended',
      description: `Call duration: ${formatDuration(actualDuration)}`,
    })
    
    // Update metrics through status hook - this will trigger the next call
    // IMPORTANT: Call this AFTER resetting state to avoid conflicts
    // Increased delay to ensure React has time to process state updates
    setTimeout(() => {
      handleStatusCallEnded(actualDuration)
    }, 500) // Increased from 100ms to 500ms
  }, [callDuration, currentCallerId, handleStatusCallEnded, sendMessage, clearAllData, disconnect, formatDuration, endCall])
  
  // Handle confirmed end call
  const handleConfirmedEndCall = useCallback(() => {
    setShowEndCallConfirm(false)
    performEndCall()
  }, [performEndCall])
  
  // Handle transfer (placeholder)
  const handleTransfer = useCallback(() => {
    toast({
      title: 'Transfer',
      description: 'Transfer functionality coming soon',
    })
  }, [])
  
  // Render incoming call notification with clean liquid glass design
  if (callState === 'incoming' && callerInfo) {
    const isAutoAccepting = agentStatus === 'available' && agentSettings.calls.autoAccept
    
    return (
      <>
        <div className="sticky top-0 z-50 overflow-hidden">
          {/* Clean liquid glass background */}
          <div className="absolute inset-0 bg-gradient-to-r from-white/60 to-white/70 backdrop-blur-2xl" />
          
          {/* Subtle shimmer effect */}
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/5 to-transparent -skew-x-12 animate-shimmer" />
          
          {/* Animated fluid border effect */}
          <div className="absolute inset-0 overflow-hidden">
            <div className="absolute inset-0 opacity-30">
              <div className="absolute top-0 left-0 w-full h-[2px] bg-gradient-to-r from-transparent via-blue-500 to-transparent animate-pulse" />
              <div className="absolute top-0 left-0 w-full h-[2px] bg-gradient-to-r from-transparent via-green-500 to-transparent animate-pulse" style={{ animationDelay: '0.5s' }} />
              <div className="absolute top-0 left-0 w-full h-[2px] bg-gradient-to-r from-transparent via-purple-500 to-transparent animate-pulse" style={{ animationDelay: '1s' }} />
            </div>
          </div>
          
          {/* Glass morphism container - clean and professional with rounded edges */}
          <div className="relative bg-white/30 backdrop-blur-xl shadow-lg animate-in slide-in-from-top-2 duration-500 rounded-2xl mx-2 mt-2 border-2 animate-wave-border">
            {/* Beautiful animated border */}
            <div className="absolute inset-0 rounded-2xl overflow-hidden pointer-events-none">
              <div className="absolute inset-0 bg-gradient-to-r from-blue-400/20 via-green-400/20 to-purple-400/20 animate-gradient-x" />
              <div className="absolute inset-[2px] bg-white/40 rounded-2xl backdrop-blur-xl" />
            </div>
            
            <div className="relative flex flex-wrap items-center justify-between h-16 gap-2 md:gap-3 px-3 sm:px-4 md:px-6">
              <div className="flex items-center gap-3 md:gap-4 flex-1 min-w-0">
                {/* Clean phone icon with subtle pulse */}
                <div className="relative">
                  <div className="absolute inset-0 bg-blue-500/20 rounded-full blur-lg animate-pulse" />
                  <PhoneIncoming className="relative h-5 w-5 text-blue-600" />
                </div>
                
                <div className="space-y-1 min-w-0 overflow-hidden">
                  <div className="flex items-center gap-2">
                    <span className="font-medium text-gray-900 tracking-wide text-[15px] truncate">
                      <span className="hidden sm:inline">{callerInfo.name}</span>
                      <span className="sm:hidden">{callerInfo.name.split(' ')[0]}</span>
                    </span>
                    <Badge 
                      variant="outline" 
                      className={cn(
                        "text-[10px] sm:text-[11px] font-medium px-1.5 sm:px-2 py-0.5 border flex-shrink-0",
                        callerInfo.priority === 'URGENT' && "border-red-500 text-red-600 bg-red-50/50 animate-pulse",
                        callerInfo.priority === 'HIGH' && "border-orange-500 text-orange-600 bg-orange-50/50",
                        callerInfo.priority === 'MEDIUM' && "border-yellow-500 text-yellow-600 bg-yellow-50/50",
                        callerInfo.priority === 'LOW' && "border-green-500 text-green-600 bg-green-50/50"
                      )}
                    >
                      <span className="hidden sm:inline">{callerInfo.priority}</span>
                      <span className="sm:hidden">{callerInfo.priority.charAt(0)}</span>
                    </Badge>
                  </div>
                  <div className="text-[12px] sm:text-[13px] text-gray-600 font-normal truncate">
                    <span className="hidden lg:inline">{callerInfo.number} • </span>
                    <span className="hidden sm:inline lg:hidden">{callerInfo.number.slice(-4)} • </span>
                    <span className="sm:hidden">{callerInfo.number.slice(-4)} • </span>
                    <span className="hidden lg:inline">{callerInfo.location}</span>
                    <span className="hidden sm:inline lg:hidden">{callerInfo.location.split(',')[0]}</span>
                    <span className="sm:hidden">{callerInfo.location.split(',')[0].split(' ')[0]}</span>
                  </div>
                </div>
              </div>
              
              <div className="flex items-center gap-1.5 sm:gap-2 md:gap-3 shrink-0">
                {isAutoAccepting && (
                  <Badge 
                    variant="secondary" 
                    className="text-[10px] sm:text-[11px] bg-blue-100/60 text-blue-700 border border-blue-200/30 whitespace-nowrap max-w-[45vw] md:max-w-[320px] truncate"
                  >
                    <span className="hidden md:inline">Auto-accepting in 5s...</span>
                    <span className="hidden sm:inline md:hidden">Auto 5s...</span>
                    <span className="sm:hidden">5s</span>
                  </Badge>
                )}
                
                {/* Clean Decline button */}
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleRejectCall}
                  className="gap-1 sm:gap-2 bg-white/50 backdrop-blur-sm border-gray-300/50 hover:bg-red-500 hover:border-red-500 hover:text-white transition-all duration-200 text-gray-700 font-medium shrink-0 whitespace-nowrap"
                >
                  <X className="h-4 w-4" />
                  <span className="hidden sm:inline">Decline</span>
                  <span className="sm:hidden">✗</span>
                </Button>
                
                {/* Clean Accept button */}
                <Button
                  variant="default"
                  size="sm"
                  onClick={handleAcceptCall}
                  className="gap-1 sm:gap-2 bg-green-600 hover:bg-green-700 border-green-600 shadow-sm transition-all duration-200 text-white font-medium shrink-0 whitespace-nowrap"
                >
                  <Phone className="h-4 w-4" />
                  <span className="hidden sm:inline">Accept</span>
                  <span className="inline sm:hidden">✓</span>
                </Button>
              </div>
            </div>
          </div>
        </div>
        
        {/* End Call Confirmation Dialog */}
        <EndCallConfirmation
          isOpen={showEndCallConfirm}
          onConfirm={handleConfirmedEndCall}
          onCancel={() => setShowEndCallConfirm(false)}
          callerName={callerInfo.name}
          duration={callDuration}
          incompleteActions={agentData.actions?.filter(action => !action.completed).length || 0}
          requireActionsCompletion={agentSettings.calls.requireActionsCompletion}
        />
      </>
    )
  }
  
  // Render active call controls
  if (callState === 'active') {
    return (
      <>
        <div className="sticky top-0 z-10 bg-white/95 dark:bg-slate-900/95 backdrop-blur-sm border-b">
          <div className="flex items-center justify-between h-10 px-3">
            {/* Left: Call Timer and Status */}
            <div className="flex items-center gap-3">
              <div className="flex items-center gap-1.5">
                <PhoneCall className="h-3 w-3 text-green-600" />
                <span className="font-mono text-sm font-semibold text-green-700 dark:text-green-400">
                  {formatDuration(callDuration)}
                </span>
              </div>
              
              <Badge variant="secondary" className="text-xs h-5 px-2">
                {callerInfo?.name || 'Connected'}
              </Badge>
              
              {isOnHold && (
                <Badge variant="outline" className="text-xs h-5 px-2 border-amber-500 text-amber-600">
                  Hold
                </Badge>
              )}
            </div>
            
            {/* Center: Compact Controls */}
            <div className="flex items-center gap-1">
              {/* Mute Button */}
              <Button
                variant={isMuted ? "destructive" : "ghost"}
                size="icon"
                className="h-7 w-7"
                onClick={() => setIsMuted(!isMuted)}
                title={isMuted ? "Unmute" : "Mute"}
              >
                {isMuted ? <MicOff className="h-3 w-3" /> : <Mic className="h-3 w-3" />}
              </Button>
              
              {/* Hold Button */}
              <Button
                variant={isOnHold ? "secondary" : "ghost"}
                size="icon"
                className="h-7 w-7"
                onClick={() => {
                  if (isOnHold) {
                    acceptCall() // Resume call
                  } else {
                    // For hold functionality, we can extend the store or handle locally
                    // For now, keeping the hold state management local until store is extended
                    setIsOnHold(true)
                  }
                }}
                title={isOnHold ? "Resume" : "Hold"}
              >
                {isOnHold ? <Play className="h-3 w-3" /> : <Pause className="h-3 w-3" />}
              </Button>
              
              {/* Transfer Button */}
              <Button 
                variant="ghost" 
                size="icon"
                className="h-7 w-7"
                onClick={handleTransfer}
                title="Transfer"
              >
                <PhoneForwarded className="h-3 w-3" />
              </Button>
              
              {/* End Call Button */}
              <Button 
                variant="destructive" 
                size="icon"
                className="h-7 w-7 bg-red-500 hover:bg-red-600"
                onClick={handleEndCall}
                title="End call"
              >
                <PhoneOff className="h-3 w-3" />
              </Button>
            </div>
            
            {/* Right: Agent Status */}
            <div className="flex items-center gap-2">
              <div className={cn("w-1.5 h-1.5 rounded-full", getStatusColor(agentStatus))} />
              <span className="text-xs text-muted-foreground">
                {getStatusLabel(agentStatus)}
              </span>
            </div>
          </div>
        </div>
        
        {/* End Call Confirmation Dialog */}
        <EndCallConfirmation
          isOpen={showEndCallConfirm}
          onConfirm={handleConfirmedEndCall}
          onCancel={() => setShowEndCallConfirm(false)}
          callerName={callerInfo?.name || 'Unknown'}
          duration={callDuration}
          incompleteActions={agentData.actions?.filter(action => !action.completed).length || 0}
          requireActionsCompletion={agentSettings.calls.requireActionsCompletion}
        />
      </>
    )
  }
  
  // Render idle state with status toggle (no simulate button - calls auto-trigger)
  return (
    <div className="sticky top-0 z-10 bg-white/95 dark:bg-slate-900/95 backdrop-blur-sm border-b">
      <div className="flex items-center justify-between h-10 px-3">
        {/* Left: Agent Status Toggle */}
        <AgentStatusToggle 
          compact={true} 
          onAutoCall={triggerAutoCall}
        />
        
        {/* Right: Call status with special states */}
        <div className="flex items-center gap-2 text-sm">
          {agentStatus === 'after-call-work' ? (
            <div className="flex items-center gap-2 text-purple-600">
              <div className="w-2 h-2 rounded-full bg-purple-500 animate-pulse" />
              <span>After Call Work - {afterCallWorkSecondsRemaining}s remaining</span>
            </div>
          ) : agentStatus === 'do-not-disturb' ? (
            <div className="flex items-center gap-2 text-orange-600">
              <div className="w-2 h-2 rounded-full bg-orange-500 animate-pulse" />
              <span>Do Not Disturb - {Math.floor(doNotDisturbSecondsRemaining / 60)}:{(doNotDisturbSecondsRemaining % 60).toString().padStart(2, '0')} remaining</span>
            </div>
          ) : (
            <div className="flex items-center gap-2 text-muted-foreground">
              <Phone className="h-3 w-3" />
              <span>No active call - Waiting for calls</span>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/components/chat/chat-window.tsx===
import { useState, useEffect, useRef } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '../ui/card'
import { Input } from '../ui/input'
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { ScrollArea } from '../ui/scroll-area'
import { Avatar, AvatarFallback } from '../ui/avatar'
import { 
  Send, 
  Paperclip, 
  Smile, 
  MoreVertical, 
  ArrowLeft,
  Phone,
  Mail,
  CreditCard,
  CheckCircle,
  AlertTriangle,
  AlertCircle,
  Building2,
  Home,
  Monitor,
  HelpCircle
} from 'lucide-react'
import { cn } from '../../lib/utils'
import { Customer, ChatMessage } from '../../types/chat-types'
import { CustomerQueue } from './customer-queue'
import { 
  generateCustomerResponse, 
  getResponseDelay, 
  shouldCustomerEndConversation,
  generateThankYouMessage 
} from '../../utils/chat-ai-responses'
import { 
  getCustomerAvatarInitials,
  getPriorityColor,
  getPriorityIcon,
  getCategoryIcon
} from '../../utils/mock-customers'

interface ChatWindowProps {
  className?: string
}

export function ChatWindow({ className }: ChatWindowProps) {
  const [mode, setMode] = useState<'queue' | 'chat'>('queue')
  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null)
  const [inputText, setInputText] = useState('')
  const [messages, setMessages] = useState<ChatMessage[]>([])
  const [isCustomerTyping, setIsCustomerTyping] = useState(false)
  const [conversationEnded, setConversationEnded] = useState(false)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const responseTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages, isCustomerTyping])

  // Start conversation when customer is selected
  const handleSelectCustomer = (customer: Customer) => {
    setSelectedCustomer(customer)
    setMode('chat')
    setMessages([])
    setConversationEnded(false)
    
    // Customer sends initial message after a short delay
    setTimeout(() => {
      const initialMessage: ChatMessage = {
        id: `msg-${Date.now()}`,
        text: customer.issueDescription,
        sender: 'customer',
        timestamp: new Date(),
        customerId: customer.id
      }
      setMessages([initialMessage])
    }, 1500)
  }

  // Return to queue
  const handleBackToQueue = () => {
    setMode('queue')
    setSelectedCustomer(null)
    setMessages([])
    setConversationEnded(false)
    if (responseTimeoutRef.current) {
      clearTimeout(responseTimeoutRef.current)
    }
  }

  // Complete conversation
  const handleCompleteConversation = () => {
    if (selectedCustomer) {
      const thankYouMessage: ChatMessage = {
        id: `msg-${Date.now()}`,
        text: generateThankYouMessage(selectedCustomer),
        sender: 'customer',
        timestamp: new Date(),
        customerId: selectedCustomer.id
      }
      setMessages(prev => [...prev, thankYouMessage])
      setConversationEnded(true)
      
      // Auto return to queue after 3 seconds
      setTimeout(() => {
        handleBackToQueue()
      }, 3000)
    }
  }

  // Generate customer response
  const generateCustomerReply = (agentMessage: string) => {
    if (!selectedCustomer || conversationEnded) return

    const context = {
      customer: selectedCustomer,
      conversation: messages,
      lastAgentMessage: agentMessage,
      conversationStage: messages.length <= 2 ? 'greeting' as const :
                        messages.length <= 4 ? 'problem_identification' as const :
                        messages.length <= 8 ? 'troubleshooting' as const :
                        messages.length <= 10 ? 'resolution' as const : 'closing' as const
    }

    // Check if customer wants to end conversation
    if (shouldCustomerEndConversation(messages, selectedCustomer)) {
      handleCompleteConversation()
      return
    }

    setIsCustomerTyping(true)
    
    const delay = getResponseDelay(selectedCustomer.personality)
    
    responseTimeoutRef.current = setTimeout(() => {
      const response = generateCustomerResponse(context)
      const customerMessage: ChatMessage = {
        id: `msg-${Date.now()}`,
        text: response,
        sender: 'customer',
        timestamp: new Date(),
        customerId: selectedCustomer.id
      }
      
      setMessages(prev => [...prev, customerMessage])
      setIsCustomerTyping(false)
    }, delay)
  }
  
  // Send agent message
  const handleSend = () => {
    if (inputText.trim() && selectedCustomer) {
      const agentMessage: ChatMessage = {
        id: `msg-${Date.now()}`,
        text: inputText.trim(),
        sender: 'agent',
        timestamp: new Date(),
        customerId: selectedCustomer.id,
        agentId: 'current-agent'
      }
      
      setMessages(prev => [...prev, agentMessage])
      const messageCopy = inputText.trim()
      setInputText('')
      
      // Generate customer response
      generateCustomerReply(messageCopy)
    }
  }
  
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSend()
    }
  }
  
  const formatTime = (date: Date) => {
    return date.toLocaleTimeString('en-US', { 
      hour: '2-digit', 
      minute: '2-digit' 
    })
  }

  // Render queue mode
  if (mode === 'queue') {
    return (
      <CustomerQueue 
        onSelectCustomer={handleSelectCustomer}
        className={className}
      />
    )
  }

  // Render chat mode
  return (
    <Card className={cn("h-full flex flex-col", className)}>
      {/* Chat Header */}
      <CardHeader className="border-b px-4 py-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <Button
              variant="ghost"
              size="icon"
              onClick={handleBackToQueue}
              className="flex-shrink-0"
            >
              <ArrowLeft className="h-4 w-4" />
            </Button>
            <Avatar className="h-9 w-9">
              <AvatarFallback>
                {selectedCustomer ? getCustomerAvatarInitials(selectedCustomer.name) : 'U'}
              </AvatarFallback>
            </Avatar>
            <div>
              <CardTitle className="text-sm">{selectedCustomer?.name}</CardTitle>
              <div className="flex items-center gap-2">
                {selectedCustomer && (
                  <>
                    <Badge className={cn("text-xs flex items-center gap-1", getPriorityColor(selectedCustomer.priority))}>
                      {getPriorityIcon(selectedCustomer.priority) === 'alert-triangle' && <AlertTriangle className="h-2.5 w-2.5" />}
                      {getPriorityIcon(selectedCustomer.priority) === 'alert-circle' && <AlertCircle className="h-2.5 w-2.5" />}
                      {getPriorityIcon(selectedCustomer.priority) === 'check-circle' && <CheckCircle className="h-2.5 w-2.5" />}
                      {selectedCustomer.priority.toUpperCase()}
                    </Badge>
                    <span className="text-xs text-muted-foreground flex items-center gap-1">
                      {getCategoryIcon(selectedCustomer.issueCategory) === 'building-2' && <Building2 className="h-3 w-3 text-blue-600" />}
                      {getCategoryIcon(selectedCustomer.issueCategory) === 'credit-card' && <CreditCard className="h-3 w-3 text-purple-600" />}
                      {getCategoryIcon(selectedCustomer.issueCategory) === 'home' && <Home className="h-3 w-3 text-orange-600" />}
                      {getCategoryIcon(selectedCustomer.issueCategory) === 'monitor' && <Monitor className="h-3 w-3 text-gray-600" />}
                      {getCategoryIcon(selectedCustomer.issueCategory) === 'help-circle' && <HelpCircle className="h-3 w-3 text-gray-500" />}
                      {selectedCustomer.issueTitle}
                    </span>
                  </>
                )}
              </div>
            </div>
          </div>
          <div className="flex items-center gap-2">
            {conversationEnded && (
              <Badge variant="secondary" className="text-xs text-green-600">
                <CheckCircle className="h-3 w-3 mr-1" />
                Completed
              </Badge>
            )}
            {!conversationEnded && (
              <Button 
                variant="outline" 
                size="sm"
                onClick={handleCompleteConversation}
                className="text-xs"
              >
                <CheckCircle className="h-3 w-3 mr-1" />
                End Chat
              </Button>
            )}
            <Button variant="ghost" size="icon">
              <MoreVertical className="h-4 w-4" />
            </Button>
          </div>
        </div>
        
        {/* Customer Details Bar */}
        {selectedCustomer && (
          <div className="mt-3 pt-3 border-t grid grid-cols-3 gap-4 text-xs">
            <div className="flex items-center gap-1 text-muted-foreground">
              <Mail className="h-3 w-3" />
              <span className="truncate">{selectedCustomer.email}</span>
            </div>
            <div className="flex items-center gap-1 text-muted-foreground">
              <Phone className="h-3 w-3" />
              <span>{selectedCustomer.phone}</span>
            </div>
            <div className="flex items-center gap-1 text-muted-foreground">
              <CreditCard className="h-3 w-3" />
              <span>***{selectedCustomer.accountNumber?.slice(-4)}</span>
            </div>
          </div>
        )}
      </CardHeader>
      
      {/* Chat Messages */}
      <CardContent className="flex-1 p-0 overflow-hidden">
        <ScrollArea className="h-full p-4">
          <div className="space-y-4">
            {messages.map((message) => (
              <div
                key={message.id}
                className={cn(
                  "flex gap-2",
                  message.sender === 'agent' ? "justify-end" : "justify-start"
                )}
              >
                {message.sender === 'customer' && selectedCustomer && (
                  <Avatar className="h-8 w-8">
                    <AvatarFallback>
                      {getCustomerAvatarInitials(selectedCustomer.name)}
                    </AvatarFallback>
                  </Avatar>
                )}
                <div
                  className={cn(
                    "max-w-[70%] rounded-lg px-3 py-2",
                    message.sender === 'agent'
                      ? "bg-primary text-primary-foreground"
                      : "bg-muted"
                  )}
                >
                  <p className="text-sm">{message.text}</p>
                  <p className={cn(
                    "text-xs mt-1",
                    message.sender === 'agent' ? "text-primary-foreground/70" : "text-muted-foreground"
                  )}>
                    {formatTime(message.timestamp)}
                  </p>
                </div>
              </div>
            ))}
            
            {/* Typing Indicator */}
            {isCustomerTyping && selectedCustomer && (
              <div className="flex gap-2 justify-start">
                <Avatar className="h-8 w-8">
                  <AvatarFallback>
                    {getCustomerAvatarInitials(selectedCustomer.name)}
                  </AvatarFallback>
                </Avatar>
                <div className="bg-muted rounded-lg px-3 py-2">
                  <div className="flex items-center gap-1">
                    <div className="flex space-x-1">
                      <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                      <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                      <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                    </div>
                  </div>
                </div>
              </div>
            )}
            
            <div ref={messagesEndRef} />
          </div>
        </ScrollArea>
      </CardContent>
      
      {/* Chat Input */}
      <div className="border-t p-3">
        {conversationEnded ? (
          <div className="text-center py-4">
            <p className="text-sm text-muted-foreground mb-2">
              Conversation completed successfully
            </p>
            <Button onClick={handleBackToQueue} variant="outline" size="sm">
              <ArrowLeft className="h-3 w-3 mr-1" />
              Back to Queue
            </Button>
          </div>
        ) : (
          <div className="flex gap-2">
            <Button variant="ghost" size="icon" className="flex-shrink-0">
              <Paperclip className="h-4 w-4" />
            </Button>
            <Input
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Type your message..."
              className="flex-1"
              disabled={isCustomerTyping}
            />
            <Button variant="ghost" size="icon" className="flex-shrink-0">
              <Smile className="h-4 w-4" />
            </Button>
            <Button 
              onClick={handleSend} 
              size="icon" 
              className="flex-shrink-0"
              disabled={!inputText.trim() || isCustomerTyping}
            >
              <Send className="h-4 w-4" />
            </Button>
          </div>
        )}
      </div>
    </Card>
  )
}
===END FILE===

===BEGIN FILE: src/components/chat/customer-queue.tsx===
import { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '../ui/card'
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { ScrollArea } from '../ui/scroll-area'
import { Avatar, AvatarFallback } from '../ui/avatar'
import { 
  Users, 
  Clock, 
  AlertTriangle, 
  MessageSquare,
  Phone,
  Mail,
  CreditCard,
  AlertCircle,
  CheckCircle,
  Building2,
  Home,
  Monitor,
  HelpCircle
} from 'lucide-react'
import { Customer, QueueMetrics } from '../../types/chat-types'
import { 
  generateInitialCustomerQueue, 
  generateMockCustomer,
  getCustomerAvatarInitials,
  getPriorityColor,
  getPriorityIcon,
  getCategoryIcon
} from '../../utils/mock-customers'
import { cn } from '../../lib/utils'

interface CustomerQueueProps {
  onSelectCustomer: (customer: Customer) => void
  className?: string
}

export function CustomerQueue({ onSelectCustomer, className }: CustomerQueueProps) {
  const [customers, setCustomers] = useState<Customer[]>([])
  const [metrics, setMetrics] = useState<QueueMetrics>({
    totalWaiting: 0,
    averageWaitTime: 0,
    highPriorityCount: 0,
    mediumPriorityCount: 0,
    lowPriorityCount: 0,
    longestWaitTime: 0
  })

  // Initialize queue on mount
  useEffect(() => {
    const initialQueue = generateInitialCustomerQueue(8)
    setCustomers(initialQueue)
  }, [])

  // Add new customers periodically
  useEffect(() => {
    const interval = setInterval(() => {
      // 30% chance to add a new customer every 30 seconds
      if (Math.random() < 0.3 && customers.length < 12) {
        const newCustomer = generateMockCustomer()
        setCustomers(prev => {
          const updated = [...prev, newCustomer]
          // Sort by priority and wait time
          return updated.sort((a, b) => {
            const priorityOrder = { high: 3, medium: 2, low: 1 }
            if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
              return priorityOrder[b.priority] - priorityOrder[a.priority]
            }
            return b.waitTime - a.waitTime
          })
        })
      }
    }, 30000) // Every 30 seconds

    return () => clearInterval(interval)
  }, [customers.length])

  // Update wait times every minute
  useEffect(() => {
    const interval = setInterval(() => {
      setCustomers(prev => 
        prev.map(customer => ({
          ...customer,
          waitTime: customer.waitTime + 1
        }))
      )
    }, 60000) // Every minute

    return () => clearInterval(interval)
  }, [])

  // Calculate metrics whenever customers change
  useEffect(() => {
    const totalWaiting = customers.filter(c => c.status === 'waiting').length
    const waitingCustomers = customers.filter(c => c.status === 'waiting')
    const averageWaitTime = waitingCustomers.length > 0 
      ? Math.round(waitingCustomers.reduce((sum, c) => sum + c.waitTime, 0) / waitingCustomers.length)
      : 0
    const highPriorityCount = customers.filter(c => c.priority === 'high' && c.status === 'waiting').length
    const mediumPriorityCount = customers.filter(c => c.priority === 'medium' && c.status === 'waiting').length
    const lowPriorityCount = customers.filter(c => c.priority === 'low' && c.status === 'waiting').length
    const longestWaitTime = waitingCustomers.length > 0 
      ? Math.max(...waitingCustomers.map(c => c.waitTime))
      : 0

    setMetrics({
      totalWaiting,
      averageWaitTime,
      highPriorityCount,
      mediumPriorityCount,
      lowPriorityCount,
      longestWaitTime
    })
  }, [customers])

  const handleSelectCustomer = (customer: Customer) => {
    // Mark customer as in progress
    setCustomers(prev =>
      prev.map(c =>
        c.id === customer.id
          ? { ...c, status: 'in_progress' as const, assignedAgentId: 'current-agent' }
          : c
      )
    )
    
    onSelectCustomer(customer)
  }

  const formatWaitTime = (minutes: number) => {
    if (minutes < 60) {
      return `${minutes}m`
    }
    const hours = Math.floor(minutes / 60)
    const remainingMinutes = minutes % 60
    return `${hours}h ${remainingMinutes}m`
  }

  const waitingCustomers = customers.filter(c => c.status === 'waiting')

  return (
    <Card className={cn("h-full flex flex-col", className)}>
      {/* Queue Header */}
      <CardHeader className="border-b px-4 py-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Users className="h-5 w-5 text-primary" />
            <CardTitle className="text-lg">Customer Queue</CardTitle>
          </div>
          <Badge variant="secondary" className="text-sm">
            {metrics.totalWaiting} waiting
          </Badge>
        </div>
      </CardHeader>

      {/* Queue Metrics */}
      <div className="px-4 py-3 border-b bg-muted/30">
        <div className="grid grid-cols-2 lg:grid-cols-4 gap-3">
          <div className="text-center">
            <div className="text-lg font-semibold text-primary">{formatWaitTime(metrics.averageWaitTime)}</div>
            <div className="text-xs text-muted-foreground">Avg Wait</div>
          </div>
          <div className="text-center">
            <div className="text-lg font-semibold text-red-600">{metrics.highPriorityCount}</div>
            <div className="text-xs text-muted-foreground">High Priority</div>
          </div>
          <div className="text-center">
            <div className="text-lg font-semibold text-yellow-600">{metrics.mediumPriorityCount}</div>
            <div className="text-xs text-muted-foreground">Medium Priority</div>
          </div>
          <div className="text-center">
            <div className="text-lg font-semibold text-green-600">{metrics.lowPriorityCount}</div>
            <div className="text-xs text-muted-foreground">Low Priority</div>
          </div>
        </div>
      </div>

      {/* Customer List */}
      <CardContent className="flex-1 p-0 overflow-hidden">
        <ScrollArea className="h-full">
          {waitingCustomers.length === 0 ? (
            <div className="h-full flex flex-col items-center justify-center p-8 text-center">
              <Users className="h-12 w-12 text-muted-foreground mb-4" />
              <h3 className="text-lg font-medium text-muted-foreground mb-2">
                No customers waiting
              </h3>
              <p className="text-sm text-muted-foreground">
                New customers will appear here when they need assistance
              </p>
            </div>
          ) : (
            <div className="p-4 space-y-3">
              {waitingCustomers.map((customer) => (
                <Card 
                  key={customer.id} 
                  className="cursor-pointer hover:shadow-md transition-shadow border-l-4 border-l-transparent hover:border-l-primary"
                  onClick={() => handleSelectCustomer(customer)}
                >
                  <CardContent className="p-4">
                    <div className="flex items-start gap-3">
                      {/* Customer Avatar */}
                      <Avatar className="h-10 w-10 flex-shrink-0">
                        <AvatarFallback className="text-sm font-medium">
                          {getCustomerAvatarInitials(customer.name)}
                        </AvatarFallback>
                      </Avatar>

                      {/* Customer Info */}
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center justify-between mb-2">
                          <h4 className="font-medium text-sm truncate">{customer.name}</h4>
                          <div className="flex items-center gap-1">
                            {getPriorityIcon(customer.priority) === 'alert-triangle' && <AlertTriangle className="h-3 w-3 text-red-500" />}
                            {getPriorityIcon(customer.priority) === 'alert-circle' && <AlertCircle className="h-3 w-3 text-yellow-500" />}
                            {getPriorityIcon(customer.priority) === 'check-circle' && <CheckCircle className="h-3 w-3 text-green-500" />}
                            <Badge className={cn("text-xs", getPriorityColor(customer.priority))}>
                              {customer.priority.toUpperCase()}
                            </Badge>
                          </div>
                        </div>

                        {/* Issue Info */}
                        <div className="flex items-center gap-2 mb-2">
                          <div className="flex-shrink-0">
                            {getCategoryIcon(customer.issueCategory) === 'building-2' && <Building2 className="h-3.5 w-3.5 text-blue-600" />}
                            {getCategoryIcon(customer.issueCategory) === 'credit-card' && <CreditCard className="h-3.5 w-3.5 text-purple-600" />}
                            {getCategoryIcon(customer.issueCategory) === 'home' && <Home className="h-3.5 w-3.5 text-orange-600" />}
                            {getCategoryIcon(customer.issueCategory) === 'monitor' && <Monitor className="h-3.5 w-3.5 text-gray-600" />}
                            {getCategoryIcon(customer.issueCategory) === 'help-circle' && <HelpCircle className="h-3.5 w-3.5 text-gray-500" />}
                          </div>
                          <span className="text-sm font-medium truncate">{customer.issueTitle}</span>
                        </div>

                        <p className="text-xs text-muted-foreground line-clamp-2 mb-3">
                          {customer.issueDescription}
                        </p>

                        {/* Customer Details */}
                        <div className="grid grid-cols-2 gap-2 text-xs text-muted-foreground mb-3">
                          <div className="flex items-center gap-1">
                            <Mail className="h-3 w-3" />
                            <span className="truncate">{customer.email}</span>
                          </div>
                          <div className="flex items-center gap-1">
                            <Phone className="h-3 w-3" />
                            <span>{customer.phone}</span>
                          </div>
                          <div className="flex items-center gap-1">
                            <CreditCard className="h-3 w-3" />
                            <span>***{customer.accountNumber?.slice(-4)}</span>
                          </div>
                          <div className="flex items-center gap-1">
                            <Clock className="h-3 w-3" />
                            <span>Est. {customer.estimatedResolutionTime}min</span>
                          </div>
                        </div>

                        {/* Wait Time */}
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-1">
                            <Clock className="h-4 w-4 text-orange-500" />
                            <span className="text-sm font-medium text-orange-600">
                              Waiting {formatWaitTime(customer.waitTime)}
                            </span>
                          </div>
                          <Button size="sm" className="text-xs">
                            <MessageSquare className="h-3 w-3 mr-1" />
                            Start Chat
                          </Button>
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </ScrollArea>
      </CardContent>

      {/* Quick Actions Footer */}
      <div className="border-t p-3 bg-muted/30">
        <div className="text-xs text-muted-foreground text-center">
          {metrics.longestWaitTime > 0 && (
            <>
              <AlertTriangle className="h-3 w-3 inline mr-1 text-orange-500" />
              Longest wait: {formatWaitTime(metrics.longestWaitTime)}
            </>
          )}
        </div>
      </div>
    </Card>
  )
}
===END FILE===

===BEGIN FILE: src/components/chat/response-templates.tsx===
import { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '../ui/card'
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { Input } from '../ui/input'
import { ScrollArea } from '../ui/scroll-area'
import { 
  MessageSquare, 
  Search, 
  Copy, 
  Star,
  Zap
} from 'lucide-react'
import { cn } from '../../lib/utils'

interface Template {
  id: string
  title: string
  content: string
  category: 'greeting' | 'account' | 'technical' | 'closing' | 'common'
  usage: number
  favorite: boolean
}

// ✅ EXTERNALIZED: Response templates moved to /public/config/response-templates.json

async function loadResponseTemplates(): Promise<Template[]> {
  try {
    const response = await fetch('/config/response-templates.json')
    if (!response.ok) {
      throw new Error(`Failed to load response templates: ${response.status}`)
    }
    const data = await response.json()
    return data.templates
  } catch (error) {
    // Failed to load response templates, using fallback
    return [
      {
        id: '1',
        title: 'Welcome',
        content: 'Hello! How can I help you today?',
        category: 'greeting',
        usage: 0,
        favorite: false
      }
    ]
  }
}

export function ResponseTemplates({ className, onTemplateSelect }: { 
  className?: string
  onTemplateSelect?: (template: Template) => void 
}) {
  const [templates, setTemplates] = useState<Template[]>([])
  const [searchTerm, setSearchTerm] = useState('')
  const [selectedCategory, setSelectedCategory] = useState<string>('all')
  const [loading, setLoading] = useState(true)

  // Load templates from config on component mount
  useEffect(() => {
    loadResponseTemplates().then(loadedTemplates => {
      setTemplates(loadedTemplates)
      setLoading(false)
    })
  }, [])
  
  const categories = [
    { id: 'all', label: 'All', count: templates.length },
    { id: 'greeting', label: 'Greeting', count: templates.filter(t => t.category === 'greeting').length },
    { id: 'account', label: 'Account', count: templates.filter(t => t.category === 'account').length },
    { id: 'technical', label: 'Technical', count: templates.filter(t => t.category === 'technical').length },
    { id: 'closing', label: 'Closing', count: templates.filter(t => t.category === 'closing').length }
  ]
  
  const filteredTemplates = templates.filter(template => {
    const matchesSearch = template.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         template.content.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesCategory = selectedCategory === 'all' || template.category === selectedCategory
    return matchesSearch && matchesCategory
  })
  
  const getCategoryColor = (category: string) => {
    switch (category) {
      case 'greeting': return 'bg-green-100 text-green-800'
      case 'account': return 'bg-blue-100 text-blue-800'
      case 'technical': return 'bg-orange-100 text-orange-800'
      case 'closing': return 'bg-purple-100 text-purple-800'
      default: return 'bg-gray-100 text-gray-800'
    }
  }
  
  const handleTemplateClick = (template: Template) => {
    if (onTemplateSelect) {
      onTemplateSelect(template)
    }
    // Copy to clipboard as fallback
    navigator.clipboard.writeText(template.content)
  }
  
  return (
    <Card className={cn("h-full flex flex-col", className)}>
      <CardHeader className="border-b pb-3">
        <CardTitle className="flex items-center gap-2 text-sm">
          <MessageSquare className="h-4 w-4" />
          Quick Responses
        </CardTitle>
        
        {/* Search */}
        <div className="relative">
          <Search className="absolute left-2 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search templates..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-8 h-8 text-xs"
          />
        </div>
        
        {/* Category Filter */}
        <div className="flex flex-wrap gap-1">
          {categories.map((category) => (
            <Button
              key={category.id}
              variant={selectedCategory === category.id ? "default" : "outline"}
              size="sm"
              className="h-6 text-xs px-2"
              onClick={() => setSelectedCategory(category.id)}
            >
              {category.label}
              <Badge variant="secondary" className="ml-1 text-[10px] px-1">
                {category.count}
              </Badge>
            </Button>
          ))}
        </div>
      </CardHeader>
      
      <CardContent className="flex-1 p-0 overflow-hidden">
        <ScrollArea className="h-full">
          <div className="p-3 space-y-2">
            {filteredTemplates.map((template) => (
              <Card
                key={template.id}
                className="p-2 cursor-pointer hover:bg-red-50 hover:border-red-200 transition-colors border"
                onClick={() => handleTemplateClick(template)}
              >
                <div className="flex items-start justify-between mb-1">
                  <div className="flex items-center gap-2">
                    <h4 className="text-xs font-medium">{template.title}</h4>
                    {template.favorite && (
                      <Star className="h-3 w-3 text-yellow-500 fill-current" />
                    )}
                  </div>
                  <div className="flex items-center gap-1">
                    <Badge variant="secondary" className={cn("text-[10px]", getCategoryColor(template.category))}>
                      {template.category}
                    </Badge>
                  </div>
                </div>
                
                <p className="text-xs text-muted-foreground line-clamp-2 mb-2">
                  {template.content}
                </p>
                
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2 text-xs text-muted-foreground">
                    <Zap className="h-3 w-3" />
                    <span>Used {template.usage} times</span>
                  </div>
                  <Button variant="ghost" size="sm" className="h-5 w-5 p-0">
                    <Copy className="h-3 w-3" />
                  </Button>
                </div>
              </Card>
            ))}
            
            {filteredTemplates.length === 0 && (
              <div className="text-center py-8 text-muted-foreground">
                <MessageSquare className="h-8 w-8 mx-auto mb-2 opacity-50" />
                <p className="text-sm">No templates found</p>
                <p className="text-xs">Try adjusting your search or category filter</p>
              </div>
            )}
          </div>
        </ScrollArea>
      </CardContent>
    </Card>
  )
}
===END FILE===

===BEGIN FILE: src/components/columns/collapsed-column-indicator.tsx===
import { Button } from '../ui/button'
import { ChevronRight, ChevronLeft, Maximize2 } from 'lucide-react'
import { cn } from '../../lib/utils'
import { 
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '../ui/tooltip'

interface CollapsedColumnIndicatorProps {
  title: string
  columnId: 'customer' | 'embedded' | 'spaceCopilot' | 'kms'
  position: 'left' | 'right'
  onExpand: () => void
  canManageColumns: boolean
}

export function CollapsedColumnIndicator({
  title,
  columnId,
  position,
  onExpand,
  canManageColumns
}: CollapsedColumnIndicatorProps) {
  if (!canManageColumns) return null

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <div className={cn(
            "flex flex-col items-center justify-center",
            "w-8 bg-muted/50 border-r border-l hover:bg-muted/80 transition-colors cursor-pointer",
            "h-full group"
          )}>
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8 p-0 icon-button-red-hover"
              onClick={onExpand}
            >
              {/* Use maximize icon for all collapsed columns */}
              <Maximize2 className="h-3 w-3" />
            </Button>
            
            {/* Vertical text */}
            <div className={cn(
              "writing-mode-vertical-lr text-orientation-mixed",
              "text-xs text-muted-foreground mt-2 group-hover:text-foreground transition-colors"
            )} style={{
              writingMode: 'vertical-lr',
              textOrientation: 'mixed'
            }}>
              {title}
            </div>
          </div>
        </TooltipTrigger>
        <TooltipContent>
          <p>Expand {title}</p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  )
}
===END FILE===

===BEGIN FILE: src/components/columns/column-header.tsx===
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { 
  ChevronLeft, 
  ChevronRight, 
  Minimize2, 
  Maximize2, 
  RotateCcw,
  MoreVertical,
  Sparkles 
} from 'lucide-react'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '../ui/dropdown-menu'
import { cn } from '../../lib/utils'
import type { ColumnState } from '../../hooks/use-column-layout'

interface ColumnHeaderProps {
  title: string
  columnId: 'customer' | 'embedded' | 'spaceCopilot' | 'kms'
  currentState: ColumnState
  canManageColumns: boolean
  onStateChange: (state: ColumnState) => void
  onResetAll?: () => void
  className?: string
  showBorder?: boolean
  showAIBadge?: boolean
}

export function ColumnHeader({
  title,
  columnId,
  currentState,
  canManageColumns,
  onStateChange,
  onResetAll,
  className,
  showBorder = true,
  showAIBadge = false
}: ColumnHeaderProps) {
  if (!canManageColumns) {
    // Simple header without controls for restricted roles
    return (
      <div className={cn(
        "flex items-center justify-between h-12 px-4 bg-muted/30",
        showBorder && "border-b",
        className
      )}>
        <div className="flex items-center gap-2">
          {showAIBadge && <Sparkles className="h-4 w-4 text-red-600" />}
          <h2 className="text-sm font-medium truncate">{title}</h2>
          {showAIBadge && (
            <Badge variant="secondary" className="text-xs bg-red-50 text-red-600 border-red-200">
              AI
            </Badge>
          )}
        </div>
      </div>
    )
  }

  const isCollapsed = currentState === 'collapsed'
  const isMaximized = currentState === 'maximized'
  const isNormal = currentState === 'normal'

  return (
    <div className={cn(
      "flex items-center justify-between h-12 px-2 bg-muted/30 transition-all duration-200",
      showBorder && "border-b",
      isCollapsed && "px-1",
      className
    )}>
      {/* Title - hidden when collapsed */}
      {!isCollapsed && (
        <div className="flex items-center gap-2 px-2">
          {showAIBadge && <Sparkles className="h-4 w-4 text-red-600" />}
          <h2 className="text-sm font-medium truncate">{title}</h2>
          {showAIBadge && (
            <Badge variant="secondary" className="text-xs bg-red-50 text-red-600 border-red-200">
              AI
            </Badge>
          )}
        </div>
      )}
      
      {/* Controls */}
      <div className="flex items-center gap-1">
        {/* Collapse/Expand toggle */}
        <Button
          variant="ghost"
          size="icon"
          className={cn(
            "h-8 w-8 icon-button-red-hover",
            isCollapsed && "h-6 w-6"
          )}
          onClick={() => {
            const newState = isCollapsed ? 'normal' : 'collapsed'
            onStateChange(newState)
          }}
          title={isCollapsed ? `Expand ${title}` : `Collapse ${title}`}
        >
          {/* Use intuitive icons that don't depend on direction:
              - Expanded: Show minimize icon (collapse)
              - Collapsed: Show maximize icon (expand) */}
          {isCollapsed ? (
            // Show maximize icon when collapsed
            <Maximize2 className="h-3 w-3" />
          ) : (
            // Show minimize icon when expanded
            <Minimize2 className="h-3 w-3" />
          )}
        </Button>

        {/* More options - only show when not collapsed */}
        {!isCollapsed && (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8 icon-button-red-hover"
              >
                <MoreVertical className="h-3 w-3" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-40">
              {!isMaximized && (
                <DropdownMenuItem
                  onClick={() => onStateChange('maximized')}
                  className="text-xs"
                >
                  <Maximize2 className="mr-2 h-3 w-3" />
                  Maximize
                </DropdownMenuItem>
              )}
              
              {isMaximized && (
                <DropdownMenuItem
                  onClick={() => onStateChange('normal')}
                  className="text-xs"
                >
                  <Minimize2 className="mr-2 h-3 w-3" />
                  Restore
                </DropdownMenuItem>
              )}
              
              {!isNormal && (
                <DropdownMenuItem
                  onClick={() => onStateChange('normal')}
                  className="text-xs"
                >
                  <RotateCcw className="mr-2 h-3 w-3" />
                  Reset Size
                </DropdownMenuItem>
              )}
              
              {onResetAll && (
                <>
                  <DropdownMenuItem
                    onClick={onResetAll}
                    className="text-xs border-t mt-1 pt-1"
                  >
                    <RotateCcw className="mr-2 h-3 w-3" />
                    Reset All Columns
                  </DropdownMenuItem>
                </>
              )}
            </DropdownMenuContent>
          </DropdownMenu>
        )}
      </div>
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/components/columns/customer-column.tsx===
import { Badge } from '../ui/badge'
import { Alert, AlertDescription } from '../ui/alert'
import { Button } from '../ui/button'
import { ScrollArea } from '../ui/scroll-area'
import { Separator } from '../ui/separator'
import { Card, CardContent, CardHeader, CardTitle } from '../ui/card'
import { Panel, PanelGroup } from 'react-resizable-panels'
import { ResizableHandle } from '../layout/resizable-widget-container'
import { useWidgetLayout } from '../../hooks/use-widget-layout'
import { 
  AlertTriangle, 
  Phone, 
  Mail, 
  MapPin,
  User,
  Hash,
  ChevronDown,
  ChevronUp,
  MessageSquare,
  RotateCcw,
  CheckCircle,
  AlertCircle,
  Building2,
  Video,
  MessageCircle,
  Smartphone,
  Globe
} from 'lucide-react'
import { useCustomerColumnData } from '../../stores/selectors/agent-selectors'
import { useState } from 'react'
import { cn } from '../../lib/utils'

// Icon mapping for 8 standardized channel types
const getChannelIcon = (channel: string) => {
  switch (channel) {
    case 'phone':
      return Phone
    case 'email':
      return Mail
    case 'mobile':
      return Smartphone
    case 'branch':
      return Building2
    case 'video':
      return Video
    case 'web':
      return Globe
    case 'social':
      return MessageCircle
    case 'chat':
      return MessageSquare
    default:
      return MessageSquare // Default fallback
  }
}

export function CustomerColumn() {
  const { customer, connectionStatus } = useCustomerColumnData()
  const [expandedInteractions, setExpandedInteractions] = useState<Set<string>>(new Set())
  
  // Widget layout hooks
  const customerInfoLayout = useWidgetLayout({
    column: 'customer',
    widgetId: 'customer-info',
    defaultSize: 40,
    minSize: 30,
    maxSize: 60
  })
  
  const interactionLayout = useWidgetLayout({
    column: 'customer',
    widgetId: 'interaction-history',
    defaultSize: 60,
    minSize: 40,
    maxSize: 70
  })
  
  // Map customer interactions to UI format
  const interactions = (customer?.interactionHistory || []).map((interaction: any, index: number) => ({
    id: `interaction-${index}`,
    channel: interaction.channel || 'phone',
    subject: interaction.subject || 'Customer Interaction',
    date: interaction.interaction_date || interaction.date || new Date().toISOString(),
    status: interaction.status || 'resolved',
    details: interaction.description || interaction.interaction_context || '',
    sentiment: interaction.sentiment || 'neutral',
    outcome: interaction.interaction_outcome || interaction.status,
    responseTime: interaction.response_time_minutes,
    priority: interaction.priority_level || 'medium',
    tags: interaction.tags || []
  }))
  
  const toggleInteraction = (id: string) => {
    setExpandedInteractions(prev => {
      const next = new Set(prev)
      if (next.has(id)) {
        next.delete(id)
      } else {
        next.add(id)
      }
      return next
    })
  }
  
  return (
    <PanelGroup direction="vertical" className="h-full w-full customer-column">
      {/* Customer Info Panel */}
      <Panel 
        defaultSize={customerInfoLayout.size}
        minSize={customerInfoLayout.minSize}
        maxSize={customerInfoLayout.maxSize}
        onResize={customerInfoLayout.handleResize}
      >
        <div className="bg-white h-full">
          <ScrollArea className="h-full w-full">
            <div className="p-4 space-y-4">
              {/* Customer Header - Show watermark when no customer data */}
              {customer ? (
                <>
                  {/* Professional Header */}
                  <div className="mb-4 border-l-4 border-gray-800 pl-4">
                    <div className="flex items-center justify-between">
                      <div>
                        <h1 className="text-lg font-semibold text-gray-900">{customer.name}</h1>
                        <p className="text-xs text-gray-600 mt-1">
                          {customer.tier || customer.accountType || 'Standard'} • CIN: {(customer.cin || customer.id).replace('CIN-', '')}
                        </p>
                      </div>
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-6 w-6"
                        onClick={customerInfoLayout.resetSize}
                        title="Reset to default size"
                      >
                        <RotateCcw className="h-3 w-3" />
                      </Button>
                    </div>
                  </div>

                  {/* Customer Information Card */}
                  <Card className="border-gray-200">
                    <CardHeader className="pb-3 bg-gray-50">
                      <CardTitle className="text-sm flex items-center gap-2">
                        <User className="h-4 w-4" />
                        Customer Information
                      </CardTitle>
                    </CardHeader>
                    <CardContent className="pt-4 space-y-3">
                      {/* Verification Status */}
                      <div className="flex items-center justify-between p-2 bg-gray-50 rounded">
                        <div className="flex items-center gap-2">
                          {customer.verificationStatus === 'verified' ? (
                            <CheckCircle className="h-3 w-3 text-green-600" />
                          ) : (
                            <AlertCircle className="h-3 w-3 text-yellow-600" />
                          )}
                          <span className="text-xs font-medium">Verification</span>
                        </div>
                        <Badge className={`text-xs ${
                          customer.verificationStatus === 'verified' 
                            ? 'bg-green-100 text-green-800 border-green-200' 
                            : 'bg-yellow-100 text-yellow-800 border-yellow-200'
                        }`} variant="outline">
                          {customer.verificationStatus === 'verified' ? 'Verified' : 'Pending'}
                        </Badge>
                      </div>

                      {/* CCAAS Details */}
                      <div className="space-y-2">
                        <div className="flex items-center justify-between p-2 border rounded text-xs">
                          <div className="flex items-center gap-2">
                            <Phone className="h-3 w-3 text-gray-600" />
                            <span className="text-gray-600">Phone</span>
                          </div>
                          <span className="font-medium">{customer.phone}</span>
                        </div>
                        
                        <div className="flex items-center justify-between p-2 border rounded text-xs">
                          <div className="flex items-center gap-2">
                            <Mail className="h-3 w-3 text-gray-600" />
                            <span className="text-gray-600">Email</span>
                          </div>
                          <span className="font-medium text-right">{customer.email}</span>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-2">
                          <div className="p-2 border rounded text-xs">
                            <div className="flex items-center gap-1 mb-1">
                              <MapPin className="h-3 w-3 text-gray-600" />
                              <span className="text-gray-600">Location</span>
                            </div>
                            <span className="font-medium text-xs">{customer.location}</span>
                          </div>
                          
                          <div className="p-2 border rounded text-xs">
                            <div className="flex items-center gap-1 mb-1">
                              <Hash className="h-3 w-3 text-gray-600" />
                              <span className="text-gray-600">Tier</span>
                            </div>
                            <span className="font-medium text-xs">{customer.tier || customer.accountType}</span>
                          </div>
                        </div>
                      </div>

                      {/* Care Need Alert - only show if customer has risk */}
                      {customer.riskLevel && customer.riskLevel !== 'low' && (
                        <div className={`p-2 rounded border-2 ${
                          customer.riskLevel === 'high' ? 'bg-red-50 border-red-200' : 'bg-orange-50 border-orange-200'
                        }`}>
                          <div className="flex items-center gap-2">
                            <AlertTriangle className={`h-3 w-3 ${
                              customer.riskLevel === 'high' ? 'text-red-600' : 'text-orange-600'
                            }`} />
                            <span className="text-xs font-medium">
                              {customer.riskLevel === 'high' ? 'Care Need' : 'Monitor Required'}
                            </span>
                          </div>
                        </div>
                      )}
                    </CardContent>
                  </Card>
                </>
              ) : (
                /* Empty state watermark */
                <div className="flex items-center justify-center h-full min-h-[200px]">
                  <div className="text-center space-y-2">
                    <div className="text-muted-foreground">
                      <User className="h-8 w-8 mx-auto mb-2 opacity-50" />
                      <p className="text-sm font-medium">Customer Information</p>
                      <p className="text-xs opacity-75">Customer details will appear when call begins</p>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </ScrollArea>
        </div>
      </Panel>
      
      {/* Resize Handle */}
      <ResizableHandle direction="vertical" />
      
      {/* Interactions Panel */}
      <Panel 
        defaultSize={interactionLayout.size}
        minSize={interactionLayout.minSize}
        maxSize={interactionLayout.maxSize}
        onResize={interactionLayout.handleResize}
      >
        <div className="bg-white h-full">
          <ScrollArea className="h-full w-full">
            <div className="p-4 space-y-4">
              {/* Professional Header */}
              <div className="mb-4 border-l-4 border-gray-800 pl-4">
                <div className="flex items-center justify-between">
                  <div>
                    <h1 className="text-lg font-semibold text-gray-900">Interaction History</h1>
                    <p className="text-xs text-gray-600 mt-1">
                      {interactions.length} total interactions • Recent activity
                    </p>
                  </div>
                  <div className="flex items-center gap-2">
                    <Badge variant="outline" className="text-xs">
                      {interactions.length}
                    </Badge>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="h-6 w-6"
                      onClick={interactionLayout.resetSize}
                      title="Reset to default size"
                    >
                      <RotateCcw className="h-3 w-3" />
                    </Button>
                  </div>
                </div>
              </div>
              
              {/* Interactions List */}
              {interactions.length > 0 ? (
                <div className="space-y-3">
                  {interactions.map((interaction) => {
                    const Icon = getChannelIcon(interaction.channel)
                    const isExpanded = expandedInteractions.has(interaction.id)
                    
                    return (
                      <Card key={interaction.id} className="border-gray-200 overflow-hidden">
                        <CardContent className="p-0">
                          <div className="p-3">
                            <button
                              onClick={() => toggleInteraction(interaction.id)}
                              className="w-full text-left"
                            >
                              <div className="flex items-start gap-3">
                                <div className={`mt-1 p-2 rounded-full ${
                                  interaction.sentiment === 'positive' || interaction.sentiment === 'delighted' ? 'bg-green-100' :
                                  interaction.sentiment === 'negative' || interaction.sentiment === 'frustrated' ? 'bg-red-100' :
                                  interaction.sentiment === 'urgent' ? 'bg-orange-100' :
                                  'bg-gray-100'
                                }`}>
                                  <Icon className={`h-3 w-3 ${
                                    interaction.sentiment === 'positive' || interaction.sentiment === 'delighted' ? 'text-green-600' :
                                    interaction.sentiment === 'negative' || interaction.sentiment === 'frustrated' ? 'text-red-600' :
                                    interaction.sentiment === 'urgent' ? 'text-orange-600' :
                                    'text-gray-600'
                                  }`} />
                                </div>
                                
                                <div className="flex-1 min-w-0">
                                  <div className="flex items-start justify-between gap-2">
                                    <div className="flex-1">
                                      <p className="text-sm font-semibold text-gray-900">
                                        {interaction.subject}
                                      </p>
                                      <div className="flex items-center gap-2 mt-1 flex-wrap">
                                        <p className="text-xs text-gray-600">
                                          {new Date(interaction.date).toLocaleDateString()}
                                        </p>
                                        <Badge className={`text-xs ${
                                          interaction.status === 'resolved' ? 'bg-green-100 text-green-800 border-green-200' :
                                          interaction.status === 'pending' ? 'bg-yellow-100 text-yellow-800 border-yellow-200' :
                                          interaction.status === 'escalated' ? 'bg-red-100 text-red-800 border-red-200' :
                                          interaction.status === 'Current conversation' ? 'bg-blue-100 text-blue-800 border-blue-200' :
                                          'bg-gray-100 text-gray-800 border-gray-200'
                                        }`} variant="outline">
                                          {interaction.status === 'Current conversation' ? 'Current' : interaction.status}
                                        </Badge>
                                        {interaction.priority === 'urgent' && (
                                          <Badge className="text-xs bg-red-100 text-red-700 border-red-200" variant="outline">
                                            Urgent
                                          </Badge>
                                        )}
                                      </div>
                                    </div>
                                    
                                    <div className="mt-0.5">
                                      {interaction.details && (
                                        isExpanded ? (
                                          <ChevronUp className="h-4 w-4 text-gray-400" />
                                        ) : (
                                          <ChevronDown className="h-4 w-4 text-gray-400" />
                                        )
                                      )}
                                    </div>
                                  </div>
                                  
                                  {isExpanded && interaction.details && (
                                    <div className="mt-3 space-y-2">
                                      <div className="p-3 bg-gray-50 rounded">
                                        <p className="text-xs text-gray-700 leading-relaxed">
                                          {interaction.details}
                                        </p>
                                      </div>
                                      {interaction.responseTime && (
                                        <div className="flex items-center gap-4 text-xs text-gray-600">
                                          <span>Response time: {interaction.responseTime} min</span>
                                          {interaction.outcome && (
                                            <span>Outcome: {interaction.outcome}</span>
                                          )}
                                        </div>
                                      )}
                                      {interaction.tags && interaction.tags.length > 0 && (
                                        <div className="flex flex-wrap gap-1">
                                          {interaction.tags.map((tag: string, idx: number) => (
                                            <span key={idx} className="text-xs px-2 py-1 bg-gray-100 text-gray-600 rounded">
                                              {tag}
                                            </span>
                                          ))}
                                        </div>
                                      )}
                                    </div>
                                  )}
                                </div>
                              </div>
                            </button>
                          </div>
                        </CardContent>
                      </Card>
                    )
                  })}
                </div>
              ) : (
                /* Empty state watermark for interactions */
                <div className="flex items-center justify-center h-full min-h-[150px]">
                  <div className="text-center space-y-2">
                    <div className="text-muted-foreground">
                      <MessageSquare className="h-8 w-8 mx-auto mb-2 opacity-50" />
                      <p className="text-sm font-medium">Interaction History</p>
                      <p className="text-xs opacity-75">Customer interactions will appear here</p>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </ScrollArea>
        </div>
      </Panel>
    </PanelGroup>
  )
}
===END FILE===

===BEGIN FILE: src/components/columns/embedded-app-column.tsx===
import { useState, useEffect, useRef, useCallback, memo } from 'react'
import { Skeleton } from '../ui/skeleton'
import { Alert, AlertDescription } from '../ui/alert'
import { Button } from '../ui/button'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../ui/tabs'
import { AlertCircle, RefreshCw, Monitor, X } from 'lucide-react'
import { 
  useCustomerData, 
  useCallerId, 
  useAgentId, 
  useWebSocketIntent,
  useEmbeddedAppIntent,
  useAvailableIntents
} from '../../stores/selectors/embedded-app-selectors'
import { useIframeHealthMonitor } from '../../hooks/use-iframe-health-monitor'
import { useWebSocket } from '../../contexts/websocket-context'
import { buildAppUrl, CustomerContext } from '../../services/url-builder.service'
import { useRoleConfig } from '../../contexts/role-context'
import { traceLog } from '../../utils/debug'

// ✅ FIXED: Embedded app URL and allowed origins now configurable via environment variables
const EMBEDDED_APP_URL = import.meta.env.VITE_EMBEDDED_APP_URL || 'http://localhost:5175'
const ALLOWED_ORIGINS = import.meta.env.VITE_ALLOWED_ORIGINS 
  ? import.meta.env.VITE_ALLOWED_ORIGINS.split(',').map(origin => origin.trim())
  : [
      'http://localhost:5173',
      'http://localhost:5174', 
      'http://localhost:5175',
      'http://localhost:5176',
      'http://localhost:5177',
      'http://localhost:5178',
      'https://embedded.hsbc.com'
    ]


interface EmbeddedAppTab {
  id: string
  intent: string
  label: string
  url: string
  isLoading: boolean
  error: string | null
  handshakeComplete: boolean
  appKey?: string // For launched apps from search
  context?: any // Additional context for the app
}

// Memoized iframe component to prevent unnecessary re-renders
const IframeTab = memo(({ 
  tab, 
  isActive, 
  onLoad, 
  onRetry,
  iframeRef 
}: { 
  tab: EmbeddedAppTab
  isActive: boolean
  onLoad: () => void
  onRetry: () => void
  iframeRef: (el: HTMLIFrameElement | null) => void
}) => {
  return (
    <div className={`absolute inset-0 ${isActive ? 'z-10 opacity-100' : 'z-0 opacity-0 pointer-events-none'}`}>
      {tab.isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-background/50 z-10">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
        </div>
      )}
      
      {tab.error && (
        <div className="absolute inset-0 flex items-center justify-center bg-background z-10 p-4">
          <Alert className="max-w-md">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              {tab.error}
              <Button 
                onClick={onRetry} 
                variant="outline" 
                size="sm" 
                className="mt-2 w-full"
              >
                <RefreshCw className="h-3 w-3 mr-2" />
                Retry Connection
              </Button>
            </AlertDescription>
          </Alert>
        </div>
      )}
      
      <iframe
        ref={iframeRef}
        src={tab.url}
        className="w-full h-full border-0"
        title={`HSBC ${tab.label}`}
        sandbox="allow-same-origin allow-scripts allow-popups allow-forms"
        allow="clipboard-write"
        onLoad={onLoad}
        onError={() => onRetry()}
      />
    </div>
  )
})

IframeTab.displayName = 'IframeTab'

export function EmbeddedAppColumn() {
  const [tabs, setTabs] = useState<EmbeddedAppTab[]>([])
  const [activeTabId, setActiveTabId] = useState<string | null>(null)
  const [iframeHeight, setIframeHeight] = useState('800px')
  const [closedIntents, setClosedIntents] = useState<Set<string>>(new Set())
  const iframeRefs = useRef<{ [key: string]: HTMLIFrameElement | null }>({})
  // Use granular selectors to prevent unnecessary re-renders
  const customer = useCustomerData()
  const callerId = useCallerId()
  const agentId = useAgentId()
  const embeddedAppIntent = useEmbeddedAppIntent()
  const availableIntents = useAvailableIntents()
  const { isConnected } = useWebSocket()
  const { currentRole } = useRoleConfig()
  const handshakeTimeoutRefs = useRef<{ [key: string]: NodeJS.Timeout | null }>({})
  const embeddedAppIntentRef = useRef(embeddedAppIntent)
  const closedIntentsRef = useRef(closedIntents)
  const tabsRef = useRef(tabs)
  
  // Get WebSocket enriched intent data with appUrl and appTitle
  const websocketIntent = useWebSocketIntent()
  
  
  // Helper to get intent display name
  const getIntentLabel = (intent: string) => {
    const intentLabels: { [key: string]: string } = {
      'credit_card_transactions': 'Credit Card',
      'fraud_alert': 'Fraud Alert',
      'credit_card_management': 'Card Management',
      'portfolio_analysis_request': 'Portfolio Review',
      'investment_advice': 'Investment Advice',
      'international_transfer': 'International Transfer',
      'mortgage_inquiry': 'Mortgage',
      'mortgage_application': 'Mortgage Application',
      'student_loan': 'Student Loan',
      'account_balance_inquiry': 'Account Balance',
      'loan_application': 'Loan Application',
      'business_loan': 'Business Loan',
      'account_upgrade': 'Account Upgrade',
      'account_upgrade_eligibility': 'Account Upgrade',
      'approval_process': 'Approval Process',
      'eligibility_check': 'Eligibility Assessment',
      'wealth_management': 'Wealth Management'
    }
    
    // If specific mapping exists, use it, otherwise format snake_case to Title Case
    return intentLabels[intent] || intent
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ')
  }
  
  // Keep refs updated - removed agentData ref
  useEffect(() => {
    embeddedAppIntentRef.current = embeddedAppIntent
    closedIntentsRef.current = closedIntents
    tabsRef.current = tabs
  }, [embeddedAppIntent, closedIntents, tabs])

  // Listen for customer context changes to update app URLs
  useEffect(() => {
    const handleCustomerContextUpdate = (event: CustomEvent) => {
      const { customer, hasContext } = event.detail
      traceLog('🔔 [TRACE] EmbeddedAppColumn received customer-context:updated event:', { 
        hasContext, 
        customer, 
        customerId: customer?.id,
        customerName: customer?.name,
        currentTabs: tabs.length,
        agentDataCustomer: customer,
        timestamp: new Date().toISOString()
      })
      
      // Update all tabs with new context-aware URLs
      setTabs(prev => prev.map(tab => {
        const customerContext: CustomerContext = {
          customerId: customer?.id || '',
          accountNumber: customer?.accountNumber,
          customerName: customer?.name,
          customerTier: customer?.tier,
          intent: tab.intent,
          callerId: callerId,
          email: customer?.email,
          phone: customer?.phone,
          location: customer?.location,
          cin: customer?.cin,
          accountType: customer?.accountType
        }
        
        // Build new URL based on updated context
        const newUrl = buildAppUrl(
          tab.appKey || tab.intent,
          hasContext,
          customerContext,
          { 
            role: 'agent',
            tabId: tab.id,
            launchedFromSearch: tab.appKey ? 'true' : 'false'
          }
        )
        
        // Only update if URL has changed (switching between modes)
        if (newUrl !== tab.url) {
          traceLog(`🔄 [TRACE] EmbeddedAppColumn updating tab ${tab.id} URL:`, {
            tabId: tab.id,
            fromMode: hasContext ? 'manual' : 'context',
            toMode: hasContext ? 'context' : 'manual',
            oldUrl: tab.url,
            newUrl,
            customerContext,
            hasContext
          })
          
          // Reset handshake state for reload
          return {
            ...tab,
            url: newUrl,
            isLoading: true,
            handshakeComplete: false,
            context: { ...tab.context, hasContext, mode: hasContext ? 'context' : 'manual' }
          }
        }
        
        return tab
      }))
    }
    
    window.addEventListener('customer-context:updated', handleCustomerContextUpdate as EventListener)
    
    return () => {
      window.removeEventListener('customer-context:updated', handleCustomerContextUpdate as EventListener)
    }
  }, [callerId, customer])
  
  // Listen for app launch events from global search
  useEffect(() => {
    const handleAppLaunch = (event: CustomEvent) => {
      const app = event.detail
      
      // Check if tab already exists for this app
      const existingTab = tabs.find(tab => tab.appKey === app.appKey)
      if (existingTab) {
        setActiveTabId(existingTab.id)
        return
      }
      
      // Build customer context for URL generation
      const customerContext: CustomerContext = {
        customerId: customer?.id || '',
        accountNumber: customer?.accountNumber,
        customerName: customer?.name,
        customerTier: customer?.tier,
        intent: app.supportedIntents?.[0] || app.intent,
        callerId: callerId,
        email: customer?.email,
        phone: customer?.phone,
        location: customer?.location,
        cin: customer?.cin,
        accountType: customer?.accountType
      }
      
      // Determine if we have customer context
      const hasContext = !!(customer?.id)
      
      // Build appropriate URL based on context availability
      const appUrl = buildAppUrl(
        app.appKey || app.id,
        hasContext,
        customerContext,
        { 
          role: 'agent',
          tabId: `app-${app.appKey || app.id}-${Date.now()}`,
          launchedFromSearch: 'true'
        }
      )
      
      // Create new tab for the launched app
      const newTabId = `app-${app.appKey || app.id}-${Date.now()}`
      const newTab: EmbeddedAppTab = {
        id: newTabId,
        intent: app.appKey || app.supportedIntents?.[0] || app.intent || 'manual_launch', // Use appKey as intent
        label: app.title || app.label || 'App',
        url: appUrl,
        isLoading: true,
        error: null,
        handshakeComplete: false,
        appKey: app.appKey,
        context: { ...app.context, hasContext, mode: hasContext ? 'context' : 'manual' }
      }
      
      setTabs(prev => [...prev, newTab])
      setActiveTabId(newTabId)
    }

    window.addEventListener('embedded-app:launch', handleAppLaunch as EventListener)
    
    return () => {
      window.removeEventListener('embedded-app:launch', handleAppLaunch as EventListener)
    }
  }, [tabs, customer, callerId])
  
  // Handle call end - reset all tabs when disconnected
  useEffect(() => {
    if (!isConnected) {
      // Clear all tabs
      setTabs([])
      setActiveTabId(null)
      setClosedIntents(new Set()) // Reset closed intents for next call
      
      // Clear all timeouts
      Object.values(handshakeTimeoutRefs.current).forEach(timeout => {
        if (timeout) clearTimeout(timeout)
      })
      handshakeTimeoutRefs.current = {}
      
      // Clear iframe refs
      iframeRefs.current = {}
    }
  }, [isConnected])
  
  // DON'T create default tab automatically - only create tabs when:
  // 1. Intent is detected
  // 2. App is launched from search
  // This prevents card management from opening by default
  useEffect(() => {
    // Removed automatic default tab creation
    // Tabs should only be created through explicit intent detection or app launch
  }, [currentRole, isConnected, tabs.length])
  
  // Extract tab creation logic into reusable function
  const createTabForIntent = useCallback((intentToCreate: string, switchToTab: boolean = false) => {
    // Check if tab already exists for this intent
    const existingTab = tabs.find(tab => tab.intent === intentToCreate)
    if (existingTab) {
      if (switchToTab) {
        setActiveTabId(existingTab.id)
      }
      return existingTab.id
    }
    
    // Check for WebSocket enriched data
    const hasEnrichedAppData = !!(websocketIntent?.type === intentToCreate && websocketIntent?.appUrl && websocketIntent?.appTitle)
    
    let appUrl: string
    let appTitle: string
    
    if (hasEnrichedAppData) {
      // Use enriched data from Gateway intent-to-app mapping
      appUrl = `${EMBEDDED_APP_URL}${websocketIntent.appUrl}`
      appTitle = websocketIntent.appTitle!
      
      // DEDUPLICATION: Check if a tab with the same appUrl already exists
      const existingAppTab = tabs.find(tab => tab.url.startsWith(`${EMBEDDED_APP_URL}${websocketIntent.appUrl}`))
      if (existingAppTab) {
        if (switchToTab) {
          setActiveTabId(existingAppTab.id)
        }
        return existingAppTab.id
      }
    } else {
      // Fallback to traditional URL building
      const customerContext: CustomerContext = {
        customerId: customer?.id || '',
        accountNumber: customer?.accountNumber,
        customerName: customer?.name,
        customerTier: customer?.tier,
        intent: intentToCreate,
        callerId: callerId,
        email: customer?.email,
        phone: customer?.phone,
        location: customer?.location,
        cin: customer?.cin,
        accountType: customer?.accountType
      }
      
      const hasContext = !!(customer?.id)
      
      appUrl = buildAppUrl(
        intentToCreate,
        hasContext,
        customerContext,
        { role: 'agent', tabId: `tab-${intentToCreate}-${Date.now()}` }
      )
      appTitle = getIntentLabel(intentToCreate)
    }
    
    // Create new tab
    const newTabId = `tab-${intentToCreate}-${Date.now()}`
    const newTab: EmbeddedAppTab = {
      id: newTabId,
      intent: intentToCreate,
      label: appTitle,
      url: appUrl,
      isLoading: true,
      error: null,
      handshakeComplete: false
    }
    
    setTabs(prev => {
      const newTabs = [...prev, newTab]
      
      // Switch to new tab if requested or if no tab is currently active
      if (switchToTab || !activeTabId) {
        setActiveTabId(newTabId)
      }
      
      return newTabs
    })
    
    return newTabId
  }, [tabs, websocketIntent, customer, callerId, activeTabId])
  
  // Add new tab when new intent is detected - use WebSocket enriched data when available
  useEffect(() => {
    // Prioritize WebSocket enriched intent data, fallback to intent store
    const currentIntent = websocketIntent?.type || embeddedAppIntent
    
    if (!currentIntent || !isConnected) {
      return
    }
    
    // Check if user previously closed this intent
    if (closedIntents.has(currentIntent)) {
      return
    }
    
    // Use the extracted function to create the tab
    createTabForIntent(currentIntent, false) // Don't auto-switch for preservation of free navigation
  }, [embeddedAppIntent, websocketIntent, isConnected, closedIntents, createTabForIntent])
  
  // Listen for dropdown selections - using refs to avoid recreating listeners
  useEffect(() => {
    const handleDropdownSelection = (event: CustomEvent) => {
      const selectedIntent = event.detail.intent
      if (!selectedIntent || !isConnected) return
      
      // Check if this intent was previously closed (using ref)
      if (closedIntentsRef.current.has(selectedIntent)) {
        // Remove from closed intents so it can be recreated
        setClosedIntents(prev => {
          const next = new Set(prev)
          next.delete(selectedIntent)
          return next
        })
        // Create tab directly to avoid race conditions
        createTabForIntent(selectedIntent, true)
        return
      }
      
      // Find existing tab for this intent (using ref)
      const existingTab = tabsRef.current.find(tab => tab.intent === selectedIntent)
      if (existingTab) {
        setActiveTabId(existingTab.id)
      } else {
        // No existing tab and not closed - create a new one
        createTabForIntent(selectedIntent, true)
      }
    }
    
    // Also listen for dropdown clicks to handle reopening closed tabs
    const handleDropdownClick = (event: CustomEvent) => {
      const clickedIntent = event.detail.intent
      if (!clickedIntent || !isConnected) return
      
      // Check if this intent was previously closed (using ref)
      if (closedIntentsRef.current.has(clickedIntent)) {
        // Remove from closed intents so it can be recreated
        setClosedIntents(prev => {
          const next = new Set(prev)
          next.delete(clickedIntent)
          return next
        })
        
        // Create tab directly using extracted function to avoid race condition
        // This bypasses the embeddedAppIntent store entirely for reopened tabs
        createTabForIntent(clickedIntent, true) // Switch to the reopened tab
        return
      }
      
      // Find existing tab for this intent (using ref)
      const existingTab = tabsRef.current.find(tab => tab.intent === clickedIntent)
      if (existingTab) {
        setActiveTabId(existingTab.id)
      }
    }
    
    window.addEventListener('intent:dropdown-selected', handleDropdownSelection as EventListener)
    window.addEventListener('intent:dropdown-clicked', handleDropdownClick as EventListener)
    return () => {
      window.removeEventListener('intent:dropdown-selected', handleDropdownSelection as EventListener)
      window.removeEventListener('intent:dropdown-clicked', handleDropdownClick as EventListener)
    }
  }, [isConnected, createTabForIntent]) // Include createTabForIntent for dropdown reopening
  
  // Handle iframe communication for each tab
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      
      // Security: Verify origin
      if (!ALLOWED_ORIGINS.includes(event.origin)) {
        return
      }
      
      // Get the tab ID from the message if available
      const tabId = event.data.tabId || activeTabId
      
      switch (event.data.type) {
        case 'embed.ready':
          
          // Update the specific tab's state
          setTabs(prev => prev.map(tab => 
            tab.id === tabId 
              ? { ...tab, handshakeComplete: true, isLoading: false, error: null }
              : tab
          ))
          
          // Clear the timeout for this tab
          if (handshakeTimeoutRefs.current[tabId]) {
            clearTimeout(handshakeTimeoutRefs.current[tabId])
            delete handshakeTimeoutRefs.current[tabId]
          }
          
          // Send initial state to the iframe
          const tab = tabs.find(t => t.id === tabId)
          if (tab && iframeRefs.current[tabId]?.contentWindow) {
            try {
              const hasContext = !!(customer?.id)
              const message = {
                type: 'host.state',
                context: {
                  customerId: customer?.id,
                  agentId: agentId,
                  customerName: customer?.name,
                  accountNumber: customer?.accountNumber,
                  customerTier: customer?.tier,
                  email: customer?.email,
                  phone: customer?.phone,
                  location: customer?.location,
                  cin: customer?.cin,
                  accountType: customer?.accountType,
                  intent: tab.intent,
                  intentContext: {},
                  // Include additional context for launched apps
                  appKey: tab.appKey,
                  launchedFromSearch: !!tab.appKey,
                  additionalContext: tab.context,
                  // Dual mode support
                  mode: hasContext ? 'context' : 'manual',
                  hasCustomerContext: hasContext
                }
              }
              iframeRefs.current[tabId].contentWindow.postMessage(message, '*')
            } catch (error) {
              // Don't let iframe communication errors affect the main app
            }
          }
          break
          
        case 'kms.open':
          // Request to open KMS article
          // Dispatch event that Space Copilot listens for
          window.dispatchEvent(new CustomEvent('kms:open-article', { 
            detail: { articleId: event.data.articleId } 
          }))
          break
          
        case 'action.execute':
          // Execute an action from embedded app
          break
          
        case 'resize':
          // Handle iframe resize request
          if (event.data.height) {
            setIframeHeight(`${event.data.height}px`)
          }
          break
        
        case 'call.ended':
          // Reset all tabs when call ends
          setTabs([])
          setActiveTabId(null)
          break
          
        default:
          break
      }
    }
    
    window.addEventListener('message', handleMessage)
    
    return () => {
      window.removeEventListener('message', handleMessage)
    }
  }, [activeTabId, tabs, customer, agentId])
  
  // Handle iframe load event for each tab
  const handleIframeLoad = (tabId: string) => {
    const iframe = iframeRefs.current[tabId]
    const tab = tabs.find(t => t.id === tabId)
    
    if (iframe?.contentWindow) {
      // Send ping to establish connection
      setTimeout(() => {
        try {
          const pingMessage = { type: 'host.ping', tabId }
          iframe.contentWindow?.postMessage(pingMessage, '*')
        } catch (error) {
          // Don't let iframe errors affect the main app
        }
      }, 100) // Reduced from 300ms to 100ms for faster handshake
      
      // Set timeout for handshake (reduced from 10s to 3s for faster feedback)
      handshakeTimeoutRefs.current[tabId] = setTimeout(() => {
        const tab = tabs.find(t => t.id === tabId)
        if (tab && !tab.handshakeComplete) {
          setTabs(prev => prev.map(t => 
            t.id === tabId 
              ? { ...t, error: 'Banking service temporarily unavailable', isLoading: false }
              : t
          ))
        }
      }, 2000) // Reduced from 3000ms to 2000ms for faster feedback
    }
  }
  
  // Handle retry for a specific tab
  const handleRetry = (tabId: string) => {
    setTabs(prev => prev.map(tab => 
      tab.id === tabId 
        ? { ...tab, error: null, isLoading: true, handshakeComplete: false }
        : tab
    ))
    
    // Clear existing timeout
    if (handshakeTimeoutRefs.current[tabId]) {
      clearTimeout(handshakeTimeoutRefs.current[tabId])
      delete handshakeTimeoutRefs.current[tabId]
    }
    
    // Reload the iframe
    const iframe = iframeRefs.current[tabId]
    if (iframe) {
      iframe.src = iframe.src
    }
  }
  
  // Handle tab close
  const handleCloseTab = (tabId: string) => {
    // Track which intent was closed
    const tabToClose = tabs.find(t => t.id === tabId)
    if (tabToClose) {
      setClosedIntents(prev => new Set([...prev, tabToClose.intent]))
    }
    
    setTabs(prev => prev.filter(tab => tab.id !== tabId))
    
    // Clear timeout
    if (handshakeTimeoutRefs.current[tabId]) {
      clearTimeout(handshakeTimeoutRefs.current[tabId])
      delete handshakeTimeoutRefs.current[tabId]
    }
    
    // Clear iframe ref
    delete iframeRefs.current[tabId]
    
    // Switch to another tab if this was active
    if (activeTabId === tabId) {
      const remainingTabs = tabs.filter(tab => tab.id !== tabId)
      setActiveTabId(remainingTabs.length > 0 ? remainingTabs[0].id : null)
    }
  }


  // Show empty state if no tabs
  if (tabs.length === 0) {
    return (
      <div className="h-full bg-background flex items-center justify-center">
        <div className="text-center space-y-3 max-w-md mx-auto px-4">
          <div className="text-muted-foreground">
            <Monitor className="h-12 w-12 mx-auto mb-4 opacity-50" />
            <p className="text-lg font-medium text-foreground">Banking Services Ready</p>
            <p className="text-sm opacity-75 leading-relaxed">Customer service tools will appear here automatically when banking needs are identified during the call</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="h-full bg-background flex flex-col">
      <Tabs value={activeTabId || ''} onValueChange={setActiveTabId} className="flex-1 flex flex-col">
        {/* Header container to match other columns */}
        <div className="h-12 bg-muted/30 border-b">
          <TabsList className="h-full w-full justify-start rounded-none border-0 p-0 px-2 bg-transparent">
            {tabs.map(tab => (
              <TabsTrigger 
                key={tab.id} 
                value={tab.id}
                className="relative h-full px-3 text-xs data-[state=active]:bg-background data-[state=active]:shadow-sm rounded-none border-r last:border-r-0"
              >
                <span className="mr-2">{tab.label}</span>
                <span
                  className="inline-flex items-center justify-center h-4 w-4 p-0 hover:bg-muted rounded cursor-pointer"
                  onClick={(e) => {
                    e.stopPropagation()
                    handleCloseTab(tab.id)
                  }}
                >
                  <X className="h-3 w-3" />
                </span>
                {tab.isLoading && (
                  <div className="absolute right-1 top-1">
                    <div className="h-2 w-2 bg-blue-500 rounded-full animate-pulse" />
                  </div>
                )}
              </TabsTrigger>
            ))}
          </TabsList>
        </div>
        
        <div className="flex-1 relative overflow-hidden">
          {tabs.map(tab => (
            <IframeTab
              key={tab.id}
              tab={tab}
              isActive={activeTabId === tab.id}
              onLoad={() => handleIframeLoad(tab.id)}
              onRetry={() => handleRetry(tab.id)}
              iframeRef={(el) => {
                if (el) {
                  iframeRefs.current[tab.id] = el
                }
              }}
            />
          ))}
        </div>
      </Tabs>
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/components/columns/kms-column.tsx===
import { useState, useEffect, memo } from 'react'
import { Button } from '../ui/button'
import { ScrollArea } from '../ui/scroll-area'
import { Badge } from '../ui/badge'
import { getAppConfig } from '../../config/app-config'
import { Separator } from '../ui/separator'
import { 
  ArrowLeft, 
  ExternalLink, 
  X,
  BookOpen,
  Clock,
  User,
  Tag,
  Star,
  ThumbsUp,
  ThumbsDown,
  Copy,
  Printer,
  Share
} from 'lucide-react'
import ReactMarkdown from 'react-markdown'
import remarkGfm from 'remark-gfm'
import { useKMSData } from '../../stores/selectors/agent-selectors'

interface KnowledgeArticle {
  id: string | number
  title: string
  category: string
  relevance?: number
  excerpt?: string
  url: string
  canEmbed?: boolean
  embedUrl?: string
  priority?: string
  author?: string
  lastUpdated?: string
  readTime?: string
  averageRating?: number
  totalRatings?: number
  helpfulVotes?: number
  content?: string
  tags?: string[]
}

interface KMSColumnProps {
  onBack?: () => void
  articleId?: string
  article?: KnowledgeArticle
}

export const KMSColumn = memo(function KMSColumn({ onBack, articleId, article }: KMSColumnProps) {
  const [userRating, setUserRating] = useState<number>(0)
  const [isHelpful, setIsHelpful] = useState<boolean | null>(null)
  const [showThankYou, setShowThankYou] = useState(false)
  const { knowledgeArticles } = useKMSData()
  
  // Resolve internal KB slugs to Docusaurus URLs
  const resolveArticleUrl = (url: string) => {
    const config = getAppConfig()
    const KB_BASE_URL = config.services.knowledgePortal.baseUrl
    
    if (url?.startsWith('/kb/')) {
      const slug = url.replace(/^\/kb\//, '')
      return `${KB_BASE_URL}/docs/${slug}`
    }
    
    return url
  }
  
  // Use the passed article object first, then try to find by ID, then fallback to mock
  const selectedArticle = article || knowledgeArticles.find(art => art.id === articleId)
  
  // Fallback to mock article if no real article found
  const displayArticle = selectedArticle || {
    id: articleId || 'kb-001',
    title: 'Querying recurring or continuous day loan transactions on a Credit Card',
    category: 'Credit Cards',
    author: 'Knowledge Team',
    lastUpdated: '20 Aug 2024',
    readTime: '5 min',
    averageRating: 4.3,
    totalRatings: 127,
    helpfulVotes: 89,
    content: `## Overview

This procedure helps establish if a transaction is a recurring transaction or a day loan transaction on a Credit Card and what the customer wants to do with the transaction.

## General Information

A recurring transaction, sometimes called a **Continuous Payment Authority (CPA)** or **Continuous Authority Transaction (CAT)**, is a series of payments set up using a customer's card details. These can be for subscriptions, memberships, or regular payments.

## Procedure Steps

### Step 1: Identify the Transaction

- Ask the customer to provide the transaction details
- Check if the merchant name appears multiple times  
- Verify the amounts and dates

### Step 2: Determine Transaction Type

#### Recurring Transaction Indicators:
- Same merchant name appearing regularly
- Consistent amounts (though may vary)
- Monthly, weekly, or other regular intervals

#### Day Loan Transaction Indicators:
- Small amounts (usually under £100)
- Very frequent transactions (daily or multiple times per week)
- Payday loan company names

### Step 3: Customer Options

#### For Recurring Transactions:
1. **Cancel at source** - CCAAS the merchant directly
2. **Cancel via bank** - Stop the continuous payment authority
3. **Dispute if unauthorized** - Raise a chargeback claim

#### For Day Loan Transactions:
1. **CCAAS the lender** - Discuss repayment options
2. **Seek financial advice** - Refer to debt counseling
3. **Block future transactions** - Cancel the CPA

## Important Notes

> ⚠️ **Always verify the customer's identity before making changes**

- Document all actions taken
- Inform customer of potential fees or consequences
- Escalate to supervisor if fraud is suspected

## Related Articles

- [How to cancel a continuous payment authority](#)
- [Understanding credit card statements](#)
- [Dispute and chargeback procedures](#)`,
    tags: ['credit-card', 'recurring-payments', 'transactions', 'day-loans']
  }

  // Handle feedback functions
  const handleRating = (rating: number) => {
    setUserRating(rating)
    setShowThankYou(true)
    setTimeout(() => setShowThankYou(false), 3000)
  }

  const handleHelpfulFeedback = (helpful: boolean) => {
    setIsHelpful(helpful)
    setShowThankYou(true) 
    setTimeout(() => setShowThankYou(false), 3000)
  }

  const copyArticleLink = () => {
    navigator.clipboard.writeText(`${window.location.origin}/knowledge/${displayArticle.id}`)
    // Could show a toast notification here
  }

  const printArticle = () => {
    window.print()
  }
  
  return (
    <div className="flex flex-col h-full bg-background">
      {/* Header with article title and action buttons */}
      <div className="px-3 py-2 border-b flex items-center justify-between">
        <h2 className="font-medium text-sm truncate flex-1 mr-2">
          {selectedArticle?.title || displayArticle.title}
        </h2>
        <div className="flex items-center gap-1 flex-shrink-0">
          <Button
            variant="ghost"
            size="icon"
            onClick={() => window.open(selectedArticle?.url || '#', '_blank')}
            title="Open in new tab"
            className="h-7 w-7"
          >
            <ExternalLink className="h-3.5 w-3.5" />
          </Button>
          <Button
            variant="ghost"
            size="icon"
            onClick={onBack}
            title="Close"
            className="h-7 w-7"
          >
            <X className="h-3.5 w-3.5" />
          </Button>
        </div>
      </div>
      
      {/* Full iframe - no other content */}
      {selectedArticle?.url ? (
        <div className="flex-1 relative overflow-hidden">
          <iframe
            src={selectedArticle.url}
            className="absolute w-full border-0"
            style={{ 
              height: 'calc(100% + 60px)', 
              top: '-60px'
            }}
            title={selectedArticle.title}
            sandbox="allow-same-origin allow-scripts allow-popups allow-forms"
          />
        </div>
      ) : (
        // Fallback to markdown content for demo articles
        <ScrollArea className="flex-1">
          <div className="p-4">
            <ReactMarkdown
              remarkPlugins={[remarkGfm]}
              className="prose prose-sm dark:prose-invert max-w-none"
              components={{
                h1: ({ children }) => (
                  <h1 className="text-xl font-bold mt-6 mb-4 text-foreground">{children}</h1>
                ),
                h2: ({ children }) => (
                  <h2 className="text-lg font-semibold mt-5 mb-3 text-foreground">{children}</h2>
                ),
                h3: ({ children }) => (
                  <h3 className="text-base font-semibold mt-4 mb-2 text-foreground">{children}</h3>
                ),
                h4: ({ children }) => (
                  <h4 className="text-sm font-semibold mt-3 mb-2 text-foreground">{children}</h4>
                ),
                p: ({ children }) => (
                  <p className="text-sm leading-relaxed mb-3 text-foreground">{children}</p>
                ),
                ul: ({ children }) => (
                  <ul className="list-disc list-inside mb-3 space-y-1">{children}</ul>
                ),
                ol: ({ children }) => (
                  <ol className="list-decimal list-inside mb-3 space-y-1">{children}</ol>
                ),
                li: ({ children }) => (
                  <li className="text-sm text-foreground ml-2">{children}</li>
                ),
                blockquote: ({ children }) => (
                  <blockquote className="border-l-4 border-primary pl-4 py-2 my-4 bg-muted/50 rounded-r">
                    {children}
                  </blockquote>
                ),
                strong: ({ children }) => (
                  <strong className="font-semibold text-foreground">{children}</strong>
                ),
                a: ({ href, children }) => (
                  <a 
                    href={href} 
                    className="text-primary hover:text-primary/80 underline"
                    target="_blank"
                    rel="noopener noreferrer"
                  >
                    {children}
                  </a>
                ),
                code: ({ children }) => (
                  <code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">
                    {children}
                  </code>
                ),
              }}
            >
              {displayArticle.content || (displayArticle as any).excerpt}
            </ReactMarkdown>
          </div>
        </ScrollArea>
      )}
    </div>
  )
})
===END FILE===

===BEGIN FILE: src/components/columns/space-copilot-column.tsx===
import { useState, useEffect, useRef, useCallback } from 'react'
import { TranscriptWidget } from '../widgets/transcript'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select'
import { Badge } from '../ui/badge'
import { Button } from '../ui/button'
import { ScrollArea } from '../ui/scroll-area'
import { Card, CardContent, CardHeader } from '../ui/card'
import { Panel, PanelGroup } from 'react-resizable-panels'
import { ResizableHandle } from '../layout/resizable-widget-container'
import { useWidgetLayout } from '../../hooks/use-widget-layout'
import { useAgentSettings } from '../../hooks/use-agent-settings'
import { 
  Bot,
  Sparkles,
  MessageSquare,
  ThumbsUp,
  ThumbsDown,
  RotateCcw,
  User,
  CreditCard,
  Shield,
  FileText,
  Copy,
  Wallet,
  ShieldAlert,
  AlertTriangle,
  Banknote,
  Building,
  Plane,
  BookOpen,
  ExternalLink,
  Target,
  X,
  Smile,
  Frown,
  Meh,
  TrendingUp,
  TrendingDown
} from 'lucide-react'
import { useIntentStore } from '../../stores/intent-store'
import { useAgentStore } from '../../stores/agent-store'
import { useWebSocket } from '../../contexts/websocket-context'
import { intentRegistry, detectIntentsFromConversation } from '../../config/intent-registry'
import { ErrorBoundary, SpaceCopilotErrorFallback } from '../common/error-boundary'
import intentService from '../../services/intent-service'
import { useNotificationStore } from '../../stores/notification-store'
import { cn } from '../../lib/utils'
import { toast } from 'sonner'

// Helper function to get icon component from string
const getIconComponent = (iconName: string) => {
  const icons: Record<string, any> = {
    'credit-card': CreditCard,
    'wallet': Wallet,
    'shield-alert': ShieldAlert,
    'alert-triangle': AlertTriangle,
    'file-text': FileText,
    'banknote': Banknote,
    'shield': Shield,
    'user': User,
    'building': Building,
    'plane': Plane
  }
  return icons[iconName] || CreditCard
}

interface SpaceCopilotColumnProps {
  onKMSOpen?: (articleId: string, article?: any) => void
}

export function SpaceCopilotColumn({ onKMSOpen }: SpaceCopilotColumnProps) {
  const { 
    currentIntent, 
    availableIntents, 
    selectIntent,
    setEmbeddedAppIntent,
    setAvailableIntents,
    clearIntents 
  } = useIntentStore()
  const { agentData } = useAgentStore()
  const { settings } = useAgentSettings()
  const webSocketContext = useWebSocket()
  const isConnected = webSocketContext?.isConnected || false
  
  // Intent notification tracking for the entire column
  const hasShownNotificationForIntent = useRef<Set<string>>(new Set())
  const previousIntentRef = useRef<string | null>(null)
  const [newIntentTrigger, setNewIntentTrigger] = useState<{intentId: string, timestamp: number} | null>(null)
  
  // Widget layout hooks - only for transcript if enabled
  const transcriptLayout = useWidgetLayout({
    column: 'spaceCopilot',
    widgetId: 'transcript',
    defaultSize: 40,
    minSize: 25,
    maxSize: 60
  })
  
  const aiAssistanceLayout = useWidgetLayout({
    column: 'spaceCopilot',
    widgetId: 'ai-assistance',
    defaultSize: settings.interface.showTranscript ? 60 : 100,
    minSize: settings.interface.showTranscript ? 40 : 100,
    maxSize: settings.interface.showTranscript ? 75 : 100
  })

  // Clear intents when call ends (disconnected)
  useEffect(() => {
    if (!isConnected) {
      clearIntents()
      // Clear notification tracking for fresh notifications on new calls
      hasShownNotificationForIntent.current.clear()
      previousIntentRef.current = null
      // Clear any pending intent triggers
      setNewIntentTrigger(null)
    }
  }, [isConnected, clearIntents])
  
  // Initialize intents based on real agent data - accumulate multiple intents
  useEffect(() => {
    const processIntent = async () => {
      try {
        
        // Only show intent if we have real intent data from the agent
        if (agentData.intent && agentData.intent.type && agentData.intent.type !== 'UNKNOWN') {
          
          try {
            // Use WebSocket enriched intent data from Gateway
            const intentId = agentData.intent.type
            const hasEnrichedData = !!(agentData.intent.appUrl && agentData.intent.appTitle)
            
            if (!hasEnrichedData) {
              return
            }
            
            // Use enriched data from Gateway - this means the intent definitely has an embedded app
            const realIntent = {
              id: intentId,
              name: agentData.intent.appTitle,
              icon: 'target',
              context: {},
              confidence: agentData.intent.confidence || 0.9,
              hasEmbeddedApp: true,
              appUrl: agentData.intent.appUrl
            }
            
            // Add to available intents if not already present
            setAvailableIntents(prev => {
              // Check if this exact intent already exists
              const exactIntentExists = prev.some(intent => intent.id === realIntent.id)
              
              if (exactIntentExists) {
                // Update confidence if intent already exists
                return prev.map(intent => 
                  intent.id === realIntent.id 
                    ? { ...intent, confidence: realIntent.confidence }
                    : intent
                )
              }
              
              // DEDUPLICATION: Check if an intent with the same appUrl already exists
              // This prevents duplicate dropdown entries for different intents that map to the same app
              const sameAppExists = prev.some(intent => 
                intent.appUrl === realIntent.appUrl && intent.id !== realIntent.id
              )
              
              if (sameAppExists) {
                // Don't add this intent as it would create a duplicate dropdown entry
                // IMPORTANT: Also don't set embeddedAppIntent to prevent duplicate tab creation
                return prev
              }
              
              // Add new intent to the list
              const newArray = [...prev, realIntent]
              
              // Trigger visual feedback for new intent detection
              setNewIntentTrigger({
                intentId: realIntent.id,
                timestamp: Date.now()
              })
              
              // Only set embedded app intent if this is the first intent OR if no tabs exist yet
              // This prevents creating duplicate tabs for the same app
              if (prev.length === 0) {
                setEmbeddedAppIntent(realIntent.id)
              }
              
              return newArray
            })
            
            // Auto-select the first intent only
            if (availableIntents.length === 0) {
              selectIntent(realIntent.id)
            }
            
          } catch (error) {
          }
          
        } else if (!agentData.intent || agentData.intent.type === 'UNKNOWN') {
          // Clear intents if no existing intents AND not connected
          if (availableIntents.length === 0 && !isConnected) {
            setAvailableIntents([])
            selectIntent('')
          }
        }
      } catch (error) {
      }
    }
    
    processIntent()
  }, [agentData.intent, isConnected, availableIntents.length])
  
  // Get current intent details
  const intentDetails = currentIntent ? 
    intentRegistry[currentIntent as keyof typeof intentRegistry] : null
    
  // Get current intent object from available intents
  const currentIntentObj = currentIntent ? 
    availableIntents.find(i => i.id === currentIntent) : null
    
  
  // Conditionally render with or without transcript based on settings
  if (settings.interface.showTranscript) {
    return (
      <PanelGroup direction="vertical" className="h-full w-full">
        {/* Space Copilot Panel with Intent at top */}
        <Panel 
          defaultSize={aiAssistanceLayout.size}
          minSize={aiAssistanceLayout.minSize}
          maxSize={aiAssistanceLayout.maxSize}
          onResize={aiAssistanceLayout.handleResize}
        >
          <ErrorBoundary fallback={SpaceCopilotErrorFallback}>
            <SpaceCopilotContent 
              currentIntent={currentIntent}
              currentIntentObj={currentIntentObj}
              availableIntents={availableIntents}
              selectIntent={selectIntent}
              setEmbeddedAppIntent={setEmbeddedAppIntent}
              agentData={agentData}
              onKMSOpen={onKMSOpen}
              notificationTracker={hasShownNotificationForIntent}
              previousIntentTracker={previousIntentRef}
              newIntentTrigger={newIntentTrigger}
              isConnected={isConnected}
            />
          </ErrorBoundary>
        </Panel>
        
        <ResizableHandle direction="vertical" />
        
        {/* Transcript Panel at bottom - Only show if enabled */}
        <Panel 
          defaultSize={transcriptLayout.size}
          minSize={transcriptLayout.minSize}
          maxSize={transcriptLayout.maxSize}
          onResize={transcriptLayout.handleResize}
        >
          <div className="h-full flex flex-col border-t">
            <div className="flex-1 overflow-hidden">
              <TranscriptWidget />
            </div>
          </div>
        </Panel>
      </PanelGroup>
    )
  }

  // No transcript - full height Space Copilot
  return (
    <div className="h-full">
      <ErrorBoundary fallback={SpaceCopilotErrorFallback}>
        <SpaceCopilotContent 
          currentIntent={currentIntent}
          currentIntentObj={currentIntentObj}
          availableIntents={availableIntents}
          selectIntent={selectIntent}
          setEmbeddedAppIntent={setEmbeddedAppIntent}
          agentData={agentData}
          onKMSOpen={onKMSOpen}
          notificationTracker={hasShownNotificationForIntent}
          previousIntentTracker={previousIntentRef}
          newIntentTrigger={newIntentTrigger}
          isConnected={isConnected}
        />
      </ErrorBoundary>
    </div>
  )
}

// Modern Space Copilot Content Component
function SpaceCopilotContent({ currentIntent, currentIntentObj, availableIntents, selectIntent, setEmbeddedAppIntent, agentData, onKMSOpen, notificationTracker, previousIntentTracker, newIntentTrigger, isConnected }: {
  currentIntent: string | null
  currentIntentObj: any | null
  availableIntents: any[]
  selectIntent: (id: string) => void
  setEmbeddedAppIntent: (id: string) => void
  agentData: any
  onKMSOpen?: (articleId: string, article?: any) => void
  notificationTracker: React.MutableRefObject<Set<string>>
  previousIntentTracker: React.MutableRefObject<string | null>
  newIntentTrigger: {intentId: string, timestamp: number} | null
  isConnected: boolean
}) {
  // Extract AI coaching messages from actions data
  const aiCoachingActions = (agentData?.actions || []).filter((action: any) => action.type === 'ai_coaching')
  const customerProfile = agentData?.customer || {}
  const knowledgeArticles = agentData?.knowledgeArticles || []
  const [viewedArticles, setViewedArticles] = useState<Set<string>>(new Set())
  const { addNotification } = useNotificationStore()
  const lastArticleCountRef = useRef(0)
  const lastCoachingCountRef = useRef(0)
  
  // Intent detection visual feedback states
  const [newIntentDetected, setNewIntentDetected] = useState(false)
  const [dropdownGlow, setDropdownGlow] = useState(false)
  
  // Refs for sticky scrolling
  const scrollAreaRef = useRef<HTMLDivElement>(null)
  const aiMessagesEndRef = useRef<HTMLDivElement>(null)
  const [isUserScrolling, setIsUserScrolling] = useState(false)
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  
  // Count new articles
  const newArticleCount = knowledgeArticles.filter((article: any) => 
    article.isNew && !viewedArticles.has(article.id)
  ).length
  
  // Show notification when new articles arrive
  useEffect(() => {
    const currentCount = knowledgeArticles.length
    if (currentCount > lastArticleCountRef.current && lastArticleCountRef.current > 0) {
      const newCount = currentCount - lastArticleCountRef.current
      const newArticles = knowledgeArticles.slice(0, newCount)
      
      addNotification({
        type: 'knowledge',
        title: "New Knowledge Articles",
        description: `${newCount} new article${newCount > 1 ? 's' : ''} available: ${newArticles.map((a: any) => a.title).join(', ')}`,
        icon: 'sparkles',
        actionLabel: 'View',
        actionCallback: () => {
          // Scroll to knowledge articles section
          if (scrollAreaRef.current) {
            const knowledgeSection = document.querySelector('[data-section="knowledge"]')
            if (knowledgeSection) {
              knowledgeSection.scrollIntoView({ behavior: 'smooth' })
            }
          }
        }
      })
    }
    lastArticleCountRef.current = currentCount
  }, [knowledgeArticles.length, addNotification])
  
  // Show notification for AI coaching messages
  useEffect(() => {
    const currentCount = aiCoachingActions.length
    if (currentCount > lastCoachingCountRef.current && lastCoachingCountRef.current > 0) {
      const newCoaching = aiCoachingActions[0] // Most recent coaching
      
      if (newCoaching && newCoaching.stage === 'resolution') {
        addNotification({
          type: 'ai_coaching',
          title: "AI Resolution Guidance",
          description: newCoaching.action.substring(0, 100) + '...',
          icon: 'bot'
        })
      } else if (newCoaching && ['greeting', 'discovery'].includes(newCoaching.stage)) {
        // Don't notify for early stage coaching
      } else if (newCoaching) {
        addNotification({
          type: 'ai_coaching',
          title: "AI Assistant Update",
          description: `New ${newCoaching.stage} guidance available`,
          icon: 'bot'
        })
      }
    }
    lastCoachingCountRef.current = currentCount
  }, [aiCoachingActions.length, addNotification])
  
  // Detect intent changes and trigger visual feedback ONLY for WebSocket-detected intents
  useEffect(() => {
    // Only process intents if we're connected
    if (!isConnected) {
      return
    }
    
    if (currentIntent && currentIntent !== previousIntentTracker.current) {
      // Only show notifications for intents we haven't already notified about
      if (previousIntentTracker.current !== null && !notificationTracker.current.has(currentIntent)) {
        // Mark this intent as having been notified
        notificationTracker.current.add(currentIntent)
        
        setNewIntentDetected(true)
        setDropdownGlow(true)
        
        // Add notification to notification center (only once per intent) - NO TOAST
        addNotification({
          type: 'system',
          title: 'New Intent Detected',
          description: `Customer intent identified: ${currentIntentObj?.name || currentIntent}`,
          icon: 'target',
          metadata: { intent: currentIntent, confidence: currentIntentObj?.confidence }
        })
        
        // Auto-dismiss alert after 5 seconds
        setTimeout(() => {
          setNewIntentDetected(false)
        }, 5000)
        
        // Remove dropdown glow after 3 seconds
        setTimeout(() => {
          setDropdownGlow(false)
        }, 3000)
      }
      previousIntentTracker.current = currentIntent
    }
  }, [currentIntent, currentIntentObj, addNotification, isConnected])
  
  // Handle immediate intent detection feedback from parent trigger (when new intents arrive)
  useEffect(() => {
    // Only process intent triggers if we're connected
    if (!isConnected || !newIntentTrigger) {
      return
    }
    
    const { intentId } = newIntentTrigger
    
    // Only show notifications for intents we haven't already notified about
    if (!notificationTracker.current.has(intentId)) {
      // Mark this intent as having been notified
      notificationTracker.current.add(intentId)
      
      // Find the intent object for display information
      const intentObj = availableIntents.find(i => i.id === intentId)
      
      setNewIntentDetected(true)
      setDropdownGlow(true)
      
      // Scroll to top to show the intent dropdown
      // Small delay to ensure DOM updates are applied first
      setTimeout(() => {
        if (scrollAreaRef.current) {
          // Stop user scrolling mode to allow auto-scroll
          setIsUserScrolling(false)
          
          // Scroll to top smoothly
          const scrollElement = scrollAreaRef.current.querySelector('[data-radix-scroll-area-viewport]')
          if (scrollElement) {
            scrollElement.scrollTo({ top: 0, behavior: 'smooth' })
          }
        }
      }, 100)
      
      // Add notification to notification center (only once per intent) - NO TOAST
      addNotification({
        type: 'system',
        title: 'New Intent Detected',
        description: `Customer intent identified: ${intentObj?.name || intentId}`,
        icon: 'target',
        metadata: { intent: intentId, confidence: intentObj?.confidence }
      })
      
      // Auto-dismiss alert after 5 seconds
      setTimeout(() => {
        setNewIntentDetected(false)
      }, 5000)
      
      // Remove dropdown glow after 3 seconds
      setTimeout(() => {
        setDropdownGlow(false)
      }, 3000)
    }
  }, [newIntentTrigger, availableIntents, addNotification, isConnected])
  
  // Handle scroll events to detect user scrolling
  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    if (scrollTimeoutRef.current) {
      clearTimeout(scrollTimeoutRef.current)
    }
    
    setIsUserScrolling(true)
    
    // Reset after user stops scrolling for 1 second
    scrollTimeoutRef.current = setTimeout(() => {
      const scrollContainer = e.currentTarget
      const isNearBottom = scrollContainer.scrollHeight - scrollContainer.scrollTop - scrollContainer.clientHeight < 100
      
      // Only auto-follow if user scrolls near the AI messages area (not down to knowledge articles)
      if (isNearBottom && aiMessagesEndRef.current) {
        const aiMessagesBottom = aiMessagesEndRef.current.offsetTop + aiMessagesEndRef.current.offsetHeight
        const currentScroll = scrollContainer.scrollTop + scrollContainer.clientHeight
        
        // If we're looking at the AI messages area (not scrolled down to knowledge), resume auto-scroll
        if (currentScroll < aiMessagesBottom + 200) {
          setIsUserScrolling(false)
        }
      }
    }, 1000)
  }, [])
  
  // Auto-scroll to latest AI coaching message (but not to knowledge articles)
  useEffect(() => {
    if (!isUserScrolling && aiMessagesEndRef.current && scrollAreaRef.current) {
      // Scroll to the end of AI messages, not the bottom of the entire container
      aiMessagesEndRef.current.scrollIntoView({ behavior: 'smooth', block: 'end' })
    }
  }, [aiCoachingActions.length, isUserScrolling])
  
  // Handle knowledge article click
  const handleKnowledgeClick = (article: any) => {
    // Mark as viewed
    setViewedArticles(prev => new Set(prev).add(article.id))
    if (onKMSOpen) {
      onKMSOpen(article.id, article)
    }
  }
  
  try {
  } catch (error) {
    // Return safe fallback UI
    return (
      <div className="h-full bg-background p-4">
        <div className="text-red-500">Error loading Space Copilot content</div>
      </div>
    )
  }
  
  // Note: Intent changes are now handled by the intent store's setEmbeddedAppIntent
  // which sends the postMessage to the embedded app
  
  // Helper to get embedded app for intent
  const getEmbeddedAppForIntent = (intent: string) => {
    const intentMapping = {
      'credit_card_transactions': 'credit_card_management',
      'fraud_alert': 'fraud_alert', 
      'mortgage_inquiry': 'mortgage_application',
      'loan_application': 'business_loan',
      'account_balance_inquiry': 'account_upgrade'
    }
    return intentMapping[intent as keyof typeof intentMapping] || 'credit_card_management'
  }
  // Get current sentiment data
  const currentSentiment = agentData?.sentiment || null
  // Convert confidence (0-1) to percentage if needed, or use score directly if already percentage
  const sentimentScore = currentSentiment?.score || (currentSentiment?.confidence ? Math.round(currentSentiment.confidence * 100) : 0)
  
  // Determine sentiment emoji and color
  const getSentimentDisplay = () => {
    if (!currentSentiment) return { icon: Meh, color: 'text-gray-400', bg: 'bg-gray-50', label: 'Neutral' }
    
    // Use sentiment field directly, or fall back to label field
    const sentiment = (currentSentiment.sentiment || currentSentiment.label || 'neutral').toLowerCase()
    if (sentiment === 'positive') {
      return { 
        icon: Smile, 
        color: 'text-green-600', 
        bg: 'bg-green-50', 
        border: 'border-green-200',
        label: 'Positive',
        trend: TrendingUp
      }
    } else if (sentiment === 'negative') {
      return { 
        icon: Frown, 
        color: 'text-red-600', 
        bg: 'bg-red-50', 
        border: 'border-red-200',
        label: 'Negative',
        trend: TrendingDown
      }
    }
    return { 
      icon: Meh, 
      color: 'text-yellow-600', 
      bg: 'bg-yellow-50', 
      border: 'border-yellow-200',
      label: 'Neutral',
      trend: null
    }
  }
  
  const sentimentDisplay = getSentimentDisplay()
  const SentimentIcon = sentimentDisplay.icon
  const TrendIcon = sentimentDisplay.trend
  
  // If no AI coaching, show full-height empty state
  if (aiCoachingActions.length === 0) {
    return (
      <div className="h-full bg-background flex items-center justify-center">
        <div className="text-center space-y-3 max-w-md mx-auto px-4">
          <div className="text-muted-foreground">
            <Bot className="h-12 w-12 mx-auto mb-4 opacity-50" />
            <p className="text-lg font-medium text-foreground">AI Copilot Ready</p>
            <p className="text-sm opacity-75 leading-relaxed">Your intelligent assistant will provide real-time insights, suggestions, and knowledge support during customer interactions</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="h-full bg-background">
      <ScrollArea className="h-full" onScroll={handleScroll} ref={scrollAreaRef}>
        <div className="p-4 space-y-4">
          {/* Real-time Sentiment Indicator - Simple one-line */}
          {isConnected && currentSentiment && (
            <div className="animate-in fade-in-50 duration-500">
              <div className={`${sentimentDisplay.bg} ${sentimentDisplay.border} border rounded-lg px-3 py-2 flex items-center gap-2`}>
                <span className="text-xs font-medium text-muted-foreground">Sentiment:</span>
                <SentimentIcon className={`h-4 w-4 ${sentimentDisplay.color} animate-pulse`} />
                <span className={`text-sm font-medium ${sentimentDisplay.color}`}>
                  {sentimentDisplay.label}
                </span>
                {TrendIcon && (
                  <TrendIcon className={`h-3 w-3 ${sentimentDisplay.color} ml-auto`} />
                )}
              </div>
            </div>
          )}
          
          {/* New Intent Detection Alert Banner */}
          {newIntentDetected && currentIntentObj && (
            <div className="animate-in slide-in-from-top-4 fade-in duration-500">
              <div className="bg-gradient-to-r from-green-100 to-emerald-100 border-2 border-green-400 rounded-lg p-4 relative overflow-hidden shadow-lg shadow-green-500/20">
                <div className="absolute inset-0 bg-gradient-to-r from-green-400/20 to-emerald-400/20 animate-pulse" />
                <div className="relative flex items-start gap-3">
                  <div className="flex-shrink-0">
                    <div className="h-8 w-8 rounded-full bg-green-100 flex items-center justify-center">
                      <Target className="h-4 w-4 text-green-600 animate-pulse" />
                    </div>
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <h4 className="text-sm font-semibold text-green-900">New Intent Detected</h4>
                      <Badge className="bg-green-100 text-green-700 text-xs">
                        {Math.round(currentIntentObj.confidence * 100)}% confidence
                      </Badge>
                    </div>
                    <p className="text-sm text-green-700 mt-1">
                      Customer intent: <span className="font-medium">{currentIntentObj.name}</span>
                    </p>
                  </div>
                  <button
                    onClick={() => setNewIntentDetected(false)}
                    className="flex-shrink-0 p-1 hover:bg-green-100 rounded transition-colors"
                  >
                    <X className="h-4 w-4 text-green-600" />
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Intent Selection - Only show after Phase 3 */}
          {availableIntents.length > 0 && (
            <div className="animate-in fade-in-50 duration-500">
              <label className="text-xs font-medium text-muted-foreground mb-2 block flex items-center gap-2">
                <span>Detected Intent</span>
                {dropdownGlow && (
                  <span className="inline-flex h-3 w-3 rounded-full bg-green-500 animate-ping shadow-lg shadow-green-500/50" />
                )}
              </label>
              <Select 
                value={currentIntent || ''} 
                onValueChange={(value) => {
                  // Dispatch custom event to indicate this is a user dropdown selection
                  window.dispatchEvent(new CustomEvent('intent:dropdown-selected', { 
                    detail: { intent: value } 
                  }))
                  setEmbeddedAppIntent(value)  // This will update both embedded app and dropdown
                }}
              >
                <SelectTrigger 
                  className={cn(
                    "w-full transition-all duration-500",
                    dropdownGlow && "ring-4 ring-green-500 ring-offset-2 shadow-lg shadow-green-500/30 border-green-500 bg-green-50/50 animate-pulse"
                  )}
                  onPointerDown={(e) => {
                    // Fire event on every click, even if selecting the same value
                    // This ensures closed tabs can be reopened by clicking the dropdown
                    if (currentIntent) {
                      window.dispatchEvent(new CustomEvent('intent:dropdown-clicked', { 
                        detail: { intent: currentIntent } 
                      }))
                    }
                  }}
                >
                  <SelectValue placeholder="Analyzing conversation..." />
                </SelectTrigger>
                <SelectContent>
                  {availableIntents.map((intent) => (
                    <SelectItem key={intent.id} value={intent.id}>
                      <div className="flex items-center gap-2">
                        {(() => {
                          const IconComponent = getIconComponent(intent.icon)
                          return <IconComponent className="h-4 w-4" />
                        })()}
                        <span>{intent.name}</span>
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              
              {currentIntentObj && (
                <div className="flex items-center justify-between mt-2">
                  <Badge variant="outline" className="text-xs">
                    {Math.round(currentIntentObj.confidence * 100)}% confidence
                  </Badge>
                </div>
              )}
            </div>
          )}

          {/* AI Assistant Messages - Progressive Display */}
          <div className="space-y-3">
            {/* Show phase indicator if no intent yet */}
            {!currentIntent && (
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
                <div className="flex items-center gap-2">
                  <Sparkles className="h-4 w-4 text-blue-600 animate-pulse" />
                  <span className="text-sm text-blue-800 font-medium">Discovering customer needs...</span>
                </div>
              </div>
            )}
            
            {/* AI Coaching Messages */}
            {aiCoachingActions.map((coaching: any, index: number) => {
              // Extract timestamp from coaching if available, otherwise use current time
              const timestamp = coaching.timestamp || new Date().toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit', 
                hour12: false 
              })
              
              // Determine coaching type based on stage
              const isGreeting = coaching.stage === 'greeting'
              const isDiscovery = ['discovery', 'verification'].includes(coaching.stage)
              const isAnalysis = ['investigation', 'analysis', 'assessment'].includes(coaching.stage)
              const isResolution = ['resolution', 'advisory', 'options', 'processing'].includes(coaching.stage)
              const isClosing = ['next_steps', 'closing', 'follow_up'].includes(coaching.stage)
              
              // Color coding based on phase
              let bgColor = 'bg-red-50 border-red-100'
              let iconBg = 'bg-red-600'
              let textColor = 'text-red-800'
              
              if (isGreeting || isDiscovery) {
                bgColor = 'bg-blue-50 border-blue-100'
                iconBg = 'bg-blue-600'
                textColor = 'text-blue-800'
              } else if (isAnalysis) {
                bgColor = 'bg-amber-50 border-amber-100'
                iconBg = 'bg-amber-600'
                textColor = 'text-amber-800'
              } else if (isResolution) {
                bgColor = 'bg-green-50 border-green-100'
                iconBg = 'bg-green-600'
                textColor = 'text-green-800'
              } else if (isClosing) {
                bgColor = 'bg-purple-50 border-purple-100'
                iconBg = 'bg-purple-600'
                textColor = 'text-purple-800'
              }
              
              return (
                <div key={`${coaching.id || `coaching_${index}`}`} className="animate-in slide-in-from-bottom-2 duration-300">
                  {/* AI Coaching Message */}
                  <div className={`${bgColor} border rounded-lg p-3`}>
                    <div className="flex items-start gap-2">
                      <div className={`${iconBg} rounded-full p-1 mt-0.5`}>
                        <Bot className="h-3 w-3 text-white" />
                      </div>
                      <div className="flex-1">
                        <div className={`text-xs ${textColor} font-medium mb-1 flex items-center gap-2`}>
                          <span>AI Assistant</span>
                          <span className="opacity-60">•</span>
                          <span className="opacity-60">{timestamp}</span>
                          {coaching.stage && (
                            <>
                              <span className="opacity-60">•</span>
                              <Badge variant="outline" className="text-[10px] px-1 py-0">
                                {coaching.stage}
                              </Badge>
                            </>
                          )}
                        </div>
                        <div className="text-sm">
                          {coaching.action}
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* Suggested Response if available */}
                  {coaching.details && (
                    <Card className="bg-gray-50 border-gray-200 ml-7 mt-2">
                      <CardContent className="p-3">
                        <div className="text-xs text-gray-500 mb-1">Suggested response:</div>
                        <div className="text-sm italic">
                          "{coaching.details}"
                        </div>
                        <div className="flex items-center justify-between mt-2">
                          <div className="flex items-center gap-2">
                            <Button variant="ghost" size="icon" className="h-6 w-6">
                              <ThumbsUp className="h-3 w-3" />
                            </Button>
                            <Button variant="ghost" size="icon" className="h-6 w-6">
                              <ThumbsDown className="h-3 w-3" />
                            </Button>
                            <Button variant="ghost" size="icon" className="h-6 w-6">
                              <Copy className="h-3 w-3" />
                            </Button>
                          </div>
                        </div>
                      </CardContent>
                    </Card>
                  )}
                </div>
              )
            })}
          </div>
          
          {/* Invisible marker for end of AI messages section */}
          <div ref={aiMessagesEndRef} />

          {/* Knowledge Articles - Show progressively after intent detected */}
          {knowledgeArticles.length > 0 && (
            <div className="animate-in fade-in-50 duration-500" data-section="knowledge">
              <label className="text-xs font-medium text-muted-foreground mb-2 block flex items-center gap-2">
                <span>Knowledge Base Articles</span>
                {newArticleCount > 0 && (
                  <Badge className="text-xs bg-green-100 text-green-800 animate-pulse">
                    <Sparkles className="h-2.5 w-2.5 mr-1" />
                    {newArticleCount} new
                  </Badge>
                )}
              </label>
              <div className="space-y-2">
                {knowledgeArticles.map((article: any, index: number) => {
                  const isNewUnviewed = article.isNew && !viewedArticles.has(article.id)
                  return (
                  <Card 
                    key={article.id || index} 
                    className={`hover:shadow-md transition-shadow cursor-pointer animate-in slide-in-from-bottom-2 duration-300 ${
                      isNewUnviewed ? 'border-green-500 bg-green-50/50' : ''
                    }`}
                    style={{ animationDelay: `${index * 100}ms` }}
                    onClick={() => handleKnowledgeClick(article)}
                  >
                    <CardContent className="p-3">
                      <div className="flex items-start justify-between gap-2">
                        <div className="flex items-start gap-2 flex-1">
                          <BookOpen className="h-4 w-4 text-blue-600 mt-0.5 flex-shrink-0" />
                          <div className="flex-1 min-w-0">
                            <div className="text-sm font-medium truncate flex items-center gap-2">
                              {isNewUnviewed && (
                                <Sparkles className="h-3 w-3 text-green-600 animate-pulse flex-shrink-0" />
                              )}
                              {article.title}
                            </div>
                            <div className="flex items-center gap-2 mt-1">
                              <Badge 
                                variant="outline" 
                                className={`text-[10px] px-1 py-0 ${
                                  article.priority === 'urgent' ? 'border-red-500 text-red-600' :
                                  article.priority === 'high' ? 'border-orange-500 text-orange-600' :
                                  article.priority === 'medium' ? 'border-yellow-500 text-yellow-600' :
                                  article.priority === 'low' ? 'border-green-500 text-green-600' : ''
                                }`}
                              >
                                {article.priority}
                              </Badge>
                              <span className="text-[10px] text-muted-foreground">
                                {article.category}
                              </span>
                            </div>
                          </div>
                        </div>
                        <Button 
                          variant="ghost" 
                          size="icon" 
                          className="h-6 w-6 flex-shrink-0"
                          onClick={(e) => {
                            e.stopPropagation() // Prevent card click
                            window.open(article.url, '_blank', 'noopener,noreferrer')
                          }}
                          title="Open in new tab"
                        >
                          <ExternalLink className="h-3 w-3" />
                        </Button>
                      </div>
                    </CardContent>
                  </Card>
                  )
                })}
              </div>
            </div>
          )}
        </div>
      </ScrollArea>
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/components/common/error-boundary.tsx===
import React from 'react'

interface ErrorBoundaryState {
  hasError: boolean
  error?: Error
  errorInfo?: React.ErrorInfo
}

interface ErrorBoundaryProps {
  children: React.ReactNode
  fallback?: React.ComponentType<{ error?: Error }>
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log error to external service in production
    // For now, just update state
    
    this.setState({
      error,
      errorInfo
    })
  }

  render() {
    if (this.state.hasError) {
      
      // Custom fallback component
      if (this.props.fallback) {
        const FallbackComponent = this.props.fallback
        return <FallbackComponent error={this.state.error} />
      }

      // Default fallback UI
      return (
        <div className="h-full bg-background p-4 border border-red-200 rounded-lg">
          <div className="text-red-600 font-medium mb-2">
            Something went wrong in this component
          </div>
          <details className="text-sm text-gray-600">
            <summary className="cursor-pointer mb-2">Error Details</summary>
            <div className="bg-gray-50 p-2 rounded border text-xs font-mono">
              <div className="mb-2">
                <strong>Error:</strong> {this.state.error?.message}
              </div>
              <div className="mb-2">
                <strong>Stack:</strong>
                <pre className="whitespace-pre-wrap">{this.state.error?.stack}</pre>
              </div>
              {this.state.errorInfo && (
                <div>
                  <strong>Component Stack:</strong>
                  <pre className="whitespace-pre-wrap">{this.state.errorInfo.componentStack}</pre>
                </div>
              )}
            </div>
          </details>
          <button 
            onClick={() => this.setState({ hasError: false, error: undefined, errorInfo: undefined })}
            className="mt-2 px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
          >
            Try Again
          </button>
        </div>
      )
    }

    return this.props.children
  }
}

// Simple fallback component for Space Copilot
export const SpaceCopilotErrorFallback: React.FC<{ error?: Error }> = ({ error }) => (
  <div className="h-full bg-background p-4">
    <div className="text-red-600 font-medium mb-2">
      Space Copilot Error
    </div>
    <div className="text-sm text-gray-600 mb-2">
      The Space Copilot component encountered an error while processing intent data.
    </div>
    {error && (
      <div className="text-xs text-gray-500 bg-gray-50 p-2 rounded border">
        Error: {error.message}
      </div>
    )}
    <div className="mt-4 text-sm">
      <p>This usually happens when:</p>
      <ul className="list-disc list-inside mt-1 text-xs">
        <li>Intent data format is unexpected</li>
        <li>Network connection to embedded app failed</li>
        <li>JavaScript error in component logic</li>
      </ul>
    </div>
  </div>
)
===END FILE===

===BEGIN FILE: src/components/dialogs/end-call-confirmation.tsx===
import { PhoneOff, Phone, AlertTriangle } from 'lucide-react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '../ui/dialog'
import { Button } from '../ui/button'

interface EndCallConfirmationProps {
  isOpen: boolean
  onConfirm: () => void
  onCancel: () => void
  callerName?: string
  duration?: number
  incompleteActions?: number
  requireActionsCompletion?: boolean
}

export function EndCallConfirmation({ 
  isOpen, 
  onConfirm, 
  onCancel, 
  callerName,
  duration,
  incompleteActions = 0,
  requireActionsCompletion = false
}: EndCallConfirmationProps) {
  const formatDuration = (seconds?: number): string => {
    if (!seconds) return '0:00'
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  return (
    <Dialog open={isOpen} onOpenChange={onCancel}>
      <DialogContent className="sm:max-w-[420px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-3 text-xl">
            <div className="w-10 h-10 rounded-full bg-red-100 dark:bg-red-900/30 flex items-center justify-center">
              <PhoneOff className="h-5 w-5 text-red-600 dark:text-red-400" />
            </div>
            End Call
          </DialogTitle>
        </DialogHeader>
        
        <div className="space-y-4 pt-2">
          {/* Call Info */}
          <div className="bg-gray-50 dark:bg-gray-900/50 rounded-lg p-4 space-y-2">
            {callerName && (
              <div className="flex items-center justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">Caller</span>
                <span className="font-medium">{callerName}</span>
              </div>
            )}
            {duration !== undefined && (
              <div className="flex items-center justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">Duration</span>
                <span className="font-medium">{formatDuration(duration)}</span>
              </div>
            )}
          </div>
          
          {/* Actions Warning */}
          {requireActionsCompletion && incompleteActions > 0 && (
            <div className="bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4">
              <div className="flex items-center gap-3">
                <AlertTriangle className="h-5 w-5 text-yellow-600 dark:text-yellow-400 flex-shrink-0" />
                <div>
                  <p className="font-medium text-yellow-800 dark:text-yellow-200">
                    Incomplete Actions Required
                  </p>
                  <p className="text-sm text-yellow-700 dark:text-yellow-300 mt-1">
                    You have {incompleteActions} pending action{incompleteActions !== 1 ? 's' : ''} that must be completed before ending this call.
                  </p>
                </div>
              </div>
            </div>
          )}

          {/* Confirmation Message */}
          <div className="text-center py-2">
            <p className="text-gray-700 dark:text-gray-300">
              {requireActionsCompletion && incompleteActions > 0 
                ? 'Complete all required actions before ending the call.' 
                : 'Are you sure you want to end this call?'
              }
            </p>
            {(!requireActionsCompletion || incompleteActions === 0) && (
              <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                This action cannot be undone.
              </p>
            )}
          </div>
          
          {/* Action Buttons */}
          <div className="flex gap-3 pt-2">
            <Button
              variant="outline"
              onClick={onCancel}
              className="flex-1"
            >
              <Phone className="h-4 w-4 mr-2" />
              Continue Call
            </Button>
            <Button
              variant="destructive"
              onClick={onConfirm}
              disabled={requireActionsCompletion && incompleteActions > 0}
              className="flex-1"
            >
              <PhoneOff className="h-4 w-4 mr-2" />
              {requireActionsCompletion && incompleteActions > 0 ? 'Complete Actions First' : 'End Call'}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  )
}
===END FILE===

===BEGIN FILE: src/components/layout/column-layout.tsx===
import { useState, useEffect, useRef } from 'react'
import { GlobalHeader } from './global-header'
import { CustomerColumn } from '../columns/customer-column'
import { EmbeddedAppColumn } from '../columns/embedded-app-column'
import { SpaceCopilotColumn } from '../columns/space-copilot-column'
import { KMSColumn } from '../columns/kms-column'
import { ColumnHeader } from '../columns/column-header'
import { CollapsedColumnIndicator } from '../columns/collapsed-column-indicator'
import { MediaControlBar } from '../call-controls/media-control-bar'
import { ChatWindow } from '../chat/chat-window'
import { ResponseTemplates } from '../chat/response-templates'
import { TeamStatusGrid } from '../supervisor/team-status-grid'
import { Panel, PanelGroup } from 'react-resizable-panels'
import { ResizableHandle } from './resizable-widget-container'
import { useMediaQuery } from '../../hooks/use-media-query'
import { useAgentSettings } from '../../hooks/use-agent-settings'
import { useColumnLayout } from '../../hooks/use-column-layout'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../ui/tabs'
import { Sheet, SheetContent, SheetTitle } from '../ui/sheet'
import { Button } from '../ui/button'
import { MessageSquare, Menu, Bot, Grid3x3, X } from 'lucide-react'
import { cn } from '../../lib/utils'
import { useAgentStore } from '../../stores/agent-store'
import { useAgentStatusStore } from '../../stores/agent-status-store'
import { initializeMockData } from '../../utils/mock-data'
import { useRoleConfig } from '../../contexts/role-context'

export function ColumnLayout() {
  const [isKMSOpen, setIsKMSOpen] = useState(false)
  const [selectedArticleId, setSelectedArticleId] = useState<string>('')
  const [selectedArticle, setSelectedArticle] = useState<any>(null)
  const [copilotOpen, setCopilotOpen] = useState(false)
  const [customerOpen, setCustomerOpen] = useState(false)
  const [spaceCopilotOverlayOpen, setSpaceCopilotOverlayOpen] = useState(false)
  // Call state is now managed by Zustand store - components can subscribe directly
  // const [callState, setCallState] = useState<'idle' | 'incoming' | 'active' | 'ended'>('idle')
  const [embeddedAppsOpen, setEmbeddedAppsOpen] = useState(false) // New state for chat agents
  const { updateAgentData } = useAgentStore()
  const { settings } = useAgentSettings()
  const { currentRole } = useRoleConfig()
  
  // Debug: Log component mount/unmount and role changes
  useEffect(() => {
    return () => {
    }
  }, [])
  
  useEffect(() => {
  }, [currentRole])
  
  // Sample notifications disabled to prevent random notifications on login
  
  
  // Initialize layout hook first
  const { 
    layout, 
    updateColumn,
    applyLayout, 
    resetLayout, 
    getColumnClasses, 
    canManageColumns,
    hasMaximizedColumn 
  } = useColumnLayout()
  
  // No longer auto-expand KMS when opened - let user control the state
  // The column will remember its previous state (normal/collapsed/maximized)
  
  // No longer auto-expand Space Copilot - let user control the state
  // Users can manually expand/collapse the Space Copilot column as needed
  
  // Initialize with empty data - widgets will show watermarks until call starts
  useEffect(() => {
    // Start with empty agent data - widgets show watermarks
    updateAgentData({
      customer: null,
      sentiment: null,
      summary: null,
      intent: null,
      actions: [],
      transcript: [],
      knowledgeArticles: [],
      priority: null,
      metrics: null
    })
  }, [])
  
  // Handle call state changes and auto-close KMS if enabled - subscribe to Zustand store
  const callState = useAgentStatusStore(state => state.callState)
  useEffect(() => {
    if (callState === 'idle' && settings.interface.autoCloseKnowledgeOnCallEnd) {
      // Close KMS when call ends if setting is enabled
      setIsKMSOpen(false)
      setSelectedArticleId('')
      setSelectedArticle(null)
    }
  }, [callState, settings.interface.autoCloseKnowledgeOnCallEnd])
  
  // Responsive breakpoints - adjusted for better larger screen support
  const isMobile = useMediaQuery('(max-width: 768px)')
  const isTablet = useMediaQuery('(max-width: 1024px)')  // Reduced from 1280px
  const isLaptop = useMediaQuery('(max-width: 1440px)')  // Reduced from 1640px
  
  // Mobile: Tab layout
  if (isMobile) {
    return (
      <div className="h-screen flex flex-col bg-background">
        <GlobalHeader 
          onMenuClick={() => setCustomerOpen(true)}
          onCopilotClick={() => setCopilotOpen(true)}
          isMobile={true}
          isKMSOpen={isKMSOpen}
          setIsKMSOpen={setIsKMSOpen}
        />
        
        <Tabs defaultValue={isKMSOpen ? "kms" : "app"} className="flex-1 flex flex-col">
          <TabsList className={cn(
            "grid w-full rounded-none",
            isKMSOpen ? "grid-cols-4" : "grid-cols-3"
          )}>
            <TabsTrigger value="customer">Customer</TabsTrigger>
            <TabsTrigger value="app">Application</TabsTrigger>
            <TabsTrigger value="copilot">AI Assistant</TabsTrigger>
            {isKMSOpen && <TabsTrigger value="kms">Knowledge</TabsTrigger>}
          </TabsList>
          
          <TabsContent value="customer" className="flex-1 m-0">
            <CustomerColumn />
          </TabsContent>
          
          <TabsContent value="app" className="flex-1 m-0">
            <EmbeddedAppColumn />
          </TabsContent>
          
          <TabsContent value="copilot" className="flex-1 m-0">
            <SpaceCopilotColumn onKMSOpen={(articleId, article) => {
              setSelectedArticleId(articleId)
              setSelectedArticle(article)
              setIsKMSOpen(true)
            }} />
          </TabsContent>
          
          {isKMSOpen && (
            <TabsContent value="kms" className="flex-1 m-0">
              <KMSColumn onBack={() => setIsKMSOpen(false)} articleId={selectedArticleId} article={selectedArticle} />
            </TabsContent>
          )}
        </Tabs>
      </div>
    )
  }
  
  // Tablet: 2 columns + drawer
  if (isTablet) {
    return (
      <div className="h-screen flex flex-col bg-background">
        <GlobalHeader 
          onMenuClick={() => setCustomerOpen(true)}
          onCopilotClick={() => setCopilotOpen(true)}
          isKMSOpen={isKMSOpen}
          setIsKMSOpen={setIsKMSOpen}
        />
        
        <div className="flex-1 grid grid-cols-1 overflow-hidden">
          <EmbeddedAppColumn />
        </div>
        
        {/* Customer drawer */}
        <Sheet open={customerOpen} onOpenChange={setCustomerOpen}>
          <SheetContent side="left" className="w-[320px] p-0">
            <SheetTitle className="sr-only">Customer Information</SheetTitle>
            <CustomerColumn />
          </SheetContent>
        </Sheet>
        
        {/* Space Copilot drawer */}
        <Sheet open={copilotOpen} onOpenChange={setCopilotOpen}>
          <SheetContent side="right" className="w-[400px] p-0">
            <SheetTitle className="sr-only">Space Copilot AI Assistant</SheetTitle>
            <SpaceCopilotColumn onKMSOpen={(articleId, article) => {
              setSelectedArticleId(articleId)
              setSelectedArticle(article)
              setIsKMSOpen(true)
            }} />
          </SheetContent>
        </Sheet>
        
        {/* KMS drawer - opens separately */}
        <Sheet open={isKMSOpen} onOpenChange={setIsKMSOpen}>
          <SheetContent side="right" className="w-[600px] p-0 sm:max-w-[600px]">
            <SheetTitle className="sr-only">Knowledge Management System</SheetTitle>
            <KMSColumn onBack={() => setIsKMSOpen(false)} />
          </SheetContent>
        </Sheet>
      </div>
    )
  }
  
  // Desktop: Dynamic layout based on KMS state, user settings, and column states
  const canShow4Columns = !isLaptop // Only show 4 columns on larger screens (remove hasMaximizedColumn check)
  
  // When KMS is open, it ALWAYS gets its own column
  // Space Copilot goes to overlay if we can't fit all 4 columns
  const showSpaceCopilotColumn = settings.interface.spaceCopilotMode === 'column' && (!isKMSOpen || canShow4Columns)
  const forceSpaceCopilotOverlay = settings.interface.spaceCopilotMode === 'overlay' || (isKMSOpen && !canShow4Columns)
  
  
  // Determine visible columns based on collapse state
  const showCustomer = layout.customer !== 'collapsed'
  const showEmbedded = layout.embedded !== 'collapsed'
  const showKMS = isKMSOpen && layout.kms !== 'collapsed' // Show full KMS column only when open AND not collapsed
  const showSpaceCopilot = showSpaceCopilotColumn && layout.spaceCopilot !== 'collapsed' // Show full Space Copilot column
  const showChatAgentEmbedded = currentRole === 'chat_agent' && embeddedAppsOpen // Chat agent's embedded apps column
  
  // Calculate dynamic panel sizes based on visible columns
  const visiblePanelCount = [showCustomer, showEmbedded, showChatAgentEmbedded, showKMS, showSpaceCopilot].filter(Boolean).length
  
  // Dynamic size calculation to ensure panels add up to 100%
  const getPanelSizes = () => {
    if (visiblePanelCount === 0) return { customer: 25, embedded: 35, kms: 20, spaceCopilot: 20 }
    
    if (visiblePanelCount === 1) {
      return { customer: 100, embedded: 100, kms: 100, spaceCopilot: 100 }
    }
    
    if (visiblePanelCount === 2) {
      if (showCustomer && showEmbedded) return { customer: 40, embedded: 60, kms: 50, spaceCopilot: 50 }
      if (showCustomer && showKMS) return { customer: 60, embedded: 50, kms: 40, spaceCopilot: 50 }
      if (showCustomer && showSpaceCopilot) return { customer: 60, embedded: 50, kms: 50, spaceCopilot: 40 }
      if (showEmbedded && showKMS) return { customer: 50, embedded: 60, kms: 40, spaceCopilot: 50 }
      if (showEmbedded && showSpaceCopilot) return { customer: 50, embedded: 60, kms: 50, spaceCopilot: 40 }
      if (showKMS && showSpaceCopilot) return { customer: 50, embedded: 50, kms: 50, spaceCopilot: 50 }
      return { customer: 50, embedded: 50, kms: 50, spaceCopilot: 50 }
    }
    
    if (visiblePanelCount === 3) {
      if (!showCustomer) return { customer: 33, embedded: 40, kms: 30, spaceCopilot: 30 }
      if (!showEmbedded) return { customer: 40, embedded: 33, kms: 30, spaceCopilot: 30 }
      if (!showKMS) return { customer: 35, embedded: 40, kms: 33, spaceCopilot: 25 }
      if (!showSpaceCopilot) return { customer: 35, embedded: 40, kms: 25, spaceCopilot: 33 }
      return { customer: 33, embedded: 34, kms: 33, spaceCopilot: 33 }
    }
    
    // All 4 columns visible
    return { customer: 25, embedded: 35, kms: 20, spaceCopilot: 20 }
  }
  
  const panelSizes = getPanelSizes()
  
  return (
    <div className="h-screen flex flex-col bg-background relative">
      <GlobalHeader 
        onCopilotClick={() => setSpaceCopilotOverlayOpen(true)}
        showCopilotButton={forceSpaceCopilotOverlay}
        isKMSOpen={isKMSOpen}
        setIsKMSOpen={setIsKMSOpen}
      />
      
      <PanelGroup direction="horizontal" className="flex-1">
        {/* Collapsed Customer Indicator */}
        {layout.customer === 'collapsed' && (
          <CollapsedColumnIndicator
            title="Customer"
            columnId="customer"
            position="left"
            onExpand={() => updateColumn('customer', 'normal')}
            canManageColumns={canManageColumns}
          />
        )}
        
        {/* Column 1: Role-based content */}
        {showCustomer && (
          <Panel 
            defaultSize={panelSizes.customer}
            minSize={15}
            maxSize={40}
            className="flex"
          >
            <div className="w-full bg-background overflow-hidden flex flex-col">
              {/* Chat agents get response templates on left, others get their respective views */}
              {currentRole === 'chat_agent' ? (
                <ResponseTemplates />
              ) : (
                <>
                  <ColumnHeader
                    title={currentRole === 'manager' ? 'Team Status' : 'Customer Info'}
                    columnId="customer"
                    currentState={layout.customer}
                    canManageColumns={canManageColumns}
                    onStateChange={(state) => updateColumn('customer', state)}
                    onResetAll={resetLayout}
                  />
                  <div className="flex-1 overflow-hidden">
                    {currentRole === 'manager' ? (
                      <TeamStatusGrid />
                    ) : (
                      <CustomerColumn />
                    )}
                  </div>
                </>
              )}
            </div>
          </Panel>
        )}
        
        {/* Resize Handle between Customer and Embedded */}
        {showCustomer && showEmbedded && (
          <ResizableHandle direction="horizontal" />
        )}
        
        {/* Collapsed Embedded Indicator */}
        {layout.embedded === 'collapsed' && (
          <CollapsedColumnIndicator
            title="Application"
            columnId="embedded"
            position="left"
            onExpand={() => updateColumn('embedded', 'normal')}
            canManageColumns={canManageColumns}
          />
        )}
        
        {/* Column 2: Role-based content */}
        {showEmbedded && (
          <Panel 
            defaultSize={panelSizes.embedded}
            minSize={20}
            maxSize={60}
            className="flex"
          >
            <div className="w-full bg-background overflow-hidden flex flex-col">
              {/* Media bar for call agents only */}
              {currentRole === 'agent' && <MediaControlBar />}
              {/* Role-based content */}
              {currentRole === 'chat_agent' ? (
                <>
                  {/* Chat window with button to open embedded apps */}
                  <div className="flex-1 overflow-hidden flex flex-col">
                    <div className="flex items-center justify-between px-4 py-2 border-b">
                      <h3 className="text-sm font-semibold">Customer Chat</h3>
                      {!embeddedAppsOpen && (
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => setEmbeddedAppsOpen(true)}
                          className="text-xs"
                        >
                          <Grid3x3 className="h-3 w-3 mr-1" />
                          Open Tools
                        </Button>
                      )}
                    </div>
                    <div className="flex-1 overflow-hidden">
                      <ChatWindow />
                    </div>
                  </div>
                </>
              ) : (
                <div className="flex-1 overflow-hidden">
                  <EmbeddedAppColumn />
                </div>
              )}
            </div>
          </Panel>
        )}
        
        {/* Resize Handle between Embedded and EmbeddedApps (for chat agents) */}
        {showEmbedded && currentRole === 'chat_agent' && embeddedAppsOpen && (
          <ResizableHandle direction="horizontal" />
        )}
        
        {/* Column 3: Embedded Apps for Chat Agents (when open) */}
        {currentRole === 'chat_agent' && embeddedAppsOpen && (
          <Panel 
            defaultSize={25}
            minSize={20}
            maxSize={40}
            className="flex"
          >
            <div className="w-full bg-background overflow-hidden flex flex-col">
              <div className="flex items-center justify-between px-4 py-2 border-b">
                <h3 className="text-sm font-semibold">Customer Tools</h3>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setEmbeddedAppsOpen(false)}
                  className="h-6 w-6 p-0"
                >
                  <X className="h-4 w-4" />
                </Button>
              </div>
              <div className="flex-1 overflow-hidden">
                <EmbeddedAppColumn />
              </div>
            </div>
          </Panel>
        )}
        
        {/* Resize Handle between Embedded/EmbeddedApps and KMS/SpaceCopilot */}
        {((showEmbedded && !currentRole.includes('chat_agent')) || (currentRole === 'chat_agent' && embeddedAppsOpen)) && (showKMS || showSpaceCopilot) && (
          <ResizableHandle direction="horizontal" />
        )}
        
        {/* Collapsed KMS Indicator */}
        {isKMSOpen && layout.kms === 'collapsed' && (
          <CollapsedColumnIndicator
            title="Knowledge"
            columnId="kms"
            position="right"
            onExpand={() => updateColumn('kms', 'normal')}
            canManageColumns={canManageColumns}
          />
        )}
        
        {/* Column 3: KMS (when open) */}
        {showKMS && (
          <Panel 
            defaultSize={panelSizes.kms}
            minSize={15}
            maxSize={35}
            className="flex"
          >
            <div className="w-full bg-background overflow-hidden flex flex-col">
              <ColumnHeader
                title="Knowledge Management"
                columnId="kms"
                currentState={layout.kms}
                canManageColumns={canManageColumns}
                onStateChange={(state) => updateColumn('kms', state)}
              />
              <div className="flex-1 overflow-hidden">
                <KMSColumn onBack={() => setIsKMSOpen(false)} articleId={selectedArticleId} article={selectedArticle} />
              </div>
            </div>
          </Panel>
        )}
        
        {/* Resize Handle between KMS and Space Copilot */}
        {showKMS && showSpaceCopilot && (
          <ResizableHandle direction="horizontal" />
        )}
        
        {/* Collapsed Space Copilot Indicator */}
        {showSpaceCopilotColumn && layout.spaceCopilot === 'collapsed' && (
          <CollapsedColumnIndicator
            title="Space Copilot"
            columnId="spaceCopilot"
            position="right"
            onExpand={() => updateColumn('spaceCopilot', 'normal')}
            canManageColumns={canManageColumns}
          />
        )}
        
        {/* Column 4 (or 3 if no KMS): Space Copilot */}
        {showSpaceCopilot && (
          <Panel 
            defaultSize={panelSizes.spaceCopilot}
            minSize={15}
            maxSize={35}
            className="flex"
          >
            <div className="w-full bg-background overflow-hidden flex flex-col">
              <ColumnHeader
                title="Space Copilot"
                columnId="spaceCopilot"
                currentState={layout.spaceCopilot}
                canManageColumns={canManageColumns}
                onStateChange={(state) => updateColumn('spaceCopilot', state)}
                showAIBadge={true}
              />
              <div className="flex-1 overflow-hidden">
                <SpaceCopilotColumn onKMSOpen={(articleId, article) => {
                      setSelectedArticleId(articleId)
                  setSelectedArticle(article)
                  setIsKMSOpen(true)
                }} />
              </div>
            </div>
          </Panel>
        )}
      </PanelGroup>

      {/* Space Copilot Overlay (when in overlay mode or forced due to space constraints) */}
      {forceSpaceCopilotOverlay && (
        <>
          {/* Overlay Toggle Button */}
          {!spaceCopilotOverlayOpen && (
            <Button
              onClick={() => setSpaceCopilotOverlayOpen(true)}
              className={cn(
                "fixed z-50 p-3 rounded-full shadow-lg bg-primary text-primary-foreground hover:bg-primary/90 icon-button-red-hover",
                "top-1/2 -translate-y-1/2",
                settings.interface.spaceCopilotOverlayPosition === 'right' 
                  ? "right-4" 
                  : "left-4"
              )}
            >
              <Bot className="h-5 w-5" />
            </Button>
          )}

          {/* Overlay Panel */}
          <Sheet 
            open={spaceCopilotOverlayOpen} 
            onOpenChange={setSpaceCopilotOverlayOpen}
          >
            <SheetContent 
              side={settings.interface.spaceCopilotOverlayPosition}
              className="w-[640px] p-0 sm:max-w-[640px]"
            >
              <SheetTitle className="sr-only">
                Space Copilot AI Assistant
              </SheetTitle>
              <SpaceCopilotColumn onKMSOpen={(articleId, article) => {
                  setSelectedArticleId(articleId)
                setSelectedArticle(article)
                setIsKMSOpen(true)
              }} />
            </SheetContent>
          </Sheet>
        </>
      )}
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/components/layout/global-header.tsx===
import { useState, useEffect } from 'react'
import { Button } from '../ui/button'
import { Input } from '../ui/input'
import { Avatar, AvatarFallback, AvatarImage } from '../ui/avatar'
import { Badge } from '../ui/badge'
import { 
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '../ui/dropdown-menu'
import { 
  Search, 
  Grid3x3, 
  Bell, 
  MessageSquare, 
  MoreVertical,
  Menu,
  LogOut,
  Settings,
  User,
  Loader2,
  Phone,
  Users,
  Headphones,
  Shield,
  TrendingUp
} from 'lucide-react'
import { useAuth } from '../../contexts/auth-context'
import { useAppLogout } from '../../hooks/use-app-logout'
import { useNavigate } from 'react-router-dom'
import { GlobalSearchOverlay } from '../search/global-search-overlay'
import { SettingsPanel } from '../settings-panel'
import { useRoleConfig, type UserRole } from '../../contexts/role-context'
import { LayoutManagerOverlay } from './layout-manager-overlay'
import { useAgentStatusStore } from '../../stores/agent-status-store'
import { cn } from '../../lib/utils'
import { NotificationCenter } from '../notifications/notification-center'

interface GlobalHeaderProps {
  onMenuClick?: () => void
  onCopilotClick?: () => void
  isMobile?: boolean
  showCopilotButton?: boolean
  isKMSOpen?: boolean
  setIsKMSOpen?: (open: boolean) => void
}

export function GlobalHeader({ onMenuClick, onCopilotClick, isMobile, showCopilotButton = false, isKMSOpen = false, setIsKMSOpen }: GlobalHeaderProps) {
  const [isSearchOpen, setIsSearchOpen] = useState(false)
  const [isSettingsOpen, setIsSettingsOpen] = useState(false)
  const [isLayoutManagerOpen, setIsLayoutManagerOpen] = useState(false)
  
  const { user } = useAuth()
  const { logout } = useAppLogout()
  const navigate = useNavigate()
  const { currentRole, isLoading, updateRole, canAccessFeature } = useRoleConfig()
  const agentStatus = useAgentStatusStore(state => state.status)
  const afterCallWorkSecondsRemaining = useAgentStatusStore(state => state.afterCallWorkSecondsRemaining)
  const doNotDisturbSecondsRemaining = useAgentStatusStore(state => state.doNotDisturbSecondsRemaining)
  
  // Generate initials from user name
  const getUserInitials = (name: string) => {
    return name
      .split(' ')
      .map(part => part.charAt(0))
      .join('')
      .toUpperCase()
      .slice(0, 2) // Only take first 2 initials
  }
  
  // Keyboard shortcut for layout manager
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'l') {
        e.preventDefault()
        setIsLayoutManagerOpen(prev => !prev)
      }
    }
    
    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [])
  
  const handleLogout = () => {
    logout()
  }
  
  return (
    <>
      <header className="sticky top-0 z-50 h-14 border-b bg-background">
        <div className="flex h-full items-center px-4">
          {/* Left: Logo + Environment + Role */}
          <div className="flex items-center gap-2">
            {isMobile && onMenuClick && (
              <Button variant="ghost" size="icon" onClick={onMenuClick} className="md:hidden icon-button-red-hover">
                <Menu className="h-5 w-5" />
              </Button>
            )}
            <img 
              src="/hsbc-logo.png" 
              alt="HSBC" 
              className="h-8 w-auto"
            />
            {/* Role Badge */}
            <Badge 
              variant={currentRole === 'manager' ? 'default' : 'outline'} 
              className={cn(
                "text-xs flex items-center gap-1 hidden sm:flex",
                currentRole === 'agent' && "border-blue-500 text-blue-700 bg-blue-50",
                currentRole === 'chat_agent' && "border-green-500 text-green-700 bg-green-50",
                currentRole === 'supervisor' && "bg-orange-600 text-white border-orange-600",
                currentRole === 'manager' && "bg-purple-600 text-white border-purple-600"
              )}
            >
              {currentRole === 'agent' && <Headphones className="h-3 w-3" />}
              {currentRole === 'chat_agent' && <MessageSquare className="h-3 w-3" />}
              {currentRole === 'supervisor' && <Shield className="h-3 w-3" />}
              {currentRole === 'manager' && <TrendingUp className="h-3 w-3" />}
              {currentRole === 'agent' ? 'Voice Agent' : 
               currentRole === 'chat_agent' ? 'Chat Agent' : 
               currentRole === 'supervisor' ? 'Supervisor' :
               'Manager'}
            </Badge>
          </div>
          
          {/* Center: Search (hidden on mobile) */}
          <div className="flex-1 max-w-xl mx-auto px-4 hidden md:block">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input 
                placeholder="Search customers, tools, knowledge..." 
                className="pl-9 h-9 w-full"
                onFocus={() => setIsSearchOpen(true)}
              />
            </div>
          </div>
          
          {/* Right: Actions */}
          <div className="flex items-center gap-2">
            {/* Search on mobile */}
            <Button 
              variant="ghost" 
              size="icon" 
              className="md:hidden icon-button-red-hover"
              onClick={() => setIsSearchOpen(true)}
            >
              <Search className="h-4 w-4" />
            </Button>
            
            {/* Layout Manager */}
            {!isMobile && setIsKMSOpen && (
              <Button 
                variant="ghost" 
                size="icon" 
                className="h-9 w-9 hidden lg:flex icon-button-red-hover"
                onClick={() => setIsLayoutManagerOpen(true)}
              >
                <Grid3x3 className="h-4 w-4" />
              </Button>
            )}
            
            {/* User Avatar with Role Dropdown */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" className="h-9 w-9 icon-button-red-hover">
                  <Avatar className="h-8 w-8 border border-gray-300">
                    <AvatarImage src={(user as any)?.avatar} />
                    <AvatarFallback className="text-xs bg-white text-foreground">
                      {user?.name ? getUserInitials(user.name) : 'AG'}
                    </AvatarFallback>
                  </Avatar>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className="w-56">
                <DropdownMenuLabel>
                  <div className="flex flex-col space-y-1">
                    <p className="text-sm font-medium leading-none">{user?.name || 'John Smith'}</p>
                    <p className="text-xs leading-none text-muted-foreground">
                      {user?.email || 'john.smith@hsbc.com'}
                    </p>
                    <div className="flex items-center gap-1.5 mt-1.5">
                      <div className={cn(
                        "w-2 h-2 rounded-full",
                        agentStatus === 'available' && "bg-green-500",
                        agentStatus === 'on-call' && "bg-blue-500",
                        agentStatus === 'break' && "bg-yellow-500",
                        agentStatus === 'offline' && "bg-gray-500",
                        agentStatus === 'after-call-work' && "bg-purple-500",
                        agentStatus === 'do-not-disturb' && "bg-orange-500"
                      )} />
                      <div className="flex flex-col">
                        <span className="text-xs font-medium">
                          {agentStatus === 'available' ? 'Online' : 
                           agentStatus === 'on-call' ? 'On Call' :
                           agentStatus === 'break' ? 'On Break' :
                           agentStatus === 'offline' ? 'Offline' :
                           agentStatus === 'after-call-work' ? 'After Call Work' :
                           agentStatus === 'do-not-disturb' ? 'Do Not Disturb' : 'Unknown'}
                        </span>
                        {agentStatus === 'after-call-work' && afterCallWorkSecondsRemaining > 0 && (
                          <span className="text-[10px] text-muted-foreground">
                            {afterCallWorkSecondsRemaining}s remaining
                          </span>
                        )}
                        {agentStatus === 'do-not-disturb' && doNotDisturbSecondsRemaining > 0 && (
                          <span className="text-[10px] text-muted-foreground">
                            {Math.floor(doNotDisturbSecondsRemaining / 60)}:{(doNotDisturbSecondsRemaining % 60).toString().padStart(2, '0')} remaining
                          </span>
                        )}
                      </div>
                    </div>
                  </div>
                </DropdownMenuLabel>
                <DropdownMenuSeparator />
                
                <DropdownMenuLabel className="text-xs text-muted-foreground">
                  Role {isLoading && <Loader2 className="h-3 w-3 animate-spin inline ml-1" />}
                </DropdownMenuLabel>
                <DropdownMenuRadioGroup 
                  value={currentRole} 
                  onValueChange={(value) => updateRole(value as UserRole)}
                >
                  <DropdownMenuRadioItem value="agent" className="flex items-center gap-2">
                    <Headphones className="h-4 w-4" />
                    Voice Agent
                  </DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="chat_agent" className="flex items-center gap-2">
                    <MessageSquare className="h-4 w-4" />
                    Chat Agent
                  </DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="supervisor" className="flex items-center gap-2">
                    <Shield className="h-4 w-4" />
                    Supervisor
                  </DropdownMenuRadioItem>
                  <DropdownMenuRadioItem value="manager" className="flex items-center gap-2">
                    <TrendingUp className="h-4 w-4" />
                    Manager
                  </DropdownMenuRadioItem>
                </DropdownMenuRadioGroup>
                
                <DropdownMenuSeparator />
                
              </DropdownMenuContent>
            </DropdownMenu>
            
            {/* Space Copilot (only in overlay mode) */}
            {showCopilotButton && (
              <Button 
                variant="ghost" 
                size="icon" 
                className="h-9 w-9 icon-button-red-hover"
                onClick={onCopilotClick}
                title="Open Space Copilot"
              >
                <MessageSquare className="h-4 w-4" />
              </Button>
            )}
            
            {/* Notifications */}
            <NotificationCenter />
            
            {/* More Options */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" className="h-9 w-9 icon-button-red-hover">
                  <MoreVertical className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className="w-48">
                {canAccessFeature('settingsAccess') && (
                  <DropdownMenuItem onSelect={() => {
                    setIsSettingsOpen(true)
                  }}>
                    <Settings className="mr-2 h-4 w-4" />
                    Settings
                  </DropdownMenuItem>
                )}
                
                <DropdownMenuItem onSelect={handleLogout}>
                  <LogOut className="mr-2 h-4 w-4" />
                  Logout
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </header>
      
      {/* Global Search Overlay */}
      <GlobalSearchOverlay 
        isOpen={isSearchOpen} 
        onClose={() => setIsSearchOpen(false)} 
      />
      
      {/* Settings Panel */}
      <SettingsPanel 
        isOpen={isSettingsOpen} 
        onClose={() => setIsSettingsOpen(false)} 
      />
      
      {/* Layout Manager Overlay */}
      {setIsKMSOpen && (
        <LayoutManagerOverlay 
          open={isLayoutManagerOpen} 
          onOpenChange={setIsLayoutManagerOpen}
          isKMSOpen={isKMSOpen}
          setIsKMSOpen={setIsKMSOpen}
        />
      )}
    </>
  )
}
===END FILE===

===BEGIN FILE: src/components/layout/layout-manager-overlay.tsx===
import { useState, useEffect } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '../ui/dialog'
import type { ColumnLayoutState } from '../../hooks/use-column-layout'
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { Input } from '../ui/input'
import { Label } from '../ui/label'
import { Switch } from '../ui/switch'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../ui/tabs'
import { ScrollArea } from '../ui/scroll-area'
import { Separator } from '../ui/separator'
import { 
  Grid3x3, 
  Save, 
  FolderOpen,
  Layout,
  Maximize2,
  RotateCcw,
  Lock,
  Unlock,
  Download,
  Upload,
  Trash2,
  Check,
  Monitor,
  Users,
  Bot,
  FileText,
  PanelLeft,
  X,
  Sparkles,
  Zap,
  Target,
  Columns3,
  Eye,
  EyeOff
} from 'lucide-react'
import { useColumnLayout } from '../../hooks/use-column-layout'
import { cn } from '../../lib/utils'
import { toast } from 'sonner'

interface SavedLayout {
  id: string
  name: string
  layout: any
  timestamp: number
  description?: string
}

interface LayoutManagerOverlayProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  isKMSOpen: boolean
  setIsKMSOpen: (open: boolean) => void
}

// Visual preview component for layout
function LayoutPreview({ layout, isKMSOpen }: { layout: any, isKMSOpen: boolean }) {
  const getColumnWidth = (state: string) => {
    switch (state) {
      case 'collapsed': return 'w-2'
      case 'maximized': return 'flex-1'
      case 'normal':
      default: return 'w-16'
    }
  }

  return (
    <div className="h-32 bg-muted/30 rounded-lg p-3 flex gap-1">
      {/* Customer */}
      <div className={cn(
        "bg-blue-500/20 rounded border border-blue-500/40 flex items-center justify-center text-xs",
        getColumnWidth(layout.customer)
      )}>
        {layout.customer !== 'collapsed' && <Users className="h-4 w-4 text-blue-500" />}
      </div>
      
      {/* Embedded */}
      <div className={cn(
        "bg-green-500/20 rounded border border-green-500/40 flex items-center justify-center text-xs",
        getColumnWidth(layout.embedded)
      )}>
        {layout.embedded !== 'collapsed' && <Monitor className="h-4 w-4 text-green-500" />}
      </div>
      
      {/* KMS (if open) */}
      {isKMSOpen && (
        <div className={cn(
          "bg-purple-500/20 rounded border border-purple-500/40 flex items-center justify-center text-xs",
          getColumnWidth(layout.kms)
        )}>
          {layout.kms !== 'collapsed' && <FileText className="h-4 w-4 text-purple-500" />}
        </div>
      )}
      
      {/* Space Copilot */}
      <div className={cn(
        "bg-amber-500/20 rounded border border-amber-500/40 flex items-center justify-center text-xs",
        getColumnWidth(layout.spaceCopilot)
      )}>
        {layout.spaceCopilot !== 'collapsed' && <Bot className="h-4 w-4 text-amber-500" />}
      </div>
    </div>
  )
}

export function LayoutManagerOverlay({ 
  open, 
  onOpenChange, 
  isKMSOpen, 
  setIsKMSOpen 
}: LayoutManagerOverlayProps) {
  const { 
    layout, 
    updateColumn,
    applyLayout, 
    resetLayout,
    canManageColumns 
  } = useColumnLayout()
  
  const [savedLayouts, setSavedLayouts] = useState<SavedLayout[]>([])
  const [isLayoutLocked, setIsLayoutLocked] = useState(false)
  const [saveName, setSaveName] = useState('')
  const [saveDescription, setSaveDescription] = useState('')
  const [showSaveDialog, setShowSaveDialog] = useState(false)

  // Load saved layouts from localStorage
  useEffect(() => {
    const saved = localStorage.getItem('ccaas-saved-layouts')
    if (saved) {
      setSavedLayouts(JSON.parse(saved))
    }
    
    const locked = localStorage.getItem('ccaas-layout-locked')
    setIsLayoutLocked(locked === 'true')
  }, [])

  // Quick layout presets
  const presets = [
    {
      id: 'standard',
      name: 'Standard View',
      description: 'All columns visible in normal size',
      icon: <Layout className="h-5 w-5" />,
      color: 'bg-blue-500/10 hover:bg-blue-500/20 border-blue-500/30',
      layout: { customer: 'normal', embedded: 'normal', spaceCopilot: 'normal', kms: 'normal' }
    },
    {
      id: 'focus',
      name: 'Focus Mode',
      description: 'Maximize application for focused work',
      icon: <Target className="h-5 w-5" />,
      color: 'bg-green-500/10 hover:bg-green-500/20 border-green-500/30',
      layout: { customer: 'collapsed', embedded: 'maximized', spaceCopilot: 'collapsed', kms: 'collapsed' }
    },
    {
      id: 'customer-focus',
      name: 'Customer Focus',
      description: 'Emphasize customer information',
      icon: <Users className="h-5 w-5" />,
      color: 'bg-purple-500/10 hover:bg-purple-500/20 border-purple-500/30',
      layout: { customer: 'maximized', embedded: 'collapsed', spaceCopilot: 'collapsed', kms: 'collapsed' }
    },
    {
      id: 'ai-mode',
      name: 'AI Assistant',
      description: 'Maximize Space Copilot for AI assistance',
      icon: <Sparkles className="h-5 w-5" />,
      color: 'bg-amber-500/10 hover:bg-amber-500/20 border-amber-500/30',
      layout: { customer: 'normal', embedded: 'normal', spaceCopilot: 'maximized', kms: 'collapsed' }
    },
    {
      id: 'compact',
      name: 'Compact View',
      description: 'Essential columns only',
      icon: <Columns3 className="h-5 w-5" />,
      color: 'bg-gray-500/10 hover:bg-gray-500/20 border-gray-500/30',
      layout: { customer: 'normal', embedded: 'normal', spaceCopilot: 'collapsed', kms: 'collapsed' }
    },
    {
      id: 'knowledge',
      name: 'Knowledge Mode',
      description: 'Focus on knowledge base and AI',
      icon: <FileText className="h-5 w-5" />,
      color: 'bg-indigo-500/10 hover:bg-indigo-500/20 border-indigo-500/30',
      layout: { customer: 'collapsed', embedded: 'normal', spaceCopilot: 'normal', kms: 'normal' },
      kmsOpen: true
    }
  ]

  const applyPreset = (preset: typeof presets[0]) => {
    if (isLayoutLocked || !canManageColumns) {
      toast.error('Layout is locked or you don\'t have permission')
      return
    }

    // Apply the complete layout at once using the new applyLayout function
    applyLayout(preset.layout as Partial<ColumnLayoutState>)
    
    // Handle KMS state
    if (preset.kmsOpen !== undefined) {
      setIsKMSOpen(preset.kmsOpen)
    } else if (preset.id !== 'knowledge') {
      // Close KMS for non-knowledge presets
      setIsKMSOpen(false)
    }
    
    toast.success(`Applied ${preset.name}`)
  }

  // Save current layout
  const saveCurrentLayout = () => {
    if (!saveName.trim()) {
      toast.error('Please enter a layout name')
      return
    }

    const newLayout: SavedLayout = {
      id: Date.now().toString(),
      name: saveName,
      description: saveDescription,
      layout: { ...layout, isKMSOpen },
      timestamp: Date.now()
    }

    const updated = [...savedLayouts, newLayout]
    setSavedLayouts(updated)
    localStorage.setItem('ccaas-saved-layouts', JSON.stringify(updated))
    
    setSaveName('')
    setSaveDescription('')
    setShowSaveDialog(false)
    toast.success(`Layout "${saveName}" saved`)
  }

  // Load saved layout
  const loadLayout = (saved: SavedLayout) => {
    if (isLayoutLocked || !canManageColumns) {
      toast.error('Layout is locked or you don\'t have permission')
      return
    }

    // Filter out non-column properties and apply the layout
    const columnLayout = Object.entries(saved.layout)
      .filter(([key]) => key !== 'isKMSOpen')
      .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {})
    
    applyLayout(columnLayout)
    setIsKMSOpen(saved.layout.isKMSOpen || false)
    
    toast.success(`Loaded "${saved.name}"`)
  }

  // Delete saved layout
  const deleteLayout = (id: string) => {
    const updated = savedLayouts.filter(l => l.id !== id)
    setSavedLayouts(updated)
    localStorage.setItem('ccaas-saved-layouts', JSON.stringify(updated))
    toast.success('Layout deleted')
  }

  // Toggle layout lock
  const toggleLayoutLock = () => {
    const newState = !isLayoutLocked
    setIsLayoutLocked(newState)
    localStorage.setItem('ccaas-layout-locked', String(newState))
    toast.success(newState ? 'Layout locked' : 'Layout unlocked')
  }

  // Export layouts
  const exportLayouts = () => {
    const data = {
      layouts: savedLayouts,
      currentLayout: layout,
      isKMSOpen,
      exportDate: new Date().toISOString()
    }
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `ccaas-layouts-${Date.now()}.json`
    a.click()
    URL.revokeObjectURL(url)
    
    toast.success('Layouts exported')
  }

  // Import layouts
  const importLayouts = () => {
    const input = document.createElement('input')
    input.type = 'file'
    input.accept = '.json'
    input.onchange = (e: any) => {
      const file = e.target.files[0]
      if (!file) return
      
      const reader = new FileReader()
      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target?.result as string)
          if (data.layouts) {
            setSavedLayouts(data.layouts)
            localStorage.setItem('ccaas-saved-layouts', JSON.stringify(data.layouts))
            toast.success('Layouts imported successfully')
          }
        } catch (error) {
          toast.error('Failed to import layouts')
        }
      }
      reader.readAsText(file)
    }
    input.click()
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-[95vw] sm:max-w-2xl lg:max-w-4xl max-h-[90vh] p-0 overflow-hidden">
        <DialogHeader className="p-6 pb-0">
          <div className="flex items-center justify-between">
            <div>
              <DialogTitle className="text-2xl flex items-center gap-2">
                <Grid3x3 className="h-6 w-6" />
                Layout Manager
              </DialogTitle>
              <DialogDescription>
                Customize your workspace layout for optimal productivity
              </DialogDescription>
            </div>
            {isLayoutLocked && (
              <Badge variant="secondary" className="text-xs">
                <Lock className="h-3 w-3 mr-1" />
                Locked
              </Badge>
            )}
          </div>
        </DialogHeader>

        <Tabs defaultValue="presets" className="flex-1">
          <TabsList className="w-full rounded-none border-b px-6">
            <TabsTrigger value="presets" className="gap-2">
              <Zap className="h-4 w-4" />
              Quick Presets
            </TabsTrigger>
            <TabsTrigger value="custom" className="gap-2">
              <Columns3 className="h-4 w-4" />
              Custom Layout
            </TabsTrigger>
            <TabsTrigger value="saved" className="gap-2">
              <FolderOpen className="h-4 w-4" />
              Saved Layouts
              {savedLayouts.length > 0 && (
                <Badge variant="secondary" className="ml-1 text-xs">
                  {savedLayouts.length}
                </Badge>
              )}
            </TabsTrigger>
          </TabsList>

          <ScrollArea className="h-[400px] sm:h-[450px] lg:h-[500px]">
            <TabsContent value="presets" className="p-6 space-y-6">
              <div>
                <h3 className="text-sm font-medium mb-3">Current Layout Preview</h3>
                <LayoutPreview layout={layout} isKMSOpen={isKMSOpen} />
              </div>

              <Separator />

              <div>
                <h3 className="text-sm font-medium mb-3">Quick Layout Presets</h3>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {presets.map((preset) => (
                    <button
                      key={preset.id}
                      onClick={() => applyPreset(preset)}
                      disabled={isLayoutLocked || !canManageColumns}
                      className={cn(
                        "p-4 rounded-lg border-2 transition-all text-left group",
                        preset.color,
                        (isLayoutLocked || !canManageColumns) && "opacity-50 cursor-not-allowed"
                      )}
                    >
                      <div className="flex items-start gap-3">
                        <div className="p-2 rounded-lg bg-background">
                          {preset.icon}
                        </div>
                        <div className="flex-1">
                          <h4 className="font-medium text-sm">{preset.name}</h4>
                          <p className="text-xs text-muted-foreground mt-1">
                            {preset.description}
                          </p>
                        </div>
                      </div>
                      <div className="mt-3">
                        <LayoutPreview layout={preset.layout} isKMSOpen={preset.kmsOpen || false} />
                      </div>
                    </button>
                  ))}
                </div>
              </div>
            </TabsContent>

            <TabsContent value="custom" className="p-6 space-y-6">
              <div>
                <h3 className="text-sm font-medium mb-3">Current Layout Preview</h3>
                <LayoutPreview layout={layout} isKMSOpen={isKMSOpen} />
              </div>

              <Separator />

              <div className="space-y-4">
                <h3 className="text-sm font-medium">Column Visibility</h3>
                
                <div className="space-y-3">
                  <div className="flex items-center justify-between p-3 rounded-lg bg-muted/50">
                    <div className="flex items-center gap-3">
                      <Users className="h-4 w-4 text-blue-500" />
                      <Label htmlFor="customer-toggle" className="text-sm font-medium">
                        Customer Info
                      </Label>
                    </div>
                    <Switch
                      id="customer-toggle"
                      checked={layout.customer !== 'collapsed'}
                      onCheckedChange={(checked) => updateColumn('customer', checked ? 'normal' : 'collapsed')}
                      disabled={isLayoutLocked || !canManageColumns}
                    />
                  </div>

                  <div className="flex items-center justify-between p-3 rounded-lg bg-muted/50">
                    <div className="flex items-center gap-3">
                      <Monitor className="h-4 w-4 text-green-500" />
                      <Label htmlFor="embedded-toggle" className="text-sm font-medium">
                        Application
                      </Label>
                    </div>
                    <Switch
                      id="embedded-toggle"
                      checked={layout.embedded !== 'collapsed'}
                      onCheckedChange={(checked) => updateColumn('embedded', checked ? 'normal' : 'collapsed')}
                      disabled={isLayoutLocked || !canManageColumns}
                    />
                  </div>

                  <div className="flex items-center justify-between p-3 rounded-lg bg-muted/50">
                    <div className="flex items-center gap-3">
                      <Bot className="h-4 w-4 text-amber-500" />
                      <Label htmlFor="copilot-toggle" className="text-sm font-medium">
                        Space Copilot
                      </Label>
                    </div>
                    <Switch
                      id="copilot-toggle"
                      checked={layout.spaceCopilot !== 'collapsed'}
                      onCheckedChange={(checked) => updateColumn('spaceCopilot', checked ? 'normal' : 'collapsed')}
                      disabled={isLayoutLocked || !canManageColumns}
                    />
                  </div>

                  <div className="flex items-center justify-between p-3 rounded-lg bg-muted/50">
                    <div className="flex items-center gap-3">
                      <FileText className="h-4 w-4 text-purple-500" />
                      <Label htmlFor="kms-toggle" className="text-sm font-medium">
                        Knowledge Base
                      </Label>
                    </div>
                    <Switch
                      id="kms-toggle"
                      checked={isKMSOpen}
                      onCheckedChange={setIsKMSOpen}
                      disabled={isLayoutLocked || !canManageColumns}
                    />
                  </div>
                </div>
              </div>

              <Separator />

              <div className="flex gap-3">
                <Button
                  onClick={() => setShowSaveDialog(true)}
                  disabled={!canManageColumns}
                  className="flex-1"
                >
                  <Save className="h-4 w-4 mr-2" />
                  Save Current Layout
                </Button>
                <Button
                  onClick={resetLayout}
                  variant="outline"
                  disabled={isLayoutLocked || !canManageColumns}
                  className="flex-1"
                >
                  <RotateCcw className="h-4 w-4 mr-2" />
                  Reset to Default
                </Button>
              </div>
            </TabsContent>

            <TabsContent value="saved" className="p-6 space-y-6">
              {savedLayouts.length === 0 ? (
                <div className="text-center py-12">
                  <FolderOpen className="h-12 w-12 mx-auto text-muted-foreground/50" />
                  <h3 className="mt-4 text-sm font-medium">No saved layouts</h3>
                  <p className="mt-2 text-sm text-muted-foreground">
                    Save your current layout to quickly switch between different configurations
                  </p>
                  <Button
                    onClick={() => setShowSaveDialog(true)}
                    className="mt-4"
                    disabled={!canManageColumns}
                  >
                    <Save className="h-4 w-4 mr-2" />
                    Save Current Layout
                  </Button>
                </div>
              ) : (
                <div className="space-y-3">
                  {savedLayouts.map((saved) => (
                    <div
                      key={saved.id}
                      className="p-4 rounded-lg border bg-card hover:bg-muted/50 transition-colors"
                    >
                      <div className="flex items-start justify-between gap-4">
                        <div className="flex-1">
                          <h4 className="font-medium">{saved.name}</h4>
                          {saved.description && (
                            <p className="text-sm text-muted-foreground mt-1">
                              {saved.description}
                            </p>
                          )}
                          <p className="text-xs text-muted-foreground mt-2">
                            Saved {new Date(saved.timestamp).toLocaleDateString()}
                          </p>
                        </div>
                        <div className="flex gap-2">
                          <Button
                            size="sm"
                            onClick={() => loadLayout(saved)}
                            disabled={isLayoutLocked || !canManageColumns}
                          >
                            Apply
                          </Button>
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => deleteLayout(saved.id)}
                            className="text-destructive hover:text-destructive"
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </div>
                      <div className="mt-3">
                        <LayoutPreview 
                          layout={saved.layout} 
                          isKMSOpen={saved.layout.isKMSOpen || false} 
                        />
                      </div>
                    </div>
                  ))}
                </div>
              )}

              <Separator />

              <div className="flex gap-3">
                <Button
                  onClick={exportLayouts}
                  variant="outline"
                  className="flex-1"
                >
                  <Download className="h-4 w-4 mr-2" />
                  Export All
                </Button>
                <Button
                  onClick={importLayouts}
                  variant="outline"
                  className="flex-1"
                >
                  <Upload className="h-4 w-4 mr-2" />
                  Import
                </Button>
              </div>
            </TabsContent>
          </ScrollArea>
        </Tabs>

        <div className="p-4 sm:p-6 pt-0 flex flex-col sm:flex-row items-start sm:items-center justify-between border-t gap-2 sm:gap-0">
          <Button
            onClick={toggleLayoutLock}
            variant="outline"
            size="sm"
            className="w-full sm:w-auto"
          >
            {isLayoutLocked ? (
              <>
                <Unlock className="h-4 w-4 mr-2" />
                Unlock Layout
              </>
            ) : (
              <>
                <Lock className="h-4 w-4 mr-2" />
                Lock Layout
              </>
            )}
          </Button>
          
          <div className="text-xs text-muted-foreground text-center sm:text-right">
            Use <kbd className="px-1 py-0.5 rounded bg-muted text-xs">Ctrl</kbd>+<kbd className="px-1 py-0.5 rounded bg-muted text-xs">L</kbd> to open this dialog
          </div>
        </div>
      </DialogContent>

      {/* Save Dialog */}
      <Dialog open={showSaveDialog} onOpenChange={setShowSaveDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Save Current Layout</DialogTitle>
            <DialogDescription>
              Give your layout a name and optional description
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            <div>
              <Label htmlFor="layout-name">Layout Name</Label>
              <Input
                id="layout-name"
                placeholder="e.g., Customer Service Mode"
                value={saveName}
                onChange={(e) => setSaveName(e.target.value)}
                className="mt-1"
              />
            </div>
            <div>
              <Label htmlFor="layout-description">Description (Optional)</Label>
              <Input
                id="layout-description"
                placeholder="e.g., Optimized for handling customer inquiries"
                value={saveDescription}
                onChange={(e) => setSaveDescription(e.target.value)}
                className="mt-1"
              />
            </div>
            <div className="flex gap-3">
              <Button
                onClick={saveCurrentLayout}
                disabled={!saveName.trim()}
                className="flex-1"
              >
                <Save className="h-4 w-4 mr-2" />
                Save Layout
              </Button>
              <Button
                onClick={() => {
                  setShowSaveDialog(false)
                  setSaveName('')
                  setSaveDescription('')
                }}
                variant="outline"
                className="flex-1"
              >
                Cancel
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </Dialog>
  )
}
===END FILE===

===BEGIN FILE: src/components/layout/resizable-widget-container.tsx===
import { ReactNode } from 'react'
import { PanelResizeHandle } from 'react-resizable-panels'
import { GripVertical, GripHorizontal } from 'lucide-react'
import { cn } from '../../lib/utils'

interface ResizableWidgetContainerProps {
  children: ReactNode
  widgetId: string
  className?: string
  direction?: 'horizontal' | 'vertical'
  showHandle?: boolean
  handleClassName?: string
  minSize?: number
  maxSize?: number
  defaultSize?: number
  onResize?: (size: number) => void
}

export function ResizableWidgetContainer({
  children,
  widgetId,
  className,
  direction = 'vertical',
  showHandle = true,
  handleClassName,
  minSize = 10,
  maxSize = 90,
  defaultSize = 50,
  onResize
}: ResizableWidgetContainerProps) {
  return (
    <>
      <div 
        className={cn(
          "relative h-full w-full overflow-hidden",
          className
        )}
        data-widget-id={widgetId}
      >
        {children}
      </div>
      {showHandle && (
        <ResizableHandle 
          direction={direction}
          className={handleClassName}
        />
      )}
    </>
  )
}

export function ResizableHandle({ 
  direction = 'vertical',
  className,
  withHandle = true 
}: { 
  direction?: 'horizontal' | 'vertical'
  className?: string
  withHandle?: boolean
}) {
  return (
    <PanelResizeHandle
      className={cn(
        "group relative flex items-center justify-center",
        direction === 'vertical' 
          ? "h-1 w-full cursor-row-resize" 
          : "h-full w-1 cursor-col-resize",
        "bg-border/50 hover:bg-border transition-colors",
        "data-[resize-handle-state=drag]:bg-primary/20",
        className
      )}
    >
      {withHandle && (
        <div className={cn(
          "absolute z-10 flex items-center justify-center rounded-sm",
          "bg-border opacity-0 group-hover:opacity-100 transition-opacity",
          "group-data-[resize-handle-state=drag]:opacity-100",
          direction === 'vertical' 
            ? "h-4 w-8 -translate-y-1/2" 
            : "h-8 w-4 -translate-x-1/2"
        )}>
          {direction === 'vertical' ? (
            <GripHorizontal className="h-3 w-3 text-muted-foreground" />
          ) : (
            <GripVertical className="h-3 w-3 text-muted-foreground" />
          )}
        </div>
      )}
    </PanelResizeHandle>
  )
}
===END FILE===

===BEGIN FILE: src/components/notifications/notification-center.css===
/* Notification Center Animations */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutRight {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes pulseScale {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
}

.notification-enter {
  animation: slideInRight 0.3s ease-out forwards;
}

.notification-exit {
  animation: slideOutRight 0.3s ease-out forwards;
}

.notification-badge-pulse {
  animation: pulseScale 2s ease-in-out infinite;
}

/* Smooth hover transitions */
.notification-item {
  transition: all 0.2s ease;
}

/* Unread indicator animation */
.unread-indicator {
  animation: fadeIn 0.5s ease-out;
}

/* Bell icon shake animation for new notifications */
@keyframes bellShake {
  0%, 100% {
    transform: rotate(0deg);
  }
  10%, 30% {
    transform: rotate(-10deg);
  }
  20%, 40% {
    transform: rotate(10deg);
  }
  50% {
    transform: rotate(0deg);
  }
}

.bell-shake {
  animation: bellShake 0.5s ease-in-out;
}

/* Smooth scrollbar styling */
.notification-scroll::-webkit-scrollbar {
  width: 4px;
}

.notification-scroll::-webkit-scrollbar-track {
  background: transparent;
}

.notification-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 2px;
}

.notification-scroll::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.2);
}

/* Dark mode support */
.dark .notification-scroll::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.1);
}

.dark .notification-scroll::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.2);
}

/* Enhanced notification item hover effects */
.notification-item-hover {
  transition: all 0.2s ease-in-out;
}

.notification-item-hover:hover {
  background: rgb(254 242 242) !important; /* bg-red-50 equivalent but stronger */
  border-left: 3px solid rgb(239 68 68); /* red-500 left border */
  transform: translateX(2px);
  box-shadow: 0 2px 8px rgba(239, 68, 68, 0.1);
}

.dark .notification-item-hover:hover {
  background: rgba(127, 29, 29, 0.4) !important; /* Stronger red background for dark mode */
  border-left: 3px solid rgb(248 113 113); /* red-400 for dark mode */
  box-shadow: 0 2px 8px rgba(248, 113, 113, 0.2);
}

/* Enhanced notification text contrast */
.notification-item-hover:hover .notification-title {
  color: rgb(17 24 39) !important; /* gray-900 */
  font-weight: 600;
}

.notification-item-hover:hover .notification-description {
  color: rgb(55 65 81) !important; /* gray-700 */
}

.notification-item-hover:hover .notification-timestamp {
  color: rgb(75 85 99) !important; /* gray-600 */
}

.dark .notification-item-hover:hover .notification-title {
  color: rgb(249 250 251) !important; /* gray-50 */
}

.dark .notification-item-hover:hover .notification-description {
  color: rgb(209 213 219) !important; /* gray-300 */
}

.dark .notification-item-hover:hover .notification-timestamp {
  color: rgb(156 163 175) !important; /* gray-400 */
}
===END FILE===

===BEGIN FILE: src/components/notifications/notification-center.tsx===
import { useEffect, useRef, useState } from 'react'
import { 
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from '../ui/dropdown-menu'
import './notification-center.css'
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { ScrollArea } from '../ui/scroll-area'
import { Separator } from '../ui/separator'
import { 
  Bell, 
  BookOpen, 
  Bot, 
  AlertCircle, 
  CheckCircle,
  Info,
  X,
  CheckCheck,
  Trash2,
  ExternalLink,
  Sparkles
} from 'lucide-react'
import { useNotificationStore, type NotificationType } from '../../stores/notification-store'
import { cn } from '../../lib/utils'
import { formatDistanceToNow } from 'date-fns'

export function NotificationCenter() {
  const { 
    notifications, 
    unreadCount, 
    isOpen,
    markAsRead, 
    markAllAsRead, 
    dismissNotification,
    clearAll,
    toggleOpen,
    setOpen
  } = useNotificationStore()
  
  const dropdownRef = useRef<HTMLDivElement>(null)
  const [shouldShake, setShouldShake] = useState(false)
  const previousCountRef = useRef(unreadCount)
  
  // Trigger bell shake animation when new notifications arrive
  useEffect(() => {
    if (unreadCount > previousCountRef.current && !isOpen) {
      setShouldShake(true)
      setTimeout(() => setShouldShake(false), 500)
    }
    previousCountRef.current = unreadCount
  }, [unreadCount, isOpen])
  
  // Auto-mark as read when viewing
  useEffect(() => {
    if (isOpen) {
      const timer = setTimeout(() => {
        // Mark visible unread notifications as read after 2 seconds
        notifications
          .filter(n => !n.read)
          .slice(0, 5)
          .forEach(n => markAsRead(n.id))
      }, 2000)
      
      return () => clearTimeout(timer)
    }
  }, [isOpen, notifications, markAsRead])
  
  const getNotificationIcon = (type: NotificationType) => {
    switch (type) {
      case 'knowledge':
        return <BookOpen className="h-4 w-4" />
      case 'ai_coaching':
        return <Bot className="h-4 w-4" />
      case 'alert':
        return <AlertCircle className="h-4 w-4" />
      case 'success':
        return <CheckCircle className="h-4 w-4" />
      default:
        return <Info className="h-4 w-4" />
    }
  }
  
  const getNotificationColor = (type: NotificationType) => {
    switch (type) {
      case 'knowledge':
        return 'text-blue-600 bg-blue-50/60 dark:bg-blue-900/10'
      case 'ai_coaching':
        return 'text-purple-600 bg-purple-50/60 dark:bg-purple-900/10'
      case 'alert':
        return 'text-red-600 bg-red-50/60 dark:bg-red-900/10'
      case 'success':
        return 'text-green-600 bg-green-50/60 dark:bg-green-900/10'
      default:
        return 'text-gray-600 bg-gray-50/60 dark:bg-gray-900/10'
    }
  }
  
  const groupedNotifications = notifications.reduce((acc, notif) => {
    if (!acc[notif.type]) {
      acc[notif.type] = []
    }
    acc[notif.type].push(notif)
    return acc
  }, {} as Record<NotificationType, typeof notifications>)
  
  const typeLabels: Record<NotificationType, string> = {
    knowledge: 'Knowledge Articles',
    ai_coaching: 'AI Coaching',
    alert: 'Alerts',
    success: 'Success',
    system: 'System'
  }
  
  return (
    <DropdownMenu open={isOpen} onOpenChange={setOpen}>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          size="icon" 
          className="h-9 w-9 relative icon-button-red-hover"
          onClick={() => toggleOpen()}
        >
          <Bell className={cn(
            "h-4 w-4 transition-all",
            shouldShake && "bell-shake",
            unreadCount > 0 && "text-blue-600 dark:text-blue-400"
          )} />
          {unreadCount > 0 && (
            <span className={cn(
              "absolute -top-1 -right-1 h-4 w-4 rounded-full bg-destructive text-destructive-foreground text-[10px] font-medium flex items-center justify-center animate-in zoom-in-50 duration-200",
              shouldShake && "notification-badge-pulse"
            )}>
              {unreadCount > 9 ? '9+' : unreadCount}
            </span>
          )}
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownMenuContent 
        align="end" 
        className="w-[420px] p-0"
        ref={dropdownRef}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-4 py-3 border-b">
          <div className="flex items-center gap-2">
            <h3 className="font-semibold text-sm">Notifications</h3>
            {unreadCount > 0 && (
              <Badge variant="secondary" className="text-xs px-1.5 py-0">
                {unreadCount} new
              </Badge>
            )}
          </div>
          <div className="flex items-center gap-1">
            {unreadCount > 0 && (
              <Button
                variant="ghost"
                size="sm"
                className="h-7 text-xs"
                onClick={(e) => {
                  e.stopPropagation()
                  markAllAsRead()
                }}
              >
                <CheckCheck className="h-3 w-3 mr-1" />
                Mark all read
              </Button>
            )}
            {notifications.length > 0 && (
              <Button
                variant="ghost"
                size="sm"
                className="h-7 text-xs"
                onClick={(e) => {
                  e.stopPropagation()
                  clearAll()
                }}
              >
                <Trash2 className="h-3 w-3 mr-1" />
                Clear
              </Button>
            )}
          </div>
        </div>
        
        {/* Notifications List */}
        <ScrollArea className="h-[400px] notification-scroll">
          {notifications.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-12 text-muted-foreground">
              <Bell className="h-8 w-8 mb-2 opacity-50" />
              <p className="text-sm font-medium">No notifications</p>
              <p className="text-xs opacity-60">You're all caught up!</p>
            </div>
          ) : (
            <div className="py-2">
              {Object.entries(groupedNotifications).map(([type, items]) => (
                <div key={type} className="mb-2">
                  <div className="px-4 py-1.5">
                    <p className="text-xs font-medium text-muted-foreground">
                      {typeLabels[type as NotificationType]}
                    </p>
                  </div>
                  {items.map((notification, index) => (
                    <div
                      key={notification.id}
                      className={cn(
                        "relative group px-4 py-3 notification-item-hover cursor-pointer",
                        !notification.read && "bg-accent/20 border-l-2 border-blue-400",
                        index < items.length - 1 && "border-b border-border/50"
                      )}
                      onClick={() => {
                        if (!notification.read) {
                          markAsRead(notification.id)
                        }
                        if (notification.actionCallback) {
                          notification.actionCallback()
                          setOpen(false)
                        }
                      }}
                    >
                      {/* Unread indicator */}
                      {!notification.read && (
                        <div className="absolute left-1 top-1/2 -translate-y-1/2 w-1 h-1 bg-blue-500 rounded-full" />
                      )}
                      
                      <div className="flex items-start gap-3">
                        <div className={cn(
                          "rounded-lg p-1.5 mt-0.5",
                          getNotificationColor(notification.type)
                        )}>
                          {notification.icon === 'sparkles' ? (
                            <Sparkles className="h-3.5 w-3.5 animate-pulse" />
                          ) : (
                            getNotificationIcon(notification.type)
                          )}
                        </div>
                        
                        <div className="flex-1 min-w-0">
                          <div className="flex items-start justify-between gap-2">
                            <div className="flex-1">
                              <p className={cn(
                                "text-sm notification-title transition-colors",
                                !notification.read && "font-medium"
                              )}>
                                {notification.title}
                              </p>
                              {notification.description && (
                                <p className="text-xs text-muted-foreground notification-description mt-0.5 line-clamp-2 transition-colors">
                                  {notification.description}
                                </p>
                              )}
                              <p className="text-[10px] text-muted-foreground notification-timestamp mt-1 transition-colors">
                                {formatDistanceToNow(new Date(notification.timestamp), { addSuffix: true })}
                              </p>
                            </div>
                            
                            {/* Actions */}
                            <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                              {notification.actionLabel && (
                                <Button
                                  variant="ghost"
                                  size="icon"
                                  className="h-6 w-6"
                                  onClick={(e) => {
                                    e.stopPropagation()
                                    if (notification.actionCallback) {
                                      notification.actionCallback()
                                      setOpen(false)
                                    }
                                  }}
                                >
                                  <ExternalLink className="h-3 w-3" />
                                </Button>
                              )}
                              <Button
                                variant="ghost"
                                size="icon"
                                className="h-6 w-6"
                                onClick={(e) => {
                                  e.stopPropagation()
                                  dismissNotification(notification.id)
                                }}
                              >
                                <X className="h-3 w-3" />
                              </Button>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              ))}
            </div>
          )}
        </ScrollArea>
        
        {/* Footer */}
        {notifications.length > 0 && (
          <>
            <Separator />
            <div className="px-4 py-2 text-center">
              <Button
                variant="ghost"
                size="sm"
                className="text-xs text-muted-foreground hover:text-foreground"
                onClick={() => {
                  // Could open a full notifications page
                  setOpen(false)
                }}
              >
                View all notifications
              </Button>
            </div>
          </>
        )}
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
===END FILE===

===BEGIN FILE: src/components/search/embedded-app-search-overlay.tsx===
import { useRef, useEffect } from 'react'
import { X, Monitor, Zap, Search } from 'lucide-react'
import { Button } from '../ui/button'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../ui/tabs'
import { SearchInput } from './search-input'
import { EmbeddedAppSearchResults } from './embedded-app-search-results'
import { SearchResultsOptimized as SearchResults } from './search-results-optimized'
import { useEmbeddedAppSearch } from '../../hooks/use-embedded-app-search'
import { useSearchAPI } from '../../hooks/use-search-api'
import { useKeyboardShortcut } from '../../hooks/use-keyboard-shortcut'
import { type EmbeddedAppSearchResult } from '../../services/embedded-app-search.service'

interface EmbeddedAppSearchOverlayProps {
  isOpen: boolean
  onClose: () => void
  onAppLaunch?: (app: EmbeddedAppSearchResult & { context?: any }) => void
  defaultTab?: 'apps' | 'knowledge'
}

export function EmbeddedAppSearchOverlay({ 
  isOpen, 
  onClose, 
  onAppLaunch,
  defaultTab = 'apps'
}: EmbeddedAppSearchOverlayProps) {
  // Early return before any hooks to avoid hook-order issues when closed
  if (!isOpen) return null

  const inputRef = useRef<HTMLInputElement>(null)
  const overlayRef = useRef<HTMLDivElement>(null)
  
  // Embedded app search
  const {
    query: appQuery,
    setQuery: setAppQuery,
    results: appResults,
    loading: appLoading,
    suggestedApps,
    launchApp,
    clearSearch: clearAppSearch,
    hasResults: hasAppResults,
    hasQuery: hasAppQuery,
    userContext
  } = useEmbeddedAppSearch()

  // General knowledge search
  const {
    query: knowledgeQuery,
    setQuery: setKnowledgeQuery,
    results: knowledgeResults,
    loading: knowledgeLoading,
    clearSearch: clearKnowledgeSearch,
    hasResults: hasKnowledgeResults,
    hasQuery: hasKnowledgeQuery
  } = useSearchAPI()

  // Handle ESC key to close overlay
  useKeyboardShortcut(
    { key: 'Escape' },
    () => {
      if (isOpen) {
        onClose()
      }
    },
    [isOpen, onClose]
  )

  // Focus the input when overlay opens
  useEffect(() => {
    if (isOpen && inputRef.current) {
      // Small delay to ensure the overlay is fully rendered
      const timer = setTimeout(() => {
        inputRef.current?.focus()
      }, 100)
      return () => clearTimeout(timer)
    }
  }, [isOpen])

  // Handle backdrop click to close
  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === overlayRef.current) {
      onClose()
    }
  }

  // Handle app launch
  const handleAppLaunch = async (app: EmbeddedAppSearchResult) => {
    try {
      const appWithContext = await launchApp(app)
      onAppLaunch?.(appWithContext)
      onClose() // Close overlay after launching app
    } catch (error) {
      // Failed to launch app
      // Still try to launch without context
      onAppLaunch?.(app)
      onClose()
    }
  }

  // Handle result click for knowledge base
  const handleKnowledgeResultClick = () => {
    // Optional: Close overlay after clicking a knowledge result
    // onClose()
  }

  // Clear all searches when closing overlay
  const handleClose = () => {
    clearAppSearch()
    clearKnowledgeSearch()
    onClose()
  }

  // Handle tab change - sync queries
  const handleTabChange = (tab: string) => {
    if (tab === 'apps') {
      setAppQuery(knowledgeQuery)
    } else {
      setKnowledgeQuery(appQuery)
    }
  }

  // Current tab values
  const currentQuery = defaultTab === 'apps' ? appQuery : knowledgeQuery
  const currentLoading = defaultTab === 'apps' ? appLoading : knowledgeLoading
  const setCurrentQuery = defaultTab === 'apps' ? setAppQuery : setKnowledgeQuery
  const clearCurrentSearch = defaultTab === 'apps' ? clearAppSearch : clearKnowledgeSearch

  return (
    <div
      ref={overlayRef}
      className="fixed inset-0 z-50 flex items-start justify-center pt-[8vh] px-4"
      style={{ 
        backgroundColor: 'rgba(0, 0, 0, 0.4)',
        backdropFilter: 'blur(4px)',
        WebkitBackdropFilter: 'blur(4px)'
      }}
      onClick={handleBackdropClick}
    >
      {/* Search Container */}
      <div className="w-full max-w-4xl bg-white/95 dark:bg-gray-900/95 backdrop-blur-md rounded-2xl shadow-2xl border border-gray-200 dark:border-gray-700 overflow-hidden animate-in slide-in-from-top-4 duration-300">
        
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-primary/10 rounded-lg">
              <Search className="h-5 w-5 text-primary" />
            </div>
            <div>
              <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
                Enhanced Search
              </h2>
              <p className="text-sm text-muted-foreground">
                Find embedded applications and knowledge resources with context awareness
              </p>
            </div>
          </div>
          
          <div className="flex items-center gap-2">
            {userContext.role && (
              <div className="text-xs text-muted-foreground px-2 py-1 bg-gray-100 dark:bg-gray-800 rounded">
                {userContext.role} • {userContext.customerTier}
              </div>
            )}
            <Button
              variant="ghost"
              size="sm"
              onClick={handleClose}
              className="h-8 w-8 p-0 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-full"
            >
              <X className="h-4 w-4" />
            </Button>
          </div>
        </div>

        {/* Search Input */}
        <div className="p-6 pb-4 border-b border-gray-200 dark:border-gray-700">
          <SearchInput
            ref={inputRef}
            value={currentQuery}
            onChange={setCurrentQuery}
            onClear={clearCurrentSearch}
            loading={currentLoading}
            placeholder="Search for embedded apps, procedures, knowledge articles..."
          />
          
          {/* Quick tip */}
          <div className="mt-3 text-xs text-muted-foreground">
            <span className="font-medium">Search examples:</span> "credit card management", "fraud detection", "customer profile", "mortgage calculator"
          </div>
        </div>

        {/* Tabs for different search types */}
        <Tabs defaultValue={defaultTab} onValueChange={handleTabChange}>
          <TabsList className="w-full justify-start rounded-none border-b dark:border-gray-700 h-12 p-0">
            <TabsTrigger 
              value="apps" 
              className="px-6 py-3 data-[state=active]:bg-background rounded-none border-r dark:border-gray-700"
            >
              <Monitor className="h-4 w-4 mr-2" />
              Embedded Apps
              {hasAppResults && (
                <span className="ml-2 px-2 py-0.5 text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded-full">
                  {appResults.length}
                </span>
              )}
            </TabsTrigger>
            <TabsTrigger 
              value="knowledge" 
              className="px-6 py-3 data-[state=active]:bg-background rounded-none"
            >
              <Zap className="h-4 w-4 mr-2" />
              Knowledge Base
              {hasKnowledgeResults && (
                <span className="ml-2 px-2 py-0.5 text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 rounded-full">
                  {knowledgeResults.length}
                </span>
              )}
            </TabsTrigger>
          </TabsList>
          
          <div className="h-[60vh]">
            <TabsContent value="apps" className="h-full p-6 mt-0">
              <EmbeddedAppSearchResults
                results={appResults}
                loading={appLoading}
                query={appQuery}
                onAppLaunch={handleAppLaunch}
                suggestedApps={suggestedApps}
                showCategories={true}
              />
            </TabsContent>
            
            <TabsContent value="knowledge" className="h-full p-6 mt-0">
              <SearchResults
                results={knowledgeResults}
                loading={knowledgeLoading}
                query={knowledgeQuery}
                onResultClick={handleKnowledgeResultClick}
              />
            </TabsContent>
          </div>
        </Tabs>

        {/* Footer with keyboard shortcuts and context info */}
        <div className="flex items-center justify-between px-6 py-3 bg-gray-50 dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-4 text-xs text-muted-foreground">
            <div className="flex items-center gap-1">
              <kbd className="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded text-xs">↵</kbd>
              <span>to open</span>
            </div>
            <div className="flex items-center gap-1">
              <kbd className="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded text-xs">ESC</kbd>
              <span>to close</span>
            </div>
            <div className="flex items-center gap-1">
              <kbd className="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded text-xs">Tab</kbd>
              <span>to switch</span>
            </div>
          </div>
          
          <div className="flex items-center gap-4 text-xs text-muted-foreground">
            {userContext.currentIntent && (
              <div className="flex items-center gap-1">
                <span>Intent:</span>
                <span className="font-medium">{userContext.currentIntent}</span>
              </div>
            )}
            {(hasAppResults || hasKnowledgeResults) && (
              <div>
                {hasAppResults && appResults.length} apps{hasAppResults && hasKnowledgeResults && ', '}
                {hasKnowledgeResults && knowledgeResults.length} articles
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/components/search/embedded-app-search-results.tsx===
import { 
  Search,
  Monitor,
  Play,
  AppWindow,
  Star,
  Loader2
} from 'lucide-react'
import { useState, useMemo, useEffect, useCallback } from 'react'
import { Button } from '../ui/button'
import { type EmbeddedAppSearchResult } from '../../services/embedded-app-search.service'
import '../../styles/search-animations.css'

interface EmbeddedAppSearchResultsProps {
  results: EmbeddedAppSearchResult[]
  loading?: boolean
  query?: string
  onAppLaunch?: (app: EmbeddedAppSearchResult) => void
  showCategories?: boolean
  suggestedApps?: EmbeddedAppSearchResult[]
}

// Removed category icons and colors for cleaner, minimal design

const SkeletonResult = () => (
  <div className="p-3 rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 animate-pulse">
    <div className="flex items-start gap-3">
      <div className="w-4 h-4 bg-gray-200 dark:bg-gray-700 rounded"></div>
      <div className="flex-1 space-y-2">
        <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4"></div>
        <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
      </div>
      <div className="h-6 w-12 bg-gray-200 dark:bg-gray-700 rounded"></div>
    </div>
  </div>
)

const EmbeddedAppResultItem = ({ 
  app, 
  query, 
  onAppLaunch 
}: { 
  app: EmbeddedAppSearchResult
  query?: string
  onAppLaunch?: (app: EmbeddedAppSearchResult) => void
}) => {
  const handleLaunch = () => {
    onAppLaunch?.(app)
  }

  // Highlight matching text
  const highlightText = (text: string, searchQuery: string) => {
    if (!text) return ''
    if (!searchQuery) return text
    
    const regex = new RegExp(`(${searchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi')
    const parts = text.split(regex)
    return parts.map((part, index) => (
      index % 2 === 1 ? (
        <mark key={index} className="bg-yellow-200 dark:bg-yellow-800 px-1 rounded">{part}</mark>
      ) : (
        <span key={index}>{part}</span>
      )
    ))
  }

  return (
    <div 
      className="search-result-card group p-3 rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-750 cursor-pointer"
      onClick={handleLaunch}
    >
      <div className="flex items-start gap-3">
        {/* Simple app icon */}
        <div className="mt-0.5 text-gray-400">
          <AppWindow className="h-4 w-4" />
        </div>
        
        <div className="flex-1 min-w-0">
          {/* Title and category on same line */}
          <div className="flex items-start justify-between gap-2 mb-1">
            <h3 className="font-medium text-gray-900 dark:text-gray-100 text-sm group-hover:text-red-600 dark:group-hover:text-red-400 transition-colors">
              {highlightText(app.title, query || '')}
            </h3>
            <div className="flex items-center gap-2 shrink-0">
              <span className="text-xs text-gray-500 dark:text-gray-400">
                {app.category.replace(/_/g, ' ')}
              </span>
              <Button
                onClick={(e) => {
                  e.stopPropagation()
                  handleLaunch()
                }}
                size="sm"
                variant="ghost"
                className="h-5 px-1.5 text-xs hover:bg-gray-100 dark:hover:bg-gray-700 opacity-0 group-hover:opacity-100 transition-opacity"
              >
                <Play className="h-3 w-3" />
              </Button>
            </div>
          </div>
          
          {/* Description */}
          <p className="text-xs text-gray-600 dark:text-gray-400 leading-relaxed line-clamp-2">
            {highlightText(app.description || '', query || '')}
          </p>
        </div>
      </div>
    </div>
  )
}

export function EmbeddedAppSearchResults({ 
  results, 
  loading, 
  query, 
  onAppLaunch,
  showCategories = true,
  suggestedApps = []
}: EmbeddedAppSearchResultsProps) {
  const maxVisible = 10
  const [visibleCount, setVisibleCount] = useState(maxVisible)
  const [isLoadingMore, setIsLoadingMore] = useState(false)
  
  // Reset visible count when query changes
  useEffect(() => {
    setVisibleCount(maxVisible)
  }, [query, maxVisible])
  
  // Slice results for performance
  const visibleResults = useMemo(
    () => results.slice(0, visibleCount),
    [results, visibleCount]
  )
  
  // Handle infinite scroll
  const handleScroll = useCallback((e: Event) => {
    const target = e.target as HTMLElement
    if (!target) return
    
    const scrollBottom = target.scrollTop + target.clientHeight
    const scrollThreshold = target.scrollHeight - 100 // 100px from bottom
    
    if (scrollBottom >= scrollThreshold && visibleCount < results.length && !isLoadingMore) {
      setIsLoadingMore(true)
      setTimeout(() => {
        setVisibleCount(prev => Math.min(prev + 10, results.length))
        setIsLoadingMore(false)
      }, 300)
    }
  }, [visibleCount, results.length, isLoadingMore])
  
  // Attach scroll listener to container
  useEffect(() => {
    // Small delay to ensure DOM is ready
    const timer = setTimeout(() => {
      const scrollContainer = document.querySelector('.max-h-\\[50vh\\].overflow-y-auto')
      
      if (scrollContainer) {
        scrollContainer.addEventListener('scroll', handleScroll)
        return () => scrollContainer.removeEventListener('scroll', handleScroll)
      }
    }, 100)
    
    return () => clearTimeout(timer)
  }, [handleScroll])
  if (loading) {
    return (
      <div className="space-y-3">
        {Array.from({ length: 4 }, (_, i) => (
          <SkeletonResult key={i} />
        ))}
      </div>
    )
  }

  // Show suggested apps when no query
  if (!query && suggestedApps.length > 0) {
    return (
      <div className="space-y-3">
        <h4 className="font-medium text-gray-900 dark:text-gray-100 flex items-center gap-2">
          <Star className="h-4 w-4 text-gray-400" />
          <span>Suggested Services</span>
        </h4>
        <div className="space-y-3">
          {suggestedApps.map((app) => (
            <EmbeddedAppResultItem
              key={app.id}
              app={app}
              query=""
              onAppLaunch={onAppLaunch}
            />
          ))}
        </div>
      </div>
    )
  }

  if (results.length === 0 && query) {
    return (
      <div className="text-center py-8">
        <Search className="h-10 w-10 text-muted-foreground mx-auto mb-3" />
        <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-2">
          No services found
        </h3>
        <p className="text-muted-foreground">
          Try adjusting your search terms or browse our service categories
        </p>
      </div>
    )
  }

  if (results.length === 0) {
    return (
      <div className="text-center py-8">
        <Monitor className="h-10 w-10 text-muted-foreground mx-auto mb-3" />
        <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-2">
          Search Banking Services
        </h3>
        <p className="text-muted-foreground">
          Find and launch specialized tools for customer service tasks
        </p>
      </div>
    )
  }

  // Group results by category if enabled
  const groupedResults = showCategories 
    ? visibleResults.reduce((acc, result) => {
        const category = result.category
        if (!acc[category]) {
          acc[category] = []
        }
        acc[category].push(result)
        return acc
      }, {} as Record<string, EmbeddedAppSearchResult[]>)
    : { 'Services': visibleResults }

  return (
    <div className="space-y-6" style={{ transform: 'translateZ(0)' }}>
        <div className="flex items-center justify-between">
          <p className="text-sm text-muted-foreground">
            Found {results.length} service{results.length !== 1 ? 's' : ''} {query && `for "${query}"`}
            {results.length > visibleCount && ` (showing ${visibleCount})`}
          </p>
        </div>
        
        {Object.entries(groupedResults).map(([category, categoryResults]) => (
          <div key={category} className="space-y-3">
            {Object.keys(groupedResults).length > 1 && (
              <h4 className="font-medium text-gray-900 dark:text-gray-100 flex items-center gap-2">
                <AppWindow className="h-4 w-4 text-gray-400" />
                <span>{category.replace(/_/g, ' ')}</span>
                <span className="ml-auto text-xs text-gray-500 dark:text-gray-400">
                  {categoryResults.length}
                </span>
              </h4>
            )}
            
            <div className="space-y-3">
              {categoryResults.map((app) => (
                <EmbeddedAppResultItem
                  key={app.id}
                  app={app}
                  query={query}
                  onAppLaunch={onAppLaunch}
                />
              ))}
            </div>
          </div>
        ))}
        
        {/* Infinite scroll loading indicator */}
        {results.length > visibleCount && (
          <div className="h-10 flex items-center justify-center">
            {isLoadingMore && (
              <div className="flex items-center gap-2 text-sm text-gray-500">
                <Loader2 className="h-4 w-4 animate-spin" />
                <span>Loading more services...</span>
              </div>
            )}
          </div>
        )}
        
        {/* Show count indicator */}
        {visibleCount === results.length && results.length > maxVisible && (
          <div className="text-center py-3 text-sm text-gray-500">
            All {results.length} services loaded
          </div>
        )}
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/components/search/global-search-overlay.tsx===
import { useRef, useEffect, useState } from 'react'
import { X, Search, Monitor, FileText } from 'lucide-react'
import { Button } from '../ui/button'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../ui/tabs'
import { SearchInput } from './search-input'
import { SearchResultsOptimized as SearchResults } from './search-results-optimized'
import { EmbeddedAppSearchResults } from './embedded-app-search-results'
import { useSearchAPI, type SearchResult } from '../../hooks/use-search-api'
import { useEmbeddedAppSearch } from '../../hooks/use-embedded-app-search'
import { useKeyboardShortcut } from '../../hooks/use-keyboard-shortcut'
import { type EmbeddedAppSearchResult } from '../../services/embedded-app-search.service'
import '../../styles/search-animations.css'

interface GlobalSearchOverlayProps {
  isOpen: boolean
  onClose: () => void
  onAppLaunch?: (app: EmbeddedAppSearchResult) => void
}

export function GlobalSearchOverlay({ isOpen, onClose, onAppLaunch }: GlobalSearchOverlayProps) {
  const inputRef = useRef<HTMLInputElement>(null)
  const overlayRef = useRef<HTMLDivElement>(null)
  const [activeTab, setActiveTab] = useState<'knowledge' | 'apps'>('knowledge')
  
  // Knowledge base search
  const {
    query: knowledgeQuery,
    setQuery: setKnowledgeQuery,
    results: knowledgeResults,
    loading: knowledgeLoading,
    clearSearch: clearKnowledgeSearch,
    hasResults: hasKnowledgeResults,
    hasQuery: hasKnowledgeQuery
  } = useSearchAPI()

  // Embedded app search
  const {
    query: appQuery,
    setQuery: setAppQuery,
    results: appResults,
    loading: appLoading,
    suggestedApps,
    launchApp,
    clearSearch: clearAppSearch,
    hasResults: hasAppResults,
    hasQuery: hasAppQuery
  } = useEmbeddedAppSearch()

  // Handle ESC key to close overlay
  useKeyboardShortcut(
    { key: 'Escape' },
    () => {
      if (isOpen) {
        onClose()
      }
    },
    [isOpen, onClose]
  )

  // Focus the input when overlay opens
  useEffect(() => {
    if (isOpen && inputRef.current) {
      // Small delay to ensure the overlay is fully rendered
      const timer = setTimeout(() => {
        inputRef.current?.focus()
      }, 100)
      return () => clearTimeout(timer)
    }
  }, [isOpen])

  // Handle backdrop click to close
  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === overlayRef.current) {
      onClose()
    }
  }

  // Handle result click for knowledge base
  const handleKnowledgeResultClick = (result: SearchResult) => {
    // Opening knowledge article
    // Knowledge articles open in new tab automatically via the SearchResults component
  }

  // Handle app launch
  const handleAppLaunch = async (app: EmbeddedAppSearchResult) => {
    try {
      const appWithContext = await launchApp(app)
      
      // Dispatch a custom event that the embedded column can listen to
      window.dispatchEvent(new CustomEvent('embedded-app:launch', { 
        detail: appWithContext 
      }))
      
      // Call the optional callback
      onAppLaunch?.(appWithContext)
      
      // Close the search overlay
      onClose()
    } catch (error) {
      // Failed to launch app
    }
  }

  // Clear all searches when closing overlay
  const handleClose = () => {
    clearKnowledgeSearch()
    clearAppSearch()
    onClose()
  }

  // Sync queries between tabs
  const handleTabChange = (value: string) => {
    const newTab = value as 'knowledge' | 'apps'
    setActiveTab(newTab)
    
    // Sync the query between tabs
    if (newTab === 'apps') {
      setAppQuery(knowledgeQuery)
    } else {
      setKnowledgeQuery(appQuery)
    }
  }

  // Get current values based on active tab
  const currentQuery = activeTab === 'knowledge' ? knowledgeQuery : appQuery
  const currentLoading = activeTab === 'knowledge' ? knowledgeLoading : appLoading
  const setCurrentQuery = activeTab === 'knowledge' ? setKnowledgeQuery : setAppQuery
  const clearCurrentSearch = activeTab === 'knowledge' ? clearKnowledgeSearch : clearAppSearch

  // Early return after all hooks have been called
  if (!isOpen) return null

  return (
    <div
      ref={overlayRef}
      className="fixed inset-0 z-50 flex items-start justify-center pt-[10vh] px-4"
      style={{ 
        backgroundColor: 'rgba(0, 0, 0, 0.4)',
        backdropFilter: 'blur(4px)',
        WebkitBackdropFilter: 'blur(4px)'
      }}
      onClick={handleBackdropClick}
    >
      {/* Search Container - Cleaner, more minimal */}
      <div className="w-full max-w-3xl bg-white dark:bg-gray-900 rounded-2xl shadow-xl border border-gray-200 dark:border-gray-700 overflow-hidden animate-in slide-in-from-top-4 duration-300">
        
        {/* Content with Tabs on Top */}
        <div className="px-6 pt-4 pb-6 relative">
          {/* Close button positioned absolutely */}
          <Button
            variant="ghost"
            size="sm"
            onClick={handleClose}
            className="absolute right-4 top-4 h-8 w-8 p-0 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-full z-10"
          >
            <X className="h-4 w-4" />
          </Button>
          <Tabs value={activeTab} onValueChange={handleTabChange}>
            {/* Clean tabs at the top */}
            <TabsList className="grid w-full grid-cols-2 mb-3 bg-transparent border-b border-gray-200 dark:border-gray-700 h-auto p-0 rounded-none">
              <TabsTrigger 
                value="knowledge" 
                className="search-tab pb-3 rounded-none border-0 bg-transparent data-[state=active]:bg-transparent data-[state=active]:text-red-600 data-[state=active]:shadow-none"
              >
                <FileText className="h-4 w-4 mr-2" />
                Knowledge Base
                {hasKnowledgeResults && (
                  <span className="ml-2 text-xs text-gray-500">
                    ({knowledgeResults.length})
                  </span>
                )}
              </TabsTrigger>
              <TabsTrigger 
                value="apps" 
                className="search-tab pb-3 rounded-none border-0 bg-transparent data-[state=active]:bg-transparent data-[state=active]:text-red-600 data-[state=active]:shadow-none"
              >
                <Monitor className="h-4 w-4 mr-2" />
                Applications
                {hasAppResults && (
                  <span className="ml-2 text-xs text-gray-500">
                    ({appResults.length})
                  </span>
                )}
              </TabsTrigger>
            </TabsList>

            {/* Beautiful Search Input below tabs */}
            <div className="mb-4">
              <SearchInput
                ref={inputRef}
                value={currentQuery}
                onChange={setCurrentQuery}
                onClear={clearCurrentSearch}
                loading={currentLoading}
                placeholder={activeTab === 'knowledge' 
                  ? "Search procedures, policies, compliance guides, or banking regulations..." 
                  : "Search banking applications and tools..."}
              />
              {/* Search hints */}
              <div className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                {activeTab === 'knowledge' ? (
                  <p>Try searching for: "loan procedures", "account opening", "KYC guidelines", "compliance rules"</p>
                ) : (
                  <p>Try searching for: "balance check", "transaction history", "customer profile", "loan calculator"</p>
                )}
              </div>
            </div>

            {/* Results with fade-in animation */}
            <div className="max-h-[50vh] overflow-y-auto">
              <TabsContent value="knowledge" className="search-results-container mt-0">
                <SearchResults
                  results={knowledgeResults}
                  loading={knowledgeLoading}
                  query={knowledgeQuery}
                  onResultClick={handleKnowledgeResultClick}
                />
              </TabsContent>
              
              <TabsContent value="apps" className="search-results-container mt-0">
                <EmbeddedAppSearchResults
                  results={appResults}
                  loading={appLoading}
                  query={appQuery}
                  onAppLaunch={handleAppLaunch}
                  suggestedApps={suggestedApps}
                  showCategories={true}
                />
              </TabsContent>
            </div>
          </Tabs>
        </div>

        {/* Footer with keyboard shortcuts */}
        <div className="flex items-center justify-between px-6 py-3 bg-gray-50 dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-4 text-xs text-muted-foreground">
            <div className="flex items-center gap-1">
              <kbd className="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded text-xs">↵</kbd>
              <span>to open</span>
            </div>
            <div className="flex items-center gap-1">
              <kbd className="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded text-xs">Tab</kbd>
              <span>to switch</span>
            </div>
            <div className="flex items-center gap-1">
              <kbd className="px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded text-xs">ESC</kbd>
              <span>to close</span>
            </div>
          </div>
          
          {(hasKnowledgeResults || hasAppResults) && (
            <div className="text-xs text-muted-foreground">
              {activeTab === 'knowledge' 
                ? `${knowledgeResults.length} result${knowledgeResults.length !== 1 ? 's' : ''}`
                : `${appResults.length} service${appResults.length !== 1 ? 's' : ''}`}
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/components/search/search-button.tsx===
import { Search } from 'lucide-react'
import { Button } from '../ui/button'

interface SearchButtonProps {
  onClick: () => void
  className?: string
}

export function SearchButton({ onClick, className }: SearchButtonProps) {
  // Detect platform for correct keyboard shortcut display
  const isMac = typeof window !== 'undefined' && window.navigator.platform.toUpperCase().indexOf('MAC') >= 0
  const shortcutKey = isMac ? '⌘' : 'Ctrl'

  return (
    <Button
      variant="outline"
      onClick={onClick}
      className={`h-9 px-3 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm border-gray-200 dark:border-gray-700 hover:bg-white dark:hover:bg-gray-800 transition-all duration-200 ${className}`}
      title={`Global Search (${shortcutKey}+F)`}
    >
      <Search className="h-4 w-4 mr-2" />
      <span className="hidden sm:inline-block mr-2">Search</span>
      <kbd className="hidden sm:inline-block px-1.5 py-0.5 text-xs bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded">
        {shortcutKey}F
      </kbd>
    </Button>
  )
}
===END FILE===

===BEGIN FILE: src/components/search/search-input.tsx===
import { forwardRef, useEffect, useState } from 'react'
import { Search, X, Loader2 } from 'lucide-react'
import { Input } from '../ui/input'
import { Button } from '../ui/button'
import '../../styles/search-animations.css'

interface SearchInputProps {
  value: string
  onChange: (value: string) => void
  onClear: () => void
  loading?: boolean
  placeholder?: string
  autoFocus?: boolean
}

export const SearchInput = forwardRef<HTMLInputElement, SearchInputProps>(
  ({ value, onChange, onClear, loading = false, placeholder = "Search procedures, policies, compliance guides...", autoFocus = true }, ref) => {
    const [isFocused, setIsFocused] = useState(false)
    const [isTyping, setIsTyping] = useState(false)
    
    useEffect(() => {
      if (autoFocus && ref && 'current' in ref && ref.current) {
        ref.current.focus()
      }
    }, [autoFocus, ref])
    
    // Trigger wave animation on typing
    useEffect(() => {
      if (isTyping) {
        const timer = setTimeout(() => setIsTyping(false), 1000)
        return () => clearTimeout(timer)
      }
    }, [isTyping, value])

    return (
      <div className={`gradient-border-animated ${loading ? 'search-input-loading' : ''}`}>
        <div className="relative bg-white dark:bg-gray-900 rounded-[0.7rem]">
          {/* Wave overlay for typing effect */}
          <div className={`search-wave-overlay ${isTyping ? 'search-wave-active' : ''}`} />
          
          {/* Search Icon */}
          <div className="absolute left-3 top-1/2 -translate-y-1/2 flex items-center justify-center text-gray-400">
            {loading ? (
              <Loader2 className="h-4 w-4 animate-spin text-red-500" />
            ) : (
              <Search className="h-4 w-4" />
            )}
          </div>

          {/* Search Input */}
          <Input
            ref={ref}
            type="text"
            value={value}
            onChange={(e) => {
              onChange(e.target.value)
              setIsTyping(true)
            }}
            onFocus={() => setIsFocused(true)}
            onBlur={() => setIsFocused(false)}
            placeholder={placeholder}
            className="search-input-animated pl-10 pr-10 h-11 text-base bg-transparent border-0 focus:ring-0 focus:outline-none rounded-[0.7rem]"
            autoComplete="off"
            spellCheck="false"
          />

          {/* Clear Button */}
          {value && (
            <Button
              variant="ghost"
              size="sm"
              onClick={onClear}
              className="absolute right-2 top-1/2 -translate-y-1/2 h-7 w-7 p-0 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-full transition-all duration-200 flex items-center justify-center"
            >
              <X className="h-3 w-3" />
            </Button>
          )}
        </div>
      </div>
    )
  }
)

SearchInput.displayName = "SearchInput"
===END FILE===

===BEGIN FILE: src/components/search/search-results-optimized.tsx===
import { memo, useCallback, useMemo, useState, useRef, useEffect } from 'react'
import { FileText, Search, Loader2 } from 'lucide-react'
import { type SearchResult } from '../../hooks/use-search-api'

interface SearchResultsOptimizedProps {
  results: SearchResult[]
  loading?: boolean
  query?: string
  onResultClick?: (result: SearchResult) => void
  maxVisible?: number
}

// Removed category icons and colors for cleaner, minimal design
// Using simple gray text for categories instead

// Memoized skeleton component - Simplified
const SkeletonResult = memo(() => (
  <div className="p-3 rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 animate-pulse">
    <div className="flex items-start gap-3">
      <div className="w-4 h-4 bg-gray-200 dark:bg-gray-700 rounded"></div>
      <div className="flex-1 space-y-2">
        <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4"></div>
        <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
        <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded w-4/5"></div>
      </div>
    </div>
  </div>
))

// Memoized highlight function
const highlightText = (text: string, searchQuery: string) => {
  if (!searchQuery || !text) return text
  
  // Use a simpler approach without regex for better performance
  const lowerText = text.toLowerCase()
  const lowerQuery = searchQuery.toLowerCase()
  const index = lowerText.indexOf(lowerQuery)
  
  if (index === -1) return text
  
  return (
    <>
      {text.slice(0, index)}
      <mark className="bg-yellow-200 dark:bg-yellow-800/50 px-1 rounded">
        {text.slice(index, index + searchQuery.length)}
      </mark>
      {text.slice(index + searchQuery.length)}
    </>
  )
}

// Memoized search result item - Beautiful & Minimal
const SearchResultItem = memo(({ 
  result, 
  query, 
  onResultClick 
}: { 
  result: SearchResult
  query?: string
  onResultClick?: (result: SearchResult) => void
}) => {
  const handleClick = useCallback(() => {
    window.open(result.url, '_blank', 'noopener,noreferrer')
    onResultClick?.(result)
  }, [result, onResultClick])
  
  return (
    <div 
      className="search-result-card group p-3 rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-750 cursor-pointer"
      onClick={handleClick}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault()
          handleClick()
        }
      }}
    >
      <div className="flex items-start gap-3">
        {/* Simple document icon */}
        <div className="mt-0.5 text-gray-400">
          <FileText className="h-4 w-4" />
        </div>
        
        <div className="flex-1 min-w-0">
          {/* Title and category on same line */}
          <div className="flex items-start justify-between gap-2 mb-1">
            <h3 className="font-medium text-gray-900 dark:text-gray-100 text-sm group-hover:text-red-600 dark:group-hover:text-red-400 transition-colors">
              {highlightText(result.title, query || '')}
            </h3>
            <span className="text-xs text-gray-500 dark:text-gray-400 shrink-0">
              {result.category}
            </span>
          </div>
          
          {/* Description */}
          <p className="text-xs text-gray-600 dark:text-gray-400 leading-relaxed line-clamp-2">
            {highlightText(result.snippet, query || '')}
          </p>
        </div>
      </div>
    </div>
  )
})

SearchResultItem.displayName = 'SearchResultItem'

// Empty state components
const NoResultsFound = memo(({ query }: { query?: string }) => (
  <div className="text-center py-8">
    <FileText className="h-10 w-10 text-muted-foreground mx-auto mb-3" />
    <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-2">
      No results found
    </h3>
    <p className="text-muted-foreground">
      {query 
        ? `No matches for "${query}". Try adjusting your search terms.`
        : 'Try adjusting your search terms or browse our knowledge categories'}
    </p>
  </div>
))

const SearchPrompt = memo(() => (
  <div className="text-center py-8">
    <Search className="h-10 w-10 text-muted-foreground mx-auto mb-3" />
    <h3 className="text-base font-normal text-gray-600 dark:text-gray-400 mb-2">
      Search Knowledge Base
    </h3>
    <p className="text-muted-foreground">
      Search procedures, policies, and guidelines instantly
    </p>
  </div>
))

export const SearchResultsOptimized = memo(({ 
  results, 
  loading, 
  query, 
  onResultClick,
  maxVisible = 10 
}: SearchResultsOptimizedProps) => {
  const [visibleCount, setVisibleCount] = useState(maxVisible)
  const [isLoadingMore, setIsLoadingMore] = useState(false)
  const containerRef = useRef<HTMLDivElement>(null)
  
  // Reset visible count when query changes
  useEffect(() => {
    setVisibleCount(maxVisible)
  }, [query, maxVisible])
  
  // Slice results for initial render performance
  const visibleResults = useMemo(
    () => results.slice(0, visibleCount),
    [results, visibleCount]
  )
  
  // Handle infinite scroll
  const handleScroll = useCallback((e: Event) => {
    const target = e.target as HTMLElement
    if (!target) return
    
    const scrollBottom = target.scrollTop + target.clientHeight
    const scrollThreshold = target.scrollHeight - 100 // 100px from bottom
    
    if (scrollBottom >= scrollThreshold && visibleCount < results.length && !isLoadingMore) {
      setIsLoadingMore(true)
      setTimeout(() => {
        setVisibleCount(prev => Math.min(prev + 10, results.length))
        setIsLoadingMore(false)
      }, 300)
    }
  }, [visibleCount, results.length, isLoadingMore])
  
  // Attach scroll listener to container
  useEffect(() => {
    // Small delay to ensure DOM is ready
    const timer = setTimeout(() => {
      const scrollContainer = document.querySelector('.max-h-\\[50vh\\].overflow-y-auto')
      
      if (scrollContainer) {
        scrollContainer.addEventListener('scroll', handleScroll)
        return () => scrollContainer.removeEventListener('scroll', handleScroll)
      }
    }, 100)
    
    return () => clearTimeout(timer)
  }, [handleScroll])
  
  // Group results by category for better organization
  const groupedResults = useMemo(() => {
    return visibleResults.reduce((acc, result) => {
      if (!acc[result.category]) {
        acc[result.category] = []
      }
      acc[result.category].push(result)
      return acc
    }, {} as Record<string, SearchResult[]>)
  }, [visibleResults])

  if (loading) {
    return (
      <div className="space-y-3">
        {Array.from({ length: 3 }, (_, i) => (
          <SkeletonResult key={i} />
        ))}
      </div>
    )
  }

  if (results.length === 0 && query) {
    return <NoResultsFound query={query} />
  }

  if (results.length === 0) {
    return <SearchPrompt />
  }

  const hasMultipleCategories = Object.keys(groupedResults).length > 1

  return (
    <div ref={containerRef} className="space-y-6">
      <div className="flex items-center justify-between">
        <p className="text-sm text-muted-foreground">
          Found {results.length} result{results.length !== 1 ? 's' : ''} 
          {query && ` for "${query}"`}
          {results.length > visibleCount && ` (showing ${visibleCount})`}
        </p>
      </div>
      
      {Object.entries(groupedResults).map(([category, categoryResults]) => (
        <div key={category} className="space-y-3">
          {hasMultipleCategories && (
            <h4 className="font-medium text-gray-900 dark:text-gray-100 flex items-center gap-2">
              <FileText className="h-4 w-4 text-gray-400" />
              <span>{category}</span>
              <span className="ml-auto text-xs text-gray-500 dark:text-gray-400">
                {categoryResults.length}
              </span>
            </h4>
          )}
          
          <div className="space-y-3">
            {categoryResults.map((result) => (
              <SearchResultItem
                key={result.id}
                result={result}
                query={query}
                onResultClick={onResultClick}
              />
            ))}
          </div>
        </div>
      ))}
      
      {/* Infinite scroll loading indicator */}
      {results.length > visibleCount && (
        <div className="h-10 flex items-center justify-center">
          {isLoadingMore && (
            <div className="flex items-center gap-2 text-sm text-gray-500">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Loading more results...</span>
            </div>
          )}
        </div>
      )}
      
      {/* Show count indicator */}
      {visibleCount === results.length && results.length > maxVisible && (
        <div className="text-center py-3 text-sm text-gray-500">
          All {results.length} results loaded
        </div>
      )}
    </div>
  )
})

SearchResultsOptimized.displayName = 'SearchResultsOptimized'
===END FILE===

===BEGIN FILE: src/components/settings-panel.tsx===
import { useState, useEffect } from 'react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from './ui/dialog'
import { Button } from './ui/button'
import { Input } from './ui/input'
import { Label } from './ui/label'
import { Switch } from './ui/switch'
import { Slider } from './ui/slider'
import { Badge } from './ui/badge'
import { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs'
import { ScrollArea } from './ui/scroll-area'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from './ui/select'
import { 
  Settings, 
  Phone, 
  Volume2, 
  Bell, 
  Shield, 
  Accessibility, 
  Globe, 
  HelpCircle,
  Play,
  Trash2,
  Keyboard,
  Layout,
  Monitor
} from 'lucide-react'
import { audioService } from '../services/audio.service'
import { useAgentSettings } from '../hooks/use-agent-settings'
import { useAgentStatus } from '../hooks/use-agent-status'

interface SettingsPanelProps {
  isOpen: boolean
  onClose: () => void
}

// Agent-focused settings interfaces
interface AgentSettings {
  calls: {
    autoAccept: boolean
    afterCallWorkTime: number // 0-120 seconds
    doNotDisturb: {
      enabled: boolean
      duration: 15 | 30 | 60 // minutes
      originalStatus?: string
    }
    confirmBeforeEnd: boolean
    requireActionsCompletion: boolean
  }
  audio: {
    ringtone: string
    volume: number // 0-100
    outputDevice: string
  }
  notifications: {
    desktop: boolean
    sounds: {
      incoming: boolean
      end: boolean
      error: boolean
    }
  }
  privacy: {
    idleTimeout: number // minutes before auto-logout
    rememberCallHistory: boolean
  }
  accessibility: {
    textSize: 'small' | 'medium' | 'large'
    highContrast: boolean
  }
  interface: {
    spaceCopilotMode: 'column' | 'overlay'
    spaceCopilotOverlayPosition: 'right' | 'left'
    showWidgetBorders: boolean
    compactMode: boolean
    showTranscript: boolean
    autoCloseKnowledgeOnCallEnd: boolean
  }
  language: string
}

const DEFAULT_AGENT_SETTINGS: AgentSettings = {
  calls: {
    autoAccept: false,
    afterCallWorkTime: 30,
    doNotDisturb: {
      enabled: false,
      duration: 15
    },
    confirmBeforeEnd: true,
    requireActionsCompletion: false
  },
  audio: {
    ringtone: 'default',
    volume: 70,
    outputDevice: 'default'
  },
  notifications: {
    desktop: true,
    sounds: {
      incoming: true,
      end: true,
      error: true
    }
  },
  privacy: {
    idleTimeout: 30,
    rememberCallHistory: false
  },
  accessibility: {
    textSize: 'medium',
    highContrast: false
  },
  interface: {
    spaceCopilotMode: 'column',
    spaceCopilotOverlayPosition: 'right',
    showWidgetBorders: true,
    compactMode: false,
    showTranscript: true,
    autoCloseKnowledgeOnCallEnd: true
  },
  language: 'en'
}

const RINGTONES = [
  { value: 'default', label: 'Default Ring' },
  { value: 'gentle', label: 'Gentle Chime' },
  { value: 'professional', label: 'Professional Tone' },
  { value: 'urgent', label: 'Urgent Alert' }
]

const LANGUAGES = [
  { value: 'en', label: 'English (UK)' },
  { value: 'en-us', label: 'English (US)' },
  { value: 'fr', label: 'Français' },
  { value: 'de', label: 'Deutsch' },
  { value: 'es', label: 'Español' },
  { value: 'zh', label: '中文' }
]

export function SettingsPanel({ isOpen, onClose }: SettingsPanelProps) {
  
  const { settings, updateSettings, updateNestedSettings } = useAgentSettings()
  const { handleDoNotDisturbToggle, status, doNotDisturbSecondsRemaining } = useAgentStatus()

  // Request desktop notification permission
  const requestNotificationPermission = async () => {
    if ('Notification' in window) {
      const permission = await Notification.requestPermission()
      if (permission === 'granted') {
        updateNestedSettings('notifications', { desktop: true })
      } else {
        updateNestedSettings('notifications', { desktop: false })
      }
    }
  }

  // Test ringtone playback
  const testRingtone = async () => {
    
    try {
      const result = await audioService.testRingtone(settings.audio.ringtone)
      if (result.success) {
        // Show brief notification if desktop notifications are enabled
        if ('Notification' in window && Notification.permission === 'granted' && settings.notifications.desktop) {
          new Notification('Ringtone Test', {
            body: `Playing ${RINGTONES.find(r => r.value === settings.audio.ringtone)?.label} at ${settings.audio.volume}% volume`,
            icon: '/hsbc-logo.png'
          })
        }
      } else {
        // Ringtone test failed
        // Fallback: show alert if audio fails
        alert(`Ringtone test failed: ${result.error}`)
      }
    } catch (error) {
      // Error testing ringtone
    }
  }


  // Apply text size to document
  useEffect(() => {
    const root = document.documentElement
    const textSizeMap = {
      small: '14px',
      medium: '16px', 
      large: '18px'
    }
    root.style.fontSize = textSizeMap[settings.accessibility.textSize]
  }, [settings.accessibility.textSize])

  // Apply high contrast mode
  useEffect(() => {
    const root = document.documentElement
    if (settings.accessibility.highContrast) {
      root.classList.add('high-contrast')
    } else {
      root.classList.remove('high-contrast')
    }
  }, [settings.accessibility.highContrast])

  // Fix pointer-events issue when dialog closes - Radix UI bug workaround
  useEffect(() => {
    if (!isOpen) {
      // Small delay to ensure Radix cleanup completes, then force restore pointer-events
      const timeoutId = setTimeout(() => {
        document.body.style.pointerEvents = ''
        document.body.style.removeProperty('pointer-events')
        document.documentElement.style.pointerEvents = ''
        document.documentElement.style.removeProperty('pointer-events')
      }, 200)
      return () => clearTimeout(timeoutId)
    }
  }, [isOpen])

  return (
    <Dialog open={isOpen} onOpenChange={(open) => {
        if (!open) {
          onClose()
        }
      }}>
      <DialogContent className="sm:max-w-[600px] max-h-[85vh] overflow-hidden flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Settings className="h-5 w-5" />
            Agent Settings
          </DialogTitle>
          <DialogDescription>
            Configure your agent preferences, call settings, and interface options.
          </DialogDescription>
        </DialogHeader>
        
        <Tabs defaultValue="calls" className="w-full flex-1 flex flex-col overflow-hidden">
          <TabsList className="grid w-full grid-cols-8">
            <TabsTrigger value="calls" className="p-2">
              <Phone className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="audio" className="p-2">
              <Volume2 className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="notifications" className="p-2">
              <Bell className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="privacy" className="p-2">
              <Shield className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="interface" className="p-2">
              <Layout className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="accessibility" className="p-2">
              <Accessibility className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="language" className="p-2">
              <Globe className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="help" className="p-2">
              <HelpCircle className="h-4 w-4" />
            </TabsTrigger>
          </TabsList>

          {/* Calls Tab */}
          <TabsContent value="calls" className="flex-1 overflow-hidden">
            <ScrollArea className="h-full">
              <div className="space-y-4 p-4 pb-6">
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label>Auto-accept calls</Label>
                  <p className="text-sm text-muted-foreground">Automatically accept incoming calls</p>
                </div>
                <Switch
                  checked={settings.calls.autoAccept}
                  onCheckedChange={(checked) => updateNestedSettings('calls', { autoAccept: checked })}
                />
              </div>

              <div className="space-y-2">
                <Label>After-call work time: {settings.calls.afterCallWorkTime} seconds</Label>
                <Slider
                  value={[settings.calls.afterCallWorkTime]}
                  onValueChange={([value]) => updateNestedSettings('calls', { afterCallWorkTime: value })}
                  max={120}
                  min={0}
                  step={15}
                  className="w-full"
                />
              </div>

              <div className="space-y-2">
                <Label>Do Not Disturb</Label>
                <div className="flex items-center gap-2">
                  <Switch
                    checked={status === 'do-not-disturb'}
                    onCheckedChange={(enabled) => {
                      if (enabled) {
                        handleDoNotDisturbToggle(true, settings.calls.doNotDisturb.duration)
                      } else {
                        handleDoNotDisturbToggle(false, settings.calls.doNotDisturb.duration)
                      }
                    }}
                  />
                  <Select
                    value={settings.calls.doNotDisturb.duration.toString()}
                    onValueChange={(value) => updateNestedSettings('calls', {
                      doNotDisturb: { ...settings.calls.doNotDisturb, duration: parseInt(value) as 15 | 30 | 60 }
                    })}
                    disabled={status === 'do-not-disturb'}
                  >
                    <SelectTrigger className="w-32">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="15">15 min</SelectItem>
                      <SelectItem value="30">30 min</SelectItem>
                      <SelectItem value="60">60 min</SelectItem>
                    </SelectContent>
                  </Select>
                  {status === 'do-not-disturb' && doNotDisturbSecondsRemaining > 0 && (
                    <span className="text-xs text-muted-foreground ml-2">
                      {Math.floor(doNotDisturbSecondsRemaining / 60)}:{(doNotDisturbSecondsRemaining % 60).toString().padStart(2, '0')} remaining
                    </span>
                  )}
                </div>
              </div>

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label>Confirm before ending call</Label>
                  <p className="text-sm text-muted-foreground">Show confirmation dialog when ending calls</p>
                </div>
                <Switch
                  checked={settings.calls.confirmBeforeEnd}
                  onCheckedChange={(checked) => updateNestedSettings('calls', { confirmBeforeEnd: checked })}
                />
              </div>

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label>Require actions completion</Label>
                  <p className="text-sm text-muted-foreground">Agent must complete all recommended actions before ending call</p>
                </div>
                <Switch
                  checked={settings.calls.requireActionsCompletion}
                  onCheckedChange={(checked) => updateNestedSettings('calls', { requireActionsCompletion: checked })}
                />
              </div>
              </div>
            </ScrollArea>
          </TabsContent>

          {/* Audio Tab */}
          <TabsContent value="audio" className="space-y-4 mt-4">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label>Ringtone</Label>
                <div className="flex gap-2">
                  <Select
                    value={settings.audio.ringtone}
                    onValueChange={(value) => updateNestedSettings('audio', { ringtone: value })}
                  >
                    <SelectTrigger className="flex-1">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      {RINGTONES.map(ringtone => (
                        <SelectItem key={ringtone.value} value={ringtone.value}>
                          {ringtone.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <Button variant="outline" size="icon" onClick={testRingtone}>
                    <Play className="h-4 w-4" />
                  </Button>
                </div>
              </div>

              <div className="space-y-2">
                <Label>Volume: {settings.audio.volume}%</Label>
                <Slider
                  value={[settings.audio.volume]}
                  onValueChange={([value]) => updateNestedSettings('audio', { volume: value })}
                  max={100}
                  min={0}
                  step={5}
                  className="w-full"
                />
              </div>

              <div className="space-y-2">
                <Label>Output Device</Label>
                <Select
                  value={settings.audio.outputDevice}
                  onValueChange={(value) => updateNestedSettings('audio', { outputDevice: value })}
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="default">Default Audio Device</SelectItem>
                    <SelectItem value="speakers">Speakers</SelectItem>
                    <SelectItem value="headset">Headset</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>
          </TabsContent>

          {/* Notifications Tab */}
          <TabsContent value="notifications" className="space-y-4 mt-4">
            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label>Desktop notifications</Label>
                  <p className="text-sm text-muted-foreground">
                    Status: {Notification?.permission || 'not supported'}
                  </p>
                </div>
                <div className="flex gap-2">
                  <Switch
                    checked={settings.notifications.desktop}
                    onCheckedChange={(checked) => {
                      if (checked && Notification?.permission !== 'granted') {
                        requestNotificationPermission()
                      } else {
                        updateNestedSettings('notifications', { desktop: checked })
                      }
                    }}
                  />
                </div>
              </div>

              <div className="space-y-2">
                <Label>Sound Notifications</Label>
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <Label className="text-sm font-normal">Incoming calls</Label>
                    <Switch
                      checked={settings.notifications.sounds.incoming}
                      onCheckedChange={(checked) => updateNestedSettings('notifications', {
                        sounds: { ...settings.notifications.sounds, incoming: checked }
                      })}
                    />
                  </div>
                  <div className="flex items-center justify-between">
                    <Label className="text-sm font-normal">Call end</Label>
                    <Switch
                      checked={settings.notifications.sounds.end}
                      onCheckedChange={(checked) => updateNestedSettings('notifications', {
                        sounds: { ...settings.notifications.sounds, end: checked }
                      })}
                    />
                  </div>
                  <div className="flex items-center justify-between">
                    <Label className="text-sm font-normal">Errors</Label>
                    <Switch
                      checked={settings.notifications.sounds.error}
                      onCheckedChange={(checked) => updateNestedSettings('notifications', {
                        sounds: { ...settings.notifications.sounds, error: checked }
                      })}
                    />
                  </div>
                </div>
              </div>
            </div>
          </TabsContent>

          {/* Privacy Tab */}
          <TabsContent value="privacy" className="space-y-4 mt-4">
            <div className="space-y-4">

              <div className="space-y-2">
                <Label>Auto-logout after idle: {settings.privacy.idleTimeout} minutes</Label>
                <p className="text-sm text-muted-foreground">Automatically log out after period of inactivity</p>
                <Slider
                  value={[settings.privacy.idleTimeout]}
                  onValueChange={([value]) => updateNestedSettings('privacy', { idleTimeout: value })}
                  max={120}
                  min={5}
                  step={5}
                  className="w-full"
                />
                <div className="flex justify-between text-xs text-muted-foreground">
                  <span>5 min</span>
                  <span>2 hours</span>
                </div>
              </div>

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label>Remember call history</Label>
                  <p className="text-sm text-muted-foreground">Keep local history of recent calls for quick reference</p>
                </div>
                <Switch
                  checked={settings.privacy.rememberCallHistory}
                  onCheckedChange={(checked) => updateNestedSettings('privacy', { rememberCallHistory: checked })}
                />
              </div>

              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                <div className="flex items-start gap-2">
                  <Shield className="h-5 w-5 text-blue-600 dark:text-blue-400 mt-0.5 flex-shrink-0" />
                  <div className="space-y-1">
                    <h4 className="font-medium text-blue-800 dark:text-blue-200">Privacy Protection</h4>
                    <p className="text-sm text-blue-700 dark:text-blue-300">
                      All call data is automatically encrypted and cleared after each session. 
                      These settings provide additional privacy controls for your workspace.
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </TabsContent>

          {/* Interface Tab */}
          <TabsContent value="interface" className="flex-1 overflow-hidden">
            <ScrollArea className="h-full">
              <div className="space-y-4 p-4 pb-6">
              <div className="space-y-2">
                <Label>Space Copilot Display Mode</Label>
                <Select
                  value={settings.interface.spaceCopilotMode}
                  onValueChange={(value: 'column' | 'overlay') => 
                    updateNestedSettings('interface', { spaceCopilotMode: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="column">Column (Always visible)</SelectItem>
                    <SelectItem value="overlay">Overlay (On-demand)</SelectItem>
                  </SelectContent>
                </Select>
                <p className="text-sm text-muted-foreground">
                  Column mode shows Space Copilot as a fixed column. Overlay mode shows it as a floating panel.
                </p>
              </div>

              {settings.interface.spaceCopilotMode === 'overlay' && (
                <div className="space-y-2">
                  <Label>Overlay Position</Label>
                  <Select
                    value={settings.interface.spaceCopilotOverlayPosition}
                    onValueChange={(value: 'right' | 'left') => 
                      updateNestedSettings('interface', { spaceCopilotOverlayPosition: value })
                    }
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="right">Right side</SelectItem>
                      <SelectItem value="left">Left side</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              )}

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label>Show widget borders</Label>
                  <p className="text-sm text-muted-foreground">Display borders around dashboard widgets</p>
                </div>
                <Switch
                  checked={settings.interface.showWidgetBorders}
                  onCheckedChange={(checked) => updateNestedSettings('interface', { showWidgetBorders: checked })}
                />
              </div>

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label>Compact mode</Label>
                  <p className="text-sm text-muted-foreground">Reduce padding and spacing for more content density</p>
                </div>
                <Switch
                  checked={settings.interface.compactMode}
                  onCheckedChange={(checked) => updateNestedSettings('interface', { compactMode: checked })}
                />
              </div>

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label>Show Transcript in Space Copilot</Label>
                  <p className="text-sm text-muted-foreground">Display call transcript alongside AI assistance</p>
                </div>
                <Switch
                  checked={settings.interface.showTranscript}
                  onCheckedChange={(checked) => updateNestedSettings('interface', { showTranscript: checked })}
                />
              </div>

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label>Auto-close Knowledge on Call End</Label>
                  <p className="text-sm text-muted-foreground">Automatically close knowledge articles when call ends</p>
                </div>
                <Switch
                  checked={settings.interface.autoCloseKnowledgeOnCallEnd}
                  onCheckedChange={(checked) => updateNestedSettings('interface', { autoCloseKnowledgeOnCallEnd: checked })}
                />
              </div>

              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                <div className="flex items-start gap-2">
                  <Monitor className="h-5 w-5 text-blue-600 dark:text-blue-400 mt-0.5 flex-shrink-0" />
                  <div className="space-y-1">
                    <h4 className="font-medium text-blue-800 dark:text-blue-200">Interface Tip</h4>
                    <p className="text-sm text-blue-700 dark:text-blue-300">
                      Overlay mode is ideal for users with smaller screens or those who prefer more workspace. 
                      Column mode provides constant access to AI assistance.
                    </p>
                  </div>
                </div>
              </div>
              </div>
            </ScrollArea>
          </TabsContent>

          {/* Accessibility Tab */}
          <TabsContent value="accessibility" className="space-y-4 mt-4">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label>Text size</Label>
                <Select
                  value={settings.accessibility.textSize}
                  onValueChange={(value: 'small' | 'medium' | 'large') => 
                    updateNestedSettings('accessibility', { textSize: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="small">Small</SelectItem>
                    <SelectItem value="medium">Medium</SelectItem>
                    <SelectItem value="large">Large</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label>High-contrast mode</Label>
                  <p className="text-sm text-muted-foreground">Increase contrast for better visibility</p>
                </div>
                <Switch
                  checked={settings.accessibility.highContrast}
                  onCheckedChange={(checked) => updateNestedSettings('accessibility', { highContrast: checked })}
                />
              </div>
            </div>
          </TabsContent>

          {/* Language Tab */}
          <TabsContent value="language" className="space-y-4 mt-4">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label>App language</Label>
                <Select
                  value={settings.language}
                  onValueChange={(value) => updateSettings({ language: value })}
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {LANGUAGES.map(lang => (
                      <SelectItem key={lang.value} value={lang.value}>
                        {lang.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </div>
          </TabsContent>

          {/* Help Tab */}
          <TabsContent value="help" className="space-y-4 mt-4">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label>Keyboard shortcuts</Label>
                <div className="bg-muted p-3 rounded-md text-sm space-y-2">
                  <div className="flex justify-between">
                    <span>Global search</span>
                    <code>Ctrl+F / Cmd+F</code>
                  </div>
                  <div className="flex justify-between">
                    <span>Accept call</span>
                    <code>Enter</code>
                  </div>
                  <div className="flex justify-between">
                    <span>End call</span>
                    <code>Ctrl+E</code>
                  </div>
                </div>
              </div>

              <div className="space-y-2">
                <Label>Report an issue</Label>
                <p className="text-sm text-muted-foreground">
                  Attach the last 5 minutes of client logs for support
                </p>
                <Button variant="outline" className="w-full">
                  <HelpCircle className="h-4 w-4 mr-2" />
                  Report Issue
                </Button>
              </div>

              <div className="space-y-2">
                <Label>Quick training tips</Label>
                <div className="bg-muted p-3 rounded-md text-sm">
                  <p className="font-medium mb-2">💡 Pro Tips:</p>
                  <ul className="space-y-1">
                    <li>• Use Do Not Disturb during admin tasks</li>
                    <li>• Test your ringtone and volume regularly</li>
                    <li>• Clear cache weekly for optimal performance</li>
                    <li>• Enable desktop notifications for alerts</li>
                  </ul>
                </div>
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </DialogContent>
    </Dialog>
  )
}
===END FILE===

===BEGIN FILE: src/components/supervisor/team-status-grid.tsx===
import { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '../ui/card'
import { Badge } from '../ui/badge'
import { Button } from '../ui/button'
import { Avatar, AvatarFallback } from '../ui/avatar'
import { Progress } from '../ui/progress'
import { 
  Users, 
  Phone, 
  MessageSquare, 
  Clock, 
  TrendingUp, 
  TrendingDown,
  Eye,
  UserCheck,
  UserX,
  Activity
} from 'lucide-react'
import { cn } from '../../lib/utils'

interface Agent {
  id: string
  name: string
  role: 'call' | 'chat'
  status: 'available' | 'busy' | 'break' | 'offline'
  currentCustomer?: string
  callDuration?: number
  performance: {
    callsToday: number
    avgHandleTime: number
    satisfaction: number
  }
}

// ✅ EXTERNALIZED: Team agents data moved to /public/config/team-agents.json

async function loadTeamAgents(): Promise<Agent[]> {
  try {
    const response = await fetch('/config/team-agents.json')
    if (!response.ok) {
      throw new Error(`Failed to load team agents: ${response.status}`)
    }
    const data = await response.json()
    return data.agents
  } catch (error) {
    // Failed to load team agents, using fallback
    return [
      {
        id: '1',
        name: 'Agent 1',
        role: 'call',
        status: 'available',
        performance: {
          callsToday: 0,
          avgHandleTime: 180,
          satisfaction: 90
        }
      }
    ]
  }
}

export function TeamStatusGrid({ className }: { className?: string }) {
  const [agents, setAgents] = useState<Agent[]>([])
  const [selectedAgent, setSelectedAgent] = useState<Agent | null>(null)
  const [loading, setLoading] = useState(true)

  // Load agents from config on component mount
  useEffect(() => {
    loadTeamAgents().then(loadedAgents => {
      setAgents(loadedAgents)
      setLoading(false)
    })
  }, [])
  
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'available': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'busy': return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
      case 'break': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      case 'offline': return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      default: return 'bg-gray-100 text-gray-800'
    }
  }
  
  const formatDuration = (seconds: number) => {
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }
  
  const totalAgents = agents.length
  const availableAgents = agents.filter(a => a.status === 'available').length
  const busyAgents = agents.filter(a => a.status === 'busy').length
  const onBreak = agents.filter(a => a.status === 'break').length
  
  return (
    <Card className={cn("h-full", className)}>
      <CardHeader className="border-b">
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center gap-2">
            <Users className="h-5 w-5" />
            Team Status
          </CardTitle>
          <div className="flex gap-2">
            <Button size="sm" variant="outline">
              <Eye className="h-4 w-4 mr-1" />
              Monitor All
            </Button>
          </div>
        </div>
        
        {/* Quick Stats */}
        <div className="grid grid-cols-4 gap-2 mt-4">
          <div className="text-center p-2 bg-green-50 dark:bg-green-900/20 rounded">
            <p className="text-2xl font-bold text-green-600">{availableAgents}</p>
            <p className="text-xs text-muted-foreground">Available</p>
          </div>
          <div className="text-center p-2 bg-red-50 dark:bg-red-900/20 rounded">
            <p className="text-2xl font-bold text-red-600">{busyAgents}</p>
            <p className="text-xs text-muted-foreground">Busy</p>
          </div>
          <div className="text-center p-2 bg-yellow-50 dark:bg-yellow-900/20 rounded">
            <p className="text-2xl font-bold text-yellow-600">{onBreak}</p>
            <p className="text-xs text-muted-foreground">Break</p>
          </div>
          <div className="text-center p-2 bg-gray-50 dark:bg-gray-900/20 rounded">
            <p className="text-2xl font-bold text-gray-600">{totalAgents - availableAgents - busyAgents - onBreak}</p>
            <p className="text-xs text-muted-foreground">Offline</p>
          </div>
        </div>
      </CardHeader>
      
      <CardContent className="p-4">
        {/* Agent Grid */}
        <div className="space-y-2">
          {agents.map((agent) => (
            <Card 
              key={agent.id} 
              className={cn(
                "p-3 cursor-pointer transition-colors border",
                selectedAgent?.id === agent.id && "bg-accent",
                agent.status === 'busy' && "border-l-4 border-l-red-500"
              )}
              onClick={() => setSelectedAgent(agent)}
            >
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <Avatar className="h-8 w-8">
                    <AvatarFallback>{agent.name.split(' ').map(n => n[0]).join('')}</AvatarFallback>
                  </Avatar>
                  <div>
                    <p className="font-medium text-sm">{agent.name}</p>
                    <div className="flex items-center gap-2">
                      <Badge variant="secondary" className={cn("text-xs", getStatusColor(agent.status))}>
                        {agent.status}
                      </Badge>
                      {agent.role === 'call' ? (
                        <Phone className="h-3 w-3 text-muted-foreground" />
                      ) : (
                        <MessageSquare className="h-3 w-3 text-muted-foreground" />
                      )}
                    </div>
                  </div>
                </div>
                
                <div className="text-right">
                  {agent.status === 'busy' && agent.callDuration !== undefined && (
                    <p className="text-sm font-mono text-red-600">
                      {formatDuration(agent.callDuration)}
                    </p>
                  )}
                  <p className="text-xs text-muted-foreground">
                    {agent.performance.callsToday} today
                  </p>
                  <div className="flex items-center gap-1 mt-1">
                    <Activity className="h-3 w-3 text-muted-foreground" />
                    <span className="text-xs">{agent.performance.satisfaction}%</span>
                  </div>
                </div>
              </div>
              
              {agent.currentCustomer && (
                <div className="mt-2 p-2 bg-muted rounded text-xs">
                  <span className="text-muted-foreground">With: </span>
                  <span className="font-medium">{agent.currentCustomer}</span>
                </div>
              )}
              
              {/* Performance bar */}
              <div className="mt-2">
                <div className="flex justify-between text-xs mb-1">
                  <span>Performance</span>
                  <span>{agent.performance.satisfaction}%</span>
                </div>
                <Progress value={agent.performance.satisfaction} className="h-1" />
              </div>
            </Card>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
===END FILE===

===BEGIN FILE: src/components/theme-toggle.tsx===
import { Moon, Sun, Monitor } from 'lucide-react'
import { Button } from './ui/button'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from './ui/dropdown-menu'
import { useTheme } from '../contexts/theme-context'

export function ThemeToggle() {
  const { theme, setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme('light')}>
          <Sun className="mr-2 h-4 w-4" />
          <span>Light</span>
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('dark')}>
          <Moon className="mr-2 h-4 w-4" />
          <span>Dark</span>
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('system')}>
          <Monitor className="mr-2 h-4 w-4" />
          <span>System</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
===END FILE===

===BEGIN FILE: src/components/ui/alert.tsx===
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
===END FILE===

===BEGIN FILE: src/components/ui/avatar.tsx===
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "../../lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
===END FILE===

===BEGIN FILE: src/components/ui/badge.tsx===
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
===END FILE===

===BEGIN FILE: src/components/ui/button.tsx===
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
===END FILE===

===BEGIN FILE: src/components/ui/card.tsx===
import * as React from "react"

import { cn } from "../../lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
===END FILE===

===BEGIN FILE: src/components/ui/checkbox.tsx===
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "../../lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
===END FILE===

===BEGIN FILE: src/components/ui/dialog.tsx===
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { Cross2Icon } from "@radix-ui/react-icons"

import { cn } from "../../lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
===END FILE===

===BEGIN FILE: src/components/ui/dropdown-menu.tsx===
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "../../lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root
const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger
const DropdownMenuGroup = DropdownMenuPrimitive.Group
const DropdownMenuPortal = DropdownMenuPrimitive.Portal
const DropdownMenuSub = DropdownMenuPrimitive.Sub
const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
===END FILE===

===BEGIN FILE: src/components/ui/input.tsx===
import * as React from "react"

import { cn } from "../../lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
===END FILE===

===BEGIN FILE: src/components/ui/label.tsx===
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
===END FILE===

===BEGIN FILE: src/components/ui/popover.tsx===
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "../../lib/utils"

const Popover = PopoverPrimitive.Root
const PopoverTrigger = PopoverPrimitive.Trigger
const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
===END FILE===

===BEGIN FILE: src/components/ui/progress.tsx===
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "../../lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
===END FILE===

===BEGIN FILE: src/components/ui/radio-group.tsx===
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "../../lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
===END FILE===

===BEGIN FILE: src/components/ui/scroll-area.tsx===
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "../../lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
===END FILE===

===BEGIN FILE: src/components/ui/select.tsx===
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "../../lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
===END FILE===

===BEGIN FILE: src/components/ui/separator.tsx===
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "../../lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
===END FILE===

===BEGIN FILE: src/components/ui/sheet.tsx===
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
===END FILE===

===BEGIN FILE: src/components/ui/skeleton.tsx===
import { cn } from "../../lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
===END FILE===

===BEGIN FILE: src/components/ui/slider.tsx===
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "../../lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
===END FILE===

===BEGIN FILE: src/components/ui/switch.tsx===
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "../../lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
===END FILE===

===BEGIN FILE: src/components/ui/table.tsx===
import * as React from "react"

import { cn } from "../../lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className)}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
===END FILE===

===BEGIN FILE: src/components/ui/tabs.tsx===
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "../../lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
===END FILE===

===BEGIN FILE: src/components/ui/textarea.tsx===
import * as React from "react"

import { cn } from "../../lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
===END FILE===

===BEGIN FILE: src/components/ui/toast.tsx===
import * as React from "react"
import { X } from "lucide-react"

export interface ToastProps {
  id: string
  title?: string
  description?: string
  action?: React.ReactNode
  variant?: "default" | "destructive" | "success"
  onClose?: () => void
}

export function Toast({
  title,
  description,
  action,
  variant = "default",
  onClose,
}: ToastProps) {
  const variantStyles = {
    default: "bg-white border-gray-200",
    destructive: "bg-red-50 border-red-200 text-red-900",
    success: "bg-green-50 border-green-200 text-green-900",
  }

  return (
    <div
      className={`
        relative flex w-full max-w-sm items-center space-x-4 rounded-lg border p-4 shadow-lg
        ${variantStyles[variant]}
        animate-in slide-in-from-top-full duration-300
      `}
    >
      <div className="flex-1 space-y-1">
        {title && <p className="text-sm font-semibold">{title}</p>}
        {description && (
          <p className="text-sm text-muted-foreground">{description}</p>
        )}
      </div>
      {action}
      {onClose && (
        <button
          onClick={onClose}
          className="absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-70 hover:opacity-100"
        >
          <X className="h-4 w-4" />
        </button>
      )}
    </div>
  )
}

export function ToastContainer({ children }: { children: React.ReactNode }) {
  return (
    <div className="fixed bottom-0 right-0 z-50 flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]">
      {children}
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/components/ui/toggle-group.tsx===
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleGroupItemVariants>
>({
  size: "default",
  variant: "default",
})

const toggleGroupItemVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleGroupItemVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleGroupItemVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleGroupItemVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
===END FILE===

===BEGIN FILE: src/components/ui/toggle.tsx===
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
===END FILE===

===BEGIN FILE: src/components/ui/tooltip.tsx===
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"
import { cn } from "../../lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

===END FILE===

===BEGIN FILE: src/components/widgets/transcript.tsx===
import { ScrollArea } from '../ui/scroll-area'
import { Badge } from '../ui/badge'
import { Separator } from '../ui/separator'
import { User, Headphones, MessageSquare, MessagesSquare, Activity, Circle } from 'lucide-react'
import { useTranscript, useCustomerName, useAgentName } from '../../stores/selectors/agent-selectors'
import { useAgentSettings } from '../../hooks/use-agent-settings'
import { useEffect, useRef, memo } from 'react'
import { cn } from '../../lib/utils'

export const TranscriptWidget = memo(function TranscriptWidget() {
  const transcript = useTranscript()
  const customerName = useCustomerName()
  const agentName = useAgentName()
  const { settings: agentSettings } = useAgentSettings()
  const scrollAreaRef = useRef<HTMLDivElement>(null)
  const scrollContentRef = useRef<HTMLDivElement>(null)
  const prevTranscriptLength = useRef(transcript.length)
  
  // Handle scroll behavior
  useEffect(() => {
    // If transcript was cleared (call ended), scroll to top
    if (transcript.length === 0 && prevTranscriptLength.current > 0) {
      if (scrollAreaRef.current) {
        const scrollContainer = scrollAreaRef.current.querySelector('[data-radix-scroll-area-viewport]')
        if (scrollContainer) {
          scrollContainer.scrollTop = 0
        }
      }
    }
    // If new messages arrived, scroll to bottom
    else if (transcript.length > prevTranscriptLength.current) {
      if (scrollContentRef.current) {
        scrollContentRef.current.scrollIntoView({ behavior: 'smooth', block: 'end' })
      }
    }
    
    prevTranscriptLength.current = transcript.length
  }, [transcript.length])
  
  const formatTime = (date: Date) => {
    const d = new Date(date)
    return d.toLocaleTimeString('en-US', { 
      hour: '2-digit', 
      minute: '2-digit', 
      second: '2-digit' 
    })
  }


  return (
    <div className="flex flex-col h-full min-w-0 transcript-widget">
      {/* Professional Header */}
      <div className="border-b pb-4 mb-4 px-4 pt-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <MessagesSquare className="h-4 w-4 text-gray-600" />
            <div>
              <h3 className="text-sm font-semibold text-gray-900">Live Transcript</h3>
              <p className="text-xs text-muted-foreground">Real-time conversation</p>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Circle className="h-2 w-2 bg-green-500 animate-pulse" />
            <span className="text-xs font-medium text-green-600">Active</span>
            <span className="text-xs text-muted-foreground font-medium">•</span>
            <span className="text-xs font-medium text-gray-600">{transcript.length} messages</span>
          </div>
        </div>
      </div>
      
      <ScrollArea className="flex-1 min-w-0" ref={scrollAreaRef}>
        <div className="space-y-3 min-w-0 px-4">
          {transcript.length > 0 ? transcript.map((entry) => (
            <div
              key={entry.id}
              className={cn(
                "flex w-full",
                entry.speaker === 'agent' ? 'justify-end' : 'justify-start'
              )}
            >
              <div className={cn(
                "max-w-[75%] space-y-1",
                entry.speaker === 'agent' ? 'items-end' : 'items-start'
              )}>
                <div className={cn(
                  "flex items-baseline gap-2 text-xs",
                  entry.speaker === 'agent' ? 'justify-end' : 'justify-start'
                )}>
                  <span className={cn(
                    "font-medium",
                    entry.speaker === 'agent' ? 'text-red-700' : 'text-gray-700'
                  )}>
                    {entry.speaker === 'agent' ? agentName : customerName}
                  </span>
                  <span className="text-[10px] text-muted-foreground">
                    {entry.speaker === 'agent' ? 'Agent' : 'Customer'}
                  </span>
                  <span className="text-xs text-muted-foreground">
                    • {formatTime(entry.timestamp)}
                  </span>
                </div>
                <div className={cn(
                  "p-3 rounded-lg break-words whitespace-normal shadow-sm",
                  entry.speaker === 'agent' 
                    ? 'bg-red-50 border border-red-100 rounded-br-sm' 
                    : 'bg-gray-50 border border-gray-200 rounded-bl-sm'
                )}>
                  <p className="text-sm text-gray-900 break-words whitespace-normal">{entry.text}</p>
                </div>
              </div>
            </div>
          )) : (
            <div className="flex items-start justify-center min-h-[200px] pt-8">
              <div className="text-center space-y-3 max-w-[260px]">
                <div className="relative inline-flex">
                  <div className="absolute inset-0 bg-gray-100 rounded-full blur-xl opacity-70" />
                  <MessageSquare className="h-10 w-10 text-gray-400 relative" />
                </div>
                <div>
                  <p className="text-sm font-medium text-gray-700">No Active Conversation</p>
                  <p className="text-xs text-muted-foreground mt-1">
                    Transcript will appear here when call begins
                  </p>
                </div>
              </div>
            </div>
          )}
          {/* Auto-scroll anchor */}
          <div ref={scrollContentRef} />
        </div>
      </ScrollArea>
    </div>
  )
})
===END FILE===

===BEGIN FILE: src/config/app-config.ts===
/**
 * Application Configuration
 * Centralized configuration management with environment-based settings
 */

export interface ServiceEndpoints {
  websocket: {
    baseUrl: string
    path: string
    callCenterPath: string
    defaultPort: number
  }
  aiService: {
    baseUrl: string
    stopCallPath: string
  }
  searchService: {
    baseUrl: string
    embeddedAppsPath: string
    documentsPath: string
  }
  gatewayService: {
    baseUrl: string
    healthPath: string
    metricsPath: string
  }
  knowledgePortal: {
    baseUrl: string
    articlesPath: string
  }
}

export interface AppConfig {
  environment: 'development' | 'staging' | 'production'
  services: ServiceEndpoints
  features: {
    enableMockData: boolean
    enableAISimulation: boolean
    enableDebugLogging: boolean
    autoConnectWebSocket: boolean
  }
  ui: {
    defaultTheme: 'light' | 'dark' | 'system'
    animationsEnabled: boolean
    toastDuration: number
  }
  websocket: {
    reconnectInterval: number
    heartbeatInterval: number
    maxReconnectAttempts: number
    maxReconnectDelay: number
  }
}

// Environment variable helpers
const getEnvVar = (key: string, defaultValue: string): string => {
  if (typeof window !== 'undefined') {
    // Client-side: check for Vite environment variables
    return import.meta.env[`VITE_${key}`] || defaultValue
  }
  return defaultValue
}

const getEnvBool = (key: string, defaultValue: boolean): boolean => {
  const value = getEnvVar(key, defaultValue.toString())
  return value.toLowerCase() === 'true'
}

const getEnvNumber = (key: string, defaultValue: number): number => {
  const value = getEnvVar(key, defaultValue.toString())
  const parsed = parseInt(value, 10)
  return isNaN(parsed) ? defaultValue : parsed
}

// Default configuration with environment variable fallbacks
const createDefaultConfig = (): AppConfig => ({
  environment: (getEnvVar('NODE_ENV', 'development') as any) || 'development',
  
  services: {
    websocket: {
      baseUrl: getEnvVar('WEBSOCKET_BASE_URL', 'ws://localhost'),
      path: getEnvVar('WEBSOCKET_PATH', '/ws'),
      callCenterPath: getEnvVar('WEBSOCKET_CALL_CENTER_PATH', '/ws/call-center'),
      defaultPort: getEnvNumber('WEBSOCKET_PORT', 8080)
    },
    
    aiService: {
      baseUrl: getEnvVar('AI_SERVICE_BASE_URL', 'http://localhost:8000'),
      stopCallPath: getEnvVar('AI_SERVICE_STOP_CALL_PATH', '/api/calls/stop')
    },
    
    searchService: {
      baseUrl: getEnvVar('SEARCH_SERVICE_BASE_URL', 'http://localhost:8081'),
      embeddedAppsPath: getEnvVar('SEARCH_EMBEDDED_APPS_PATH', '/api/embedded-apps/search'),
      documentsPath: getEnvVar('SEARCH_DOCUMENTS_PATH', '/api/documents/search')
    },
    
    gatewayService: {
      baseUrl: getEnvVar('GATEWAY_SERVICE_BASE_URL', 'http://localhost:8080'),
      healthPath: getEnvVar('GATEWAY_HEALTH_PATH', '/health'),
      metricsPath: getEnvVar('GATEWAY_METRICS_PATH', '/metrics')
    },
    
    knowledgePortal: {
      baseUrl: getEnvVar('KNOWLEDGE_PORTAL_BASE_URL', 'http://localhost:3001'),
      articlesPath: getEnvVar('KNOWLEDGE_ARTICLES_PATH', '/api/articles')
    }
  },
  
  features: {
    enableMockData: getEnvBool('ENABLE_MOCK_DATA', true),
    enableAISimulation: getEnvBool('ENABLE_AI_SIMULATION', true),
    enableDebugLogging: getEnvBool('ENABLE_DEBUG_LOGGING', true),
    autoConnectWebSocket: getEnvBool('AUTO_CONNECT_WEBSOCKET', false)
  },
  
  ui: {
    defaultTheme: (getEnvVar('DEFAULT_THEME', 'system') as any) || 'system',
    animationsEnabled: getEnvBool('ANIMATIONS_ENABLED', true),
    toastDuration: getEnvNumber('TOAST_DURATION', 3000)
  },
  
  websocket: {
    reconnectInterval: getEnvNumber('WS_RECONNECT_INTERVAL', 3000),
    heartbeatInterval: getEnvNumber('WS_HEARTBEAT_INTERVAL', 15000),
    maxReconnectAttempts: getEnvNumber('WS_MAX_RECONNECT_ATTEMPTS', 10),
    maxReconnectDelay: getEnvNumber('WS_MAX_RECONNECT_DELAY', 30000)
  }
})

// Configuration instance
let appConfig: AppConfig | null = null

/**
 * Get the application configuration
 * Initializes config on first access
 */
export const getAppConfig = (): AppConfig => {
  if (!appConfig) {
    appConfig = createDefaultConfig()
    
    // Configuration loaded
  }
  
  return appConfig
}

/**
 * Get WebSocket URL with parameters
 */
export const getWebSocketUrl = (params?: { 
  callerId?: string 
  agentId?: string 
  role?: string
  port?: number 
}): string => {
  const config = getAppConfig()
  const port = params?.port || config.services.websocket.defaultPort
  const baseUrl = `${config.services.websocket.baseUrl}:${port}${config.services.websocket.callCenterPath}`
  
  if (params?.callerId || params?.agentId || params?.role) {
    const searchParams = new URLSearchParams()
    if (params.callerId) searchParams.set('callerId', params.callerId)
    if (params.agentId) searchParams.set('agentId', params.agentId)
    if (params.role) searchParams.set('role', params.role)
    return `${baseUrl}?${searchParams.toString()}`
  }
  
  return baseUrl
}

/**
 * Get AI Service stop call URL
 */
export const getAIServiceStopUrl = (): string => {
  const config = getAppConfig()
  return `${config.services.aiService.baseUrl}${config.services.aiService.stopCallPath}`
}

/**
 * Get Search Service URLs
 */
export const getSearchServiceUrls = () => {
  const config = getAppConfig()
  return {
    embeddedApps: `${config.services.searchService.baseUrl}${config.services.searchService.embeddedAppsPath}`,
    documents: `${config.services.searchService.baseUrl}${config.services.searchService.documentsPath}`
  }
}

/**
 * Get Gateway Service URLs
 */
export const getGatewayServiceUrls = () => {
  const config = getAppConfig()
  return {
    health: `${config.services.gatewayService.baseUrl}${config.services.gatewayService.healthPath}`,
    metrics: `${config.services.gatewayService.baseUrl}${config.services.gatewayService.metricsPath}`
  }
}

/**
 * Get Knowledge Portal URLs
 */
export const getKnowledgePortalUrls = () => {
  const config = getAppConfig()
  return {
    articles: `${config.services.knowledgePortal.baseUrl}${config.services.knowledgePortal.articlesPath}`
  }
}

/**
 * Override configuration for testing or dynamic changes
 */
export const setAppConfig = (overrides: Partial<AppConfig>): void => {
  if (!appConfig) {
    appConfig = createDefaultConfig()
  }
  
  // Deep merge configuration
  appConfig = {
    ...appConfig,
    ...overrides,
    services: {
      ...appConfig.services,
      ...overrides.services
    },
    features: {
      ...appConfig.features,
      ...overrides.features
    },
    ui: {
      ...appConfig.ui,
      ...overrides.ui
    },
    websocket: {
      ...appConfig.websocket,
      ...overrides.websocket
    }
  }
}

// Export default config for convenience
export default getAppConfig
===END FILE===

===BEGIN FILE: src/config/intent-registry.ts===
// Intent registry defines all possible intents and their mappings
export const intentRegistry = {
  // Original intents
  'credit_card_transactions': {
    id: 'credit_card_transactions',
    name: 'Credit card transactions',
    icon: 'credit-card',
    embedRoute: '/credit-card',
    description: 'View and manage credit card transactions',
    keywords: ['credit', 'card', 'transaction', 'payment', 'charge', 'recurring', 'subscription']
  },
  'customer_details': {
    id: 'customer_details', 
    name: 'Customer details',
    icon: 'user',
    embedRoute: '/customer-info',
    description: 'View and update customer information',
    keywords: ['customer', 'profile', 'details', 'information', 'ccaas', 'address']
  },
  'account_inquiry': {
    id: 'account_inquiry',
    name: 'Account inquiry',
    icon: 'building',
    embedRoute: '/account',
    description: 'View account balances and details',
    keywords: ['account', 'balance', 'statement', 'savings', 'checking']
  },
  'dispute_resolution': {
    id: 'dispute_resolution',
    name: 'Dispute resolution',
    icon: 'alert-triangle',
    embedRoute: '/disputes',
    description: 'Handle transaction disputes',
    keywords: ['dispute', 'chargeback', 'fraud', 'unauthorized', 'complaint']
  },
  'loan_services': {
    id: 'loan_services',
    name: 'Loan services',
    icon: 'wallet',
    embedRoute: '/loans',
    description: 'Manage loans and mortgages',
    keywords: ['loan', 'mortgage', 'interest', 'payment', 'refinance']
  },
  'travel_notification': {
    id: 'travel_notification',
    name: 'Travel notification',
    icon: 'plane',
    embedRoute: '/travel',
    description: 'Set travel notifications for cards',
    keywords: ['travel', 'overseas', 'abroad', 'international', 'notification']
  },
  
  // Banking scenario intents
  'fraud_alert': {
    id: 'fraud_alert',
    name: 'Fraud alert',
    icon: 'shield-alert',
    embedRoute: '/fraud-alert',
    description: 'Handle security fraud alerts and suspicious transactions',
    keywords: ['fraud', 'suspicious', 'security', 'alert', 'unauthorized', 'scam', 'phishing']
  },
  'mortgage_application': {
    id: 'mortgage_application',
    name: 'Mortgage application',
    icon: 'home',
    embedRoute: '/mortgage',
    description: 'Process mortgage applications and property financing',
    keywords: ['mortgage', 'home', 'property', 'loan', 'financing', 'house', 'first-time', 'buyer']
  },
  'account_upgrade': {
    id: 'account_upgrade',
    name: 'Account upgrade',
    icon: 'trending-up',
    embedRoute: '/account-upgrade',
    description: 'Upgrade customer account tiers and benefits',
    keywords: ['upgrade', 'premier', 'advance', 'jade', 'benefits', 'tier', 'account', 'level']
  },
  'international_transfer': {
    id: 'international_transfer',
    name: 'International transfer',
    icon: 'globe',
    embedRoute: '/international-transfer',
    description: 'Process international wire transfers and currency exchange',
    keywords: ['international', 'wire', 'transfer', 'overseas', 'currency', 'exchange', 'swift', 'foreign']
  },
  'investment_advice': {
    id: 'investment_advice',
    name: 'Investment advice',
    icon: 'trending-up',
    embedRoute: '/investment',
    description: 'Provide investment guidance and portfolio advice',
    keywords: ['investment', 'portfolio', 'stocks', 'bonds', 'funds', 'wealth', 'advisor', 'market']
  },
  'business_loan': {
    id: 'business_loan',
    name: 'Business loan',
    icon: 'briefcase',
    embedRoute: '/business-loan',
    description: 'Process business loan applications and commercial lending',
    keywords: ['business', 'commercial', 'loan', 'enterprise', 'company', 'corporate', 'finance', 'lending']
  },
  'student_overdraft': {
    id: 'student_overdraft',
    name: 'Student overdraft',
    icon: 'graduation-cap',
    embedRoute: '/student-overdraft',
    description: 'Manage student overdraft facilities and education banking',
    keywords: ['student', 'overdraft', 'education', 'university', 'college', 'graduate', 'study']
  },
  'credit_increase': {
    id: 'credit_increase',
    name: 'Credit increase',
    icon: 'credit-card',
    embedRoute: '/credit-increase',
    description: 'Process credit limit increase requests',
    keywords: ['credit', 'limit', 'increase', 'raise', 'higher', 'expand', 'boost']
  },
  'portfolio_review': {
    id: 'portfolio_review',
    name: 'Portfolio review',
    icon: 'pie-chart',
    embedRoute: '/portfolio-review',
    description: 'Review and analyze investment portfolios',
    keywords: ['portfolio', 'review', 'analysis', 'performance', 'allocation', 'rebalance', 'investment']
  },
  'student_loan': {
    id: 'student_loan',
    name: 'Student loan',
    icon: 'graduation-cap',
    embedRoute: '/student-loan',
    description: 'Process student loan applications and education financing',
    keywords: ['student', 'loan', 'education', 'tuition', 'university', 'college', 'study', 'finance']
  },
  'standing_order': {
    id: 'standing_order',
    name: 'Standing order',
    icon: 'repeat',
    embedRoute: '/standing-order',
    description: 'Set up and manage recurring payment orders',
    keywords: ['standing', 'order', 'recurring', 'automatic', 'regular', 'payment', 'schedule']
  },
  'overdraft_request': {
    id: 'overdraft_request',
    name: 'Overdraft request',
    icon: 'minus-circle',
    embedRoute: '/overdraft',
    description: 'Process overdraft facility requests and arrangements',
    keywords: ['overdraft', 'facility', 'arrangement', 'buffer', 'protection', 'negative', 'balance']
  },
  'first_credit_card': {
    id: 'first_credit_card',
    name: 'First credit card',
    icon: 'credit-card',
    embedRoute: '/first-credit-card',
    description: 'Guide first-time credit card applications',
    keywords: ['first', 'credit', 'card', 'new', 'application', 'initial', 'starter', 'beginner']
  }
}

export type IntentId = keyof typeof intentRegistry

// Helper function to get intent details
export function getIntentDetails(intentId: string) {
  return intentRegistry[intentId as IntentId] || null
}

// Helper function to detect intent from text (simplified)
export function detectIntentFromText(text: string): IntentId | null {
  const lowerText = text.toLowerCase()
  
  for (const [id, intent] of Object.entries(intentRegistry)) {
    const hasKeyword = intent.keywords.some(keyword => 
      lowerText.includes(keyword.toLowerCase())
    )
    if (hasKeyword) {
      return id as IntentId
    }
  }
  
  return null
}

// Mock AI intent detection (in real app, this would call AI service)
export function detectIntentsFromConversation(transcript: string[]): Array<{
  id: string
  confidence: number
}> {
  const intentScores = new Map<string, number>()
  
  // Analyze transcript for keywords
  transcript.forEach(message => {
    const intent = detectIntentFromText(message)
    if (intent) {
      const current = intentScores.get(intent) || 0
      intentScores.set(intent, current + 1)
    }
  })
  
  // Convert to array with confidence scores
  const results = Array.from(intentScores.entries()).map(([id, count]) => ({
    id,
    confidence: Math.min(95, 50 + (count * 15)) // Mock confidence calculation
  }))
  
  // Sort by confidence
  return results.sort((a, b) => b.confidence - a.confidence)
}
===END FILE===

===BEGIN FILE: src/contexts/auth-context.tsx===
import { createContext, useContext, useState, useEffect, ReactNode } from 'react'
import { useNavigate } from 'react-router-dom'

interface User {
  id: string
  name: string
  email: string
  role: 'agent' | 'chat_agent' | 'supervisor' | 'admin' | 'manager'
  department: string
}

interface AuthContextType {
  user: User | null
  isAuthenticated: boolean
  login: (email: string, password: string) => Promise<boolean>
  logout: () => void
  isLoading: boolean
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

// Mock users for demo
const MOCK_USERS = [
  {
    email: 'agent@hsbc.com',
    password: 'demo123',
    user: {
      id: 'agent-001',
      name: 'Sarah Thompson',
      email: 'agent@hsbc.com',
      role: 'agent' as const,
      department: 'Premier Banking'
    }
  },
  {
    email: 'chat@hsbc.com',
    password: 'demo123',
    user: {
      id: 'chat-001',
      name: 'Emma Rodriguez',
      email: 'chat@hsbc.com',
      role: 'chat_agent' as const,
      department: 'Digital Support'
    }
  },
  {
    email: 'supervisor@hsbc.com',
    password: 'demo123',
    user: {
      id: 'sup-001',
      name: 'Michael Chen',
      email: 'supervisor@hsbc.com',
      role: 'supervisor' as const,
      department: 'Call Center Operations'
    }
  },
  {
    email: 'manager@hsbc.com',
    password: 'demo123',
    user: {
      id: 'mgr-001',
      name: 'David Williams',
      email: 'manager@hsbc.com',
      role: 'manager' as const,
      department: 'Customer Experience'
    }
  },
  {
    email: 'admin@hsbc.com',
    password: 'admin123',
    user: {
      id: 'admin-001',
      name: 'Victoria Sterling',
      email: 'admin@hsbc.com',
      role: 'admin' as const,
      department: 'IT Administration'
    }
  }
]

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const navigate = useNavigate()

  // Check for existing session on mount
  useEffect(() => {
    const storedUser = localStorage.getItem('hsbc-user')
    if (storedUser) {
      try {
        setUser(JSON.parse(storedUser))
      } catch (error) {
        // Failed to parse stored user
        localStorage.removeItem('hsbc-user')
      }
    }
    setIsLoading(false)
  }, [])

  const login = async (email: string, password: string): Promise<boolean> => {
    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 800))

    // Find matching user
    const mockUser = MOCK_USERS.find(
      u => u.email.toLowerCase() === email.toLowerCase() && u.password === password
    )

    if (mockUser) {
      setUser(mockUser.user)
      localStorage.setItem('hsbc-user', JSON.stringify(mockUser.user))
      
      // Clear notifications on fresh login
      localStorage.removeItem('ccaas-notifications')
      
      // Navigate to dashboard
      navigate('/dashboard')
      
      return true
    }

    return false
  }

  const logout = () => {
    setUser(null)
    
    // Clear all localStorage data
    localStorage.removeItem('hsbc-user')
    localStorage.removeItem('ccaas-ui-role') // Clear role selection
    localStorage.removeItem('ccaas-agent-settings') // Clear agent settings
    localStorage.removeItem('ccaas-column-layout') // Clear column layout
    localStorage.removeItem('ccaas-notification-preferences') // Clear notification settings
    localStorage.removeItem('agent-status-storage') // Clear call state persistence
    
    // Clear any other localStorage keys that might contain user data
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('ccaas-') || key.startsWith('hsbc-')) {
        localStorage.removeItem(key)
      }
    })
    
    navigate('/login')
  }

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        login,
        logout,
        isLoading
      }}
    >
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}
===END FILE===

===BEGIN FILE: src/contexts/role-context.tsx===
import React, { createContext, useContext, useState, useEffect, useRef, ReactNode } from 'react'
import { useToast } from '../hooks/use-toast'

export type UserRole = 'agent' | 'chat_agent' | 'supervisor' | 'manager' | 'admin'

export interface RoleConfig {
  widgets: {
    customer: boolean
    transcript: boolean
    sentiment: boolean
    summary: boolean
    intent: boolean
    actions: boolean
    knowledge: boolean
    priority: boolean
  }
  features: {
    spaceCopilot: boolean
    kmsAccess: boolean
    embeddedApps: boolean
    settingsAccess: boolean
    telemetryAccess: boolean
  }
  intents: string[]
  columns: {
    canCollapse: boolean
    canResize: boolean
    persistLayout: boolean
  }
}

const DEFAULT_CONFIGS: Record<UserRole, RoleConfig> = {
  agent: {
    widgets: {
      customer: true,
      transcript: true,
      sentiment: true,
      summary: true,
      intent: true,
      actions: true,
      knowledge: true,
      priority: true
    },
    features: {
      spaceCopilot: true,
      kmsAccess: true,
      embeddedApps: true,
      settingsAccess: true,
      telemetryAccess: false
    },
    intents: [
      'credit_card_transactions',
      'account_inquiry',
      'customer_details',
      'payment_issues',
      'general_support'
    ],
    columns: {
      canCollapse: true,
      canResize: true,
      persistLayout: true
    }
  },
  chat_agent: {
    widgets: {
      customer: true,
      transcript: true,
      sentiment: true,
      summary: false,
      intent: true,
      actions: true,
      knowledge: true,
      priority: false
    },
    features: {
      spaceCopilot: true,
      kmsAccess: true,
      embeddedApps: true,
      settingsAccess: true,
      telemetryAccess: false
    },
    intents: [
      'customer_details',
      'general_support',
      'account_inquiry'
    ],
    columns: {
      canCollapse: false,
      canResize: false,
      persistLayout: true
    }
  },
  supervisor: {
    widgets: {
      customer: true,
      transcript: true,
      sentiment: true,
      summary: true,
      intent: true,
      actions: true,
      knowledge: true,
      priority: true
    },
    features: {
      spaceCopilot: true,
      kmsAccess: true,
      embeddedApps: true,
      settingsAccess: true,
      telemetryAccess: true
    },
    intents: [
      'credit_card_transactions',
      'account_inquiry',
      'customer_details',
      'payment_issues',
      'general_support',
      'dispute_resolution',
      'fraud_detection',
      'team_management'
    ],
    columns: {
      canCollapse: true,
      canResize: true,
      persistLayout: true
    }
  },
  manager: {
    widgets: {
      customer: true,
      transcript: true,
      sentiment: true,
      summary: true,
      intent: true,
      actions: true,
      knowledge: true,
      priority: true
    },
    features: {
      spaceCopilot: true,
      kmsAccess: true,
      embeddedApps: true,
      settingsAccess: true,
      telemetryAccess: true
    },
    intents: [
      'credit_card_transactions',
      'account_inquiry',
      'customer_details',
      'payment_issues',
      'general_support',
      'dispute_resolution',
      'fraud_detection',
      'team_management',
      'performance_analysis'
    ],
    columns: {
      canCollapse: true,
      canResize: true,
      persistLayout: true
    }
  },
  admin: {
    widgets: {
      customer: true,
      transcript: true,
      sentiment: true,
      summary: true,
      intent: true,
      actions: true,
      knowledge: true,
      priority: true
    },
    features: {
      spaceCopilot: true,
      kmsAccess: true,
      embeddedApps: true,
      settingsAccess: true,
      telemetryAccess: true
    },
    intents: [
      'credit_card_transactions',
      'account_inquiry',
      'customer_details',
      'payment_issues',
      'general_support',
      'dispute_resolution',
      'fraud_detection',
      'team_management',
      'performance_analysis',
      'system_administration'
    ],
    columns: {
      canCollapse: true,
      canResize: true,
      persistLayout: true
    }
  }
}

interface RoleContextType {
  currentRole: UserRole
  config: RoleConfig
  isLoading: boolean
  updateRole: (newRole: UserRole, showNotification?: boolean) => Promise<void>
  resetRole: () => void
  canAccessWidget: (widget: keyof RoleConfig['widgets']) => boolean
  canAccessFeature: (feature: keyof RoleConfig['features']) => boolean
  getAvailableIntents: () => string[]
  canManageColumns: () => boolean
}

const RoleContext = createContext<RoleContextType | undefined>(undefined)

export function RoleProvider({ children }: { children: ReactNode }) {
  const [currentRole, setCurrentRole] = useState<UserRole>('agent')
  const [config, setConfig] = useState<RoleConfig>(DEFAULT_CONFIGS['agent'])
  const [isLoading, setIsLoading] = useState(false)
  const { toast } = useToast()
  const isInitialMount = useRef(true)

  // Simulate fetching role config from API
  const fetchRoleConfig = async (role: UserRole): Promise<RoleConfig> => {
    setIsLoading(true)
    
    try {
      // Remove artificial delay for demo responsiveness
      // await new Promise(resolve => setTimeout(resolve, 500))
      
      // In production, this would be:
      // const response = await fetch(`/api/ui-config/roles/${role}`)
      // return await response.json()
      
      return DEFAULT_CONFIGS[role]
    } catch (error) {
      toast({
        title: "Configuration Error",
        description: "Failed to load role configuration. Using defaults.",
        variant: "destructive"
      })
      return DEFAULT_CONFIGS[role]
    } finally {
      setIsLoading(false)
    }
  }

  const updateRole = async (newRole: UserRole, showNotification = true) => {
    if (newRole === currentRole) return

    const newConfig = await fetchRoleConfig(newRole)
    
    setCurrentRole(newRole)
    setConfig(newConfig)
    
    // Persist role selection
    localStorage.setItem('ccaas-ui-role', newRole)
    
    
    // Only show notification if explicitly requested (not on initial load)
    if (showNotification) {
      const roleNames = {
        agent: 'Voice Agent',
        chat_agent: 'Chat Agent',
        supervisor: 'Supervisor',
        manager: 'Manager',
        admin: 'Administrator'
      }
      
      toast({
        title: "Role Updated",
        description: `Switched to ${roleNames[newRole]} role`,
      })
    }
  }

  const resetRole = () => {
    setCurrentRole('agent')
    setConfig(DEFAULT_CONFIGS['agent'])
    localStorage.removeItem('ccaas-ui-role')
  }

  // Load persisted role on mount
  useEffect(() => {
    // Only run once on initial mount
    if (!isInitialMount.current) return
    isInitialMount.current = false
    
    const savedRole = localStorage.getItem('ccaas-ui-role') as UserRole
    if (savedRole && savedRole !== currentRole) {
      // Don't show notification on initial load
      updateRole(savedRole, false)
    }
  }, [])

  const value: RoleContextType = {
    currentRole,
    config,
    isLoading,
    updateRole,
    resetRole,
    // Helper functions
    canAccessWidget: (widget: keyof RoleConfig['widgets']) => config?.widgets?.[widget] ?? false,
    canAccessFeature: (feature: keyof RoleConfig['features']) => config?.features?.[feature] ?? false,
    getAvailableIntents: () => config?.intents ?? [],
    canManageColumns: () => {
      if (!config || !config.columns) return false
      return config.columns.canCollapse || config.columns.canResize
    }
  }

  return (
    <RoleContext.Provider value={value}>
      {children}
    </RoleContext.Provider>
  )
}

export function useRoleConfig() {
  const context = useContext(RoleContext)
  if (context === undefined) {
    throw new Error('useRoleConfig must be used within a RoleProvider')
  }
  return context
}
===END FILE===

===BEGIN FILE: src/contexts/theme-context.tsx===
import { createContext, useContext, useEffect, useState } from 'react'

type Theme = 'dark' | 'light' | 'system'

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

const initialState: ThemeProviderState = {
  theme: 'system',
  setTheme: () => null,
}

const ThemeProviderContext = createContext<ThemeProviderState>(initialState)

export function ThemeProvider({
  children,
  defaultTheme = 'system',
  storageKey = 'ccaas-ui-theme',
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  useEffect(() => {
    const root = window.document.documentElement

    root.classList.remove('light', 'dark')

    if (theme === 'system') {
      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)')
        .matches
        ? 'dark'
        : 'light'

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error('useTheme must be used within a ThemeProvider')

  return context
}
===END FILE===

===BEGIN FILE: src/contexts/websocket-context.tsx===
import React, { createContext, useContext, useEffect, useRef, useCallback, useMemo } from 'react'
import { useAgentStore } from '../stores/agent-store'
import { useToast } from '../hooks/use-toast'
import { getWebSocketUrl, getAppConfig } from '../config/app-config'
import { useAgentProfiles } from '../hooks/use-config'
import { useRoleConfig } from './role-context'
import { useAuth } from './auth-context'
import { traceLog } from '../utils/debug'

interface WebSocketContextValue {
  connect: (agentId: string, callerId: string, port?: number) => void
  disconnect: () => void
  sendMessage: (message: any) => void
  isConnected: boolean
  clearStore?: (dataType: string) => void
  hasCustomerContext: boolean
}

const WebSocketContext = createContext<WebSocketContextValue | null>(null)

export const useWebSocket = () => {
  const context = useContext(WebSocketContext)
  if (!context) {
    // Return a safe no-op implementation during transitions (HMR, role changes, etc.)
    // This prevents crashes while maintaining functionality when provider is available
    return {
      connect: () => {},
      disconnect: () => {},
      sendMessage: () => {},
      isConnected: false,
      clearStore: () => {},
      hasCustomerContext: false
    }
  }
  return context
}

interface WebSocketProviderProps {
  children: React.ReactNode
  customWsUrl?: string
}

export function WebSocketProvider({ children, customWsUrl }: WebSocketProviderProps) {
  const wsRef = useRef<WebSocket | null>(null)
  const heartbeatIntervalRef = useRef<number | null>(null)
  const reconnectTimeoutRef = useRef<number | null>(null)
  const reconnectAttemptsRef = useRef<number>(0)
  const intentionalDisconnectRef = useRef<boolean>(false)
  const hasAutoConnected = useRef(false)
  
  // Get configuration values
  const config = getAppConfig()
  const { maxReconnectAttempts, maxReconnectDelay } = config.websocket
  
  const { toast } = useToast()
  
  // Get current user role for intent-to-app mapping
  const { currentRole } = useRoleConfig()
  
  // Get authenticated user
  const { user } = useAuth()
  
  // Use the global store for the agent dashboard
  const {
    agentData,
    setConnectionStatus,
    updateSentiment,
    updatePriority,
    updateSummary,
    updateIntent,
    updateActions,
    updateKnowledgeArticles,
    addTranscriptEntry,
    updateCustomer,
    updateAgentData,
    isConnected,
    clearSentiment,
    clearPriority,
    clearSummary,
    clearIntent,
    clearActions,
    clearTranscript,
    clearKnowledgeArticles,
    clearCustomer,
  } = useAgentStore()

  const handleMessage = useCallback((event: MessageEvent) => {
    try {
      const data = JSON.parse(event.data)
      
      // 🔍 Log all incoming WebSocket messages for debugging
      
      // Route message based on type
      switch (data.type) {
        case 'sentiment':
          // Parse sentiment from backend which sends: {sentiment: 'positive'/'negative'/'neutral', confidence: 0.85}
          const sentimentValue = data.sentiment || 'neutral'
          const confidence = data.confidence || data.score || 0.5
          
          updateSentiment({
            score: Math.round(confidence * 100),  // Convert confidence to percentage
            label: sentimentValue,  // Use sentiment as label
            trend: data.trend || 'stable',
            change: data.change || 0,
          })
          break
          
        case 'priority':
          updatePriority({
            level: data.level || data.priority || 'MEDIUM',
            waitTime: data.waitTime || 0,
            estimatedResolution: data.estimatedResolution || 0,
            escalation: data.escalation || false,
          })
          // Also update agent data with queue position
          updateAgentData({
            queuePosition: data.queuePosition || 1
          })
          break
          
        case 'summary':
          // Handle summary as array or string
          let summaryText = ''
          if (Array.isArray(data.summary)) {
            summaryText = data.summary.join('\n')
          } else {
            summaryText = data.summary || data.text || ''
          }
          updateSummary({
            text: summaryText,
            category: data.category || 'General',
            lastUpdated: new Date(),
            confidence: data.confidence || 0,
          })
          break
          
        case 'intent': {
          // Derive detection latency from timestamp/deliveryTime when available
          let tsMs: number | undefined
          if (data.timestamp) {
            tsMs = new Date(data.timestamp).getTime()
          } else if (typeof data.deliveryTime === 'number') {
            // deliveryTime may be epoch seconds or ms; detect unit
            tsMs = data.deliveryTime > 1e12 ? data.deliveryTime : data.deliveryTime * 1000
          }
          const detectionMs = tsMs ? Math.max(0, Date.now() - tsMs) : undefined

          // Map accuracy label from confidence if explicit accuracy not provided
          const confidence = data.confidence || 0
          const accuracy = (data.intentAccuracy ?? data.accuracy) ?? (
            confidence >= 0.85 ? 'High' : confidence >= 0.6 ? 'Medium' : 'Low'
          )

          // Extract enriched app data from Gateway (new fields from intent-to-app mapping)
          const intentData = {
            type: data.intent || data.intentType || 'UNKNOWN',
            confidence,
            detectionMs,
            accuracy,
            appUrl: data.appUrl,      // Enriched by Gateway with embedded app URL
            appTitle: data.appTitle   // Enriched by Gateway with embedded app title
          }

          updateIntent(intentData)
          break
        }
          
        case 'actions':
          updateActions(data.actions || [])
          break
          
        case 'knowledge':
        case 'knowledge_articles':
        case 'knowledge_update':
          // Handle AI-provided knowledge article recommendations
          updateKnowledgeArticles(data.articles || data.knowledgeArticles || [])
          break
          
        case 'transcript':
          addTranscriptEntry({
            id: `${Date.now()}`,
            timestamp: new Date(data.timestamp || Date.now()),
            speaker: data.speaker || 'agent',
            text: data.text || '',
          })
          break
          
        case 'customer':
          // Accept customer data from PostgreSQL via WebSocket
          traceLog('🔍 [TRACE] Customer data received from WebSocket - BEFORE any processing:', {
            rawCustomerData: data.customer,
            hasId: !!data.customer?.id,
            hasCustomerId: !!data.customer?.customerId,
            allFields: Object.keys(data.customer || {}),
            fullMessage: data,
            timestamp: new Date().toISOString()
          })
          
          // Map accountType to tier for compatibility
          if (data.customer && data.customer.accountType) {
            data.customer.tier = data.customer.accountType
          }
          
          // IMPORTANT: Backend might send customerId instead of id
          // Check if we need to map customerId to id for frontend compatibility  
          if (data.customer && !data.customer.id && data.customer.customerId) {
            traceLog('🔧 [TRACE] Mapping customerId to id for frontend compatibility:', {
              beforeMapping: { ...data.customer },
              customerId: data.customer.customerId
            })
            data.customer.id = data.customer.customerId
          }
          
          // BACKUP: If still no ID, generate one from the customer name
          // This should no longer be needed after fixing the Java service
          if (data.customer && !data.customer.id && data.customer.name) {
            const generatedId = `CUST-${data.customer.name.replace(/\s+/g, '-').toUpperCase()}-${Date.now().toString().slice(-6)}`
            traceLog('⚠️ [TRACE] BACKUP: No customer ID from backend, generating one (Java service should be fixed!):', {
              customerName: data.customer.name,
              generatedId,
              beforeGeneration: { ...data.customer }
            })
            data.customer.id = generatedId
          }
          
          traceLog('📤 [TRACE] Final customer data AFTER processing, before updateCustomer:', {
            finalCustomerData: data.customer,
            hasId: !!data.customer?.id,
            hasCustomerId: !!data.customer?.customerId,
            willHaveContext: !!data.customer?.id
          })
          
          updateCustomer(data.customer)
          
          traceLog('🔔 [TRACE] Dispatching customer-context:updated event:', {
            customer: data.customer,
            hasContext: !!data.customer?.id,
            timestamp: new Date().toISOString()
          })
          
          // Notify embedded apps about customer context change
          window.dispatchEvent(new CustomEvent('customer-context:updated', {
            detail: {
              customer: data.customer,
              hasContext: !!data.customer?.id
            }
          }))
          break
          
          
        default:
      }
    } catch (error) {
      // Error parsing WebSocket message
    }
  }, [
    updateSentiment,
    updatePriority,
    updateSummary,
    updateIntent,
    updateActions,
    updateKnowledgeArticles,
    addTranscriptEntry,
    updateCustomer,
    updateAgentData,
  ])

  // Hook to get agent profiles from configuration
  const { data: agentProfiles } = useAgentProfiles()
  
  // Helper function to get agent data from configuration or fallback
  const getAgentProfile = useCallback((agentId: string) => {
    // Try to get from configuration data first
    const agent = agentProfiles?.agentProfiles?.[agentId] || agentProfiles?.defaultAgent
    
    if (agent) {
      return {
        agentName: agent.agentName,
        department: agent.department,
        agentId: agent.agentId
      }
    }
    
    // Fallback to default
    return {
      agentName: 'HSBC Agent',
      department: 'Customer Service',
      agentId: agentId.toUpperCase().replace('AGENT-', 'HSB-'),
    }
  }, [agentProfiles])

  const connect = useCallback((agentId: string, callerId: string, port = 8080) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      return
    }

    // Reset intentional disconnect flag when starting new connection
    intentionalDisconnectRef.current = false
    setConnectionStatus('connecting')
    
    // Use custom URL if provided, otherwise use configuration-based URL
    const wsUrl = customWsUrl || getWebSocketUrl({ 
      callerId,
      agentId,
      role: currentRole,  // Pass role for intent-to-app mapping
      port 
    })
    
    try {
      const ws = new WebSocket(wsUrl)
      wsRef.current = ws
      
      ws.onopen = () => {
        setConnectionStatus('connected')
        reconnectAttemptsRef.current = 0 // Reset reconnect attempts on successful connection
        
        // Use authenticated user info if available, otherwise use config profile
        const agentProfile = user ? {
          agentName: user.name,
          department: user.department,
          agentId: user.id
        } : getAgentProfile(agentId)
        
        updateAgentData({
          ...agentProfile,
          callerId,
          status: 'active',
          callDuration: 0,
        })
        
        // Start call duration timer
        const callStartTime = Date.now()
        const durationInterval = setInterval(() => {
          updateAgentData({
            callDuration: Math.floor((Date.now() - callStartTime) / 1000)
          })
        }, 1000)
        
        // Store interval reference for cleanup
        ;(ws as any)._durationInterval = durationInterval
        
        // Start heartbeat
        heartbeatIntervalRef.current = window.setInterval(() => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'heartbeat' }))
          }
        }, config.websocket.heartbeatInterval)
        
        // Send initial heartbeat
        ws.send(JSON.stringify({ type: 'heartbeat' }))
        
        // Log connection success (no user notification needed)
      }
      
      ws.onmessage = handleMessage
      
      ws.onerror = (error) => {
        // WebSocket error
        setConnectionStatus('error')
        toast({
          title: 'Connection Error',
          description: 'Failed to connect to WebSocket server',
          variant: 'destructive'
        })
      }
      
      ws.onclose = () => {
        setConnectionStatus('disconnected')
        
        // Clear heartbeat
        if (heartbeatIntervalRef.current) {
          clearInterval(heartbeatIntervalRef.current)
          heartbeatIntervalRef.current = null
        }
        
        // Clear call duration timer
        if ((ws as any)._durationInterval) {
          clearInterval((ws as any)._durationInterval)
        }
        
        // Only reconnect if this wasn't an intentional disconnect
        if (!intentionalDisconnectRef.current) {
          // Exponential backoff for reconnection
          if (reconnectAttemptsRef.current < maxReconnectAttempts) {
            reconnectAttemptsRef.current++
            const delay = Math.min(
              config.websocket.reconnectInterval * Math.pow(2, reconnectAttemptsRef.current - 1),
              maxReconnectDelay
            )
            
            
            reconnectTimeoutRef.current = window.setTimeout(() => {
              connect(agentId, callerId, port)
            }, delay)
          } else {
            // Max reconnection attempts reached
            setConnectionStatus('error')
          }
        } else {
        }
      }
    } catch (error) {
      // Failed to create WebSocket
      setConnectionStatus('error')
    }
  }, [setConnectionStatus, handleMessage, user, getAgentProfile, updateAgentData, toast, config, currentRole])

  const disconnect = useCallback(() => {
    
    // Set intentional disconnect flag to prevent reconnection
    intentionalDisconnectRef.current = true
    reconnectAttemptsRef.current = 0  // Reset reconnect attempts
    
    // Clear reconnect timeout
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current)
      reconnectTimeoutRef.current = null
    }
    
    // Clear heartbeat
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current)
      heartbeatIntervalRef.current = null
    }
    
    // Close WebSocket
    if (wsRef.current) {
      wsRef.current.close()
      wsRef.current = null
    }
    
    setConnectionStatus('disconnected')
  }, [setConnectionStatus])

  const sendMessage = useCallback((message: any) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message))
    } else {
      // WebSocket not connected, cannot send message
    }
  }, [])
  
  const clearStore = useCallback((dataType: string) => {
    switch(dataType) {
      case 'sentiment':
        clearSentiment?.()
        break
      case 'priority':
        clearPriority?.()
        break
      case 'summary':
        clearSummary?.()
        break
      case 'intent':
        clearIntent?.()
        break
      case 'actions':
        clearActions?.()
        break
      case 'knowledge':
      case 'knowledge_articles':
        clearKnowledgeArticles?.()
        break
      case 'messages':
      case 'transcript':
        clearTranscript?.()
        break
      case 'customer':
        clearCustomer?.()
        break
      default:
        // Unknown data type for clearing
    }
  }, [clearSentiment, clearPriority, clearSummary, clearIntent, clearActions, clearKnowledgeArticles, clearTranscript, clearCustomer])

  // Cleanup on unmount
  // Auto-connect if custom URL is provided (for multi-agent view)
  useEffect(() => {
    if (customWsUrl && !hasAutoConnected.current) {
      hasAutoConnected.current = true
      // Extract agentId and callerId from URL
      const url = new URL(customWsUrl.replace('ws://', 'http://'))
      const params = new URLSearchParams(url.search)
      const agentId = params.get('agentId') || 'agent-001'
      const callerId = params.get('callerId') || 'caller-001'
      
      // Auto-connect with extracted parameters
      connect(agentId, callerId)
    }
  }, [customWsUrl, connect])
  
  useEffect(() => {
    return () => {
      // Only disconnect when the component truly unmounts
      // Set intentional disconnect flag to prevent reconnection
      intentionalDisconnectRef.current = true
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.close()
      }
    }
  }, [])

  // Calculate hasCustomerContext with logging  
  const hasCustomerContext = !!(agentData?.customer?.id)
  traceLog('🧮 [TRACE] WebSocketContext hasCustomerContext calculation:', {
    hasCustomerContext,
    agentDataExists: !!agentData,
    customerExists: !!agentData?.customer,
    customerId: agentData?.customer?.id,
    customerName: agentData?.customer?.name,
    timestamp: new Date().toISOString()
  })

  const value: WebSocketContextValue = {
    connect,
    disconnect,
    sendMessage,
    isConnected,
    clearStore,
    hasCustomerContext
  }

  return (
    <WebSocketContext.Provider value={value}>
      {children}
    </WebSocketContext.Provider>
  )
}
===END FILE===

===BEGIN FILE: src/hooks/use-agent-settings.ts===
import { useState, useEffect } from 'react'

interface AgentSettings {
  calls: {
    autoAccept: boolean
    afterCallWorkTime: number
    doNotDisturb: {
      enabled: boolean
      duration: 15 | 30 | 60
      originalStatus?: string
    }
    confirmBeforeEnd: boolean
    requireActionsCompletion: boolean
  }
  audio: {
    ringtone: string
    volume: number
    outputDevice: string
  }
  notifications: {
    desktop: boolean
    sounds: {
      incoming: boolean
      end: boolean
      error: boolean
    }
  }
  privacy: {
    lastCacheCleared?: string
    screenshotProtection?: boolean
    idleTimeout: number
    rememberCallHistory: boolean
  }
  accessibility: {
    textSize: 'small' | 'medium' | 'large'
    highContrast: boolean
  }
  interface: {
    spaceCopilotMode: 'column' | 'overlay'
    spaceCopilotOverlayPosition: 'right' | 'left'
    showWidgetBorders: boolean
    compactMode: boolean
    showTranscript: boolean
    autoCloseKnowledgeOnCallEnd: boolean
  }
  language: string
}

const DEFAULT_AGENT_SETTINGS: AgentSettings = {
  calls: {
    autoAccept: false,
    afterCallWorkTime: 30,
    doNotDisturb: {
      enabled: false,
      duration: 15
    },
    confirmBeforeEnd: true,
    requireActionsCompletion: false
  },
  audio: {
    ringtone: 'default',
    volume: 70,
    outputDevice: 'default'
  },
  notifications: {
    desktop: true,
    sounds: {
      incoming: true,
      end: true,
      error: true
    }
  },
  privacy: {
    idleTimeout: 30,
    rememberCallHistory: false
  },
  accessibility: {
    textSize: 'medium',
    highContrast: false
  },
  interface: {
    spaceCopilotMode: 'column',
    spaceCopilotOverlayPosition: 'right',
    showWidgetBorders: true,
    compactMode: false,
    showTranscript: true,
    autoCloseKnowledgeOnCallEnd: true
  },
  language: 'en'
}

// Custom event for real-time settings updates within the same tab
const SETTINGS_CHANGE_EVENT = 'agent-settings-changed'

// Helper function to dispatch settings change event
export function dispatchSettingsChange() {
  window.dispatchEvent(new CustomEvent(SETTINGS_CHANGE_EVENT))
}

export function useAgentSettings() {
  const [settings, setSettings] = useState<AgentSettings>(() => {
    const saved = localStorage.getItem('agent-settings')
    return saved ? { ...DEFAULT_AGENT_SETTINGS, ...JSON.parse(saved) } : DEFAULT_AGENT_SETTINGS
  })

  // Function to update settings from localStorage
  const updateSettingsFromStorage = () => {
    const saved = localStorage.getItem('agent-settings')
    if (saved) {
      try {
        const parsedSettings = JSON.parse(saved)
        setSettings({ ...DEFAULT_AGENT_SETTINGS, ...parsedSettings })
      } catch (error) {
        // Failed to parse agent settings
      }
    }
  }

  // Function to update settings and save to localStorage
  const updateSettings = (updates: Partial<AgentSettings>) => {
    setSettings(prev => {
      const newSettings = { ...prev, ...updates }
      localStorage.setItem('agent-settings', JSON.stringify(newSettings))
      dispatchSettingsChange() // Dispatch for real-time updates
      return newSettings
    })
  }

  // Helper function to update nested settings
  const updateNestedSettings = <K extends keyof AgentSettings>(
    section: K,
    updates: Partial<AgentSettings[K]>
  ) => {
    const currentSection = settings[section]
    updateSettings({
      [section]: { ...(currentSection as object), ...updates }
    } as Partial<AgentSettings>)
  }

  // Listen for both storage events (cross-tab) and custom events (same-tab)
  useEffect(() => {
    // Handle storage events (cross-tab sync)
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === 'agent-settings') {
        updateSettingsFromStorage()
      }
    }

    // Handle custom events (same-tab real-time updates)
    const handleCustomEvent = () => {
      updateSettingsFromStorage()
    }

    window.addEventListener('storage', handleStorageChange)
    window.addEventListener(SETTINGS_CHANGE_EVENT, handleCustomEvent)
    
    return () => {
      window.removeEventListener('storage', handleStorageChange)
      window.removeEventListener(SETTINGS_CHANGE_EVENT, handleCustomEvent)
    }
  }, [])

  return {
    settings,
    updateSettings,
    updateNestedSettings
  }
}
===END FILE===

===BEGIN FILE: src/hooks/use-agent-status.ts===
import { useEffect, useCallback, useRef } from 'react'
import { useAgentStatusStore, AgentStatus } from '../stores/agent-status-store'
import { useAgentSettings } from './use-agent-settings'
import { useToast } from './use-toast'

interface UseAgentStatusOptions {
  onStatusChange?: (status: AgentStatus) => void
  onAutoCall?: () => void
  autoCallDelay?: number // Delay before auto-triggering call (ms)
  betweenCallDelay?: number // Delay between calls (ms)
}

export function useAgentStatus({
  onStatusChange,
  onAutoCall,
  autoCallDelay = 4000, // 4 seconds default
  betweenCallDelay = 10000 // 10 seconds between calls as requested
}: UseAgentStatusOptions = {}) {
  const { toast } = useToast()
  const { settings } = useAgentSettings()
  const autoCallTimerRef = useRef<NodeJS.Timeout | null>(null)
  const betweenCallTimerRef = useRef<NodeJS.Timeout | null>(null)
  
  const {
    status,
    statusSince,
    callsHandledToday,
    totalHandleTime,
    callsInQueue,
    autoCallEnabled,
    lastCallEndTime,
    timeInStatus,
    afterCallWorkSecondsRemaining,
    doNotDisturbSecondsRemaining,
    setStatus: setStoreStatus,
    incrementCallsHandled,
    updateHandleTime,
    setCallsInQueue,
    setAutoCallEnabled,
    setLastCallEndTime,
    startAfterCallWork,
    cancelAfterCallWork,
    startDoNotDisturb,
    cancelDoNotDisturb,
    canAcceptCalls
  } = useAgentStatusStore()
  
  
  // Calculate average handle time
  const averageHandleTime = callsHandledToday > 0 
    ? Math.round(totalHandleTime / callsHandledToday) 
    : 0
  
  // Format time for display (seconds to MM:SS)
  const formatTime = useCallback((seconds: number): string => {
    const hours = Math.floor(seconds / 3600)
    const minutes = Math.floor((seconds % 3600) / 60)
    const secs = seconds % 60
    
    if (hours > 0) {
      return `${hours}h ${minutes}m`
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`
  }, [])
  
  // Get status color
  const getStatusColor = useCallback((s: AgentStatus): string => {
    switch (s) {
      case 'available':
        return 'bg-green-500'
      case 'on-call':
        return 'bg-blue-500'
      case 'break':
        return 'bg-yellow-500'
      case 'offline':
        return 'bg-red-500'
      case 'after-call-work':
        return 'bg-purple-500'
      case 'do-not-disturb':
        return 'bg-orange-500'
      default:
        return 'bg-gray-500'
    }
  }, [])
  
  // Get status icon
  const getStatusIcon = useCallback((s: AgentStatus): string => {
    switch (s) {
      case 'available':
        return '●'
      case 'on-call':
        return '●'
      case 'break':
        return '●'
      case 'offline':
        return '●'
      case 'after-call-work':
        return '●'
      case 'do-not-disturb':
        return '●'
      default:
        return '○'
    }
  }, [])
  
  // Get status label
  const getStatusLabel = useCallback((s: AgentStatus): string => {
    switch (s) {
      case 'available':
        return 'Available'
      case 'on-call':
        return 'On Call'
      case 'break':
        return 'On Break'
      case 'offline':
        return 'Offline'
      case 'after-call-work':
        return 'After Call Work'
      case 'do-not-disturb':
        return 'Do Not Disturb'
      default:
        return 'Unknown'
    }
  }, [])
  
  // Set agent status with notifications
  const setStatus = useCallback((newStatus: AgentStatus) => {
    const previousStatus = status
    
    // Validate the new status
    const validStatuses: AgentStatus[] = ['available', 'on-call', 'break', 'offline', 'after-call-work', 'do-not-disturb']
    if (!validStatuses.includes(newStatus)) {
      return
    }
    
    // Don't do anything if status hasn't changed
    if (previousStatus === newStatus) {
      return
    }
    
    // Don't allow manual status changes while on a call (except to on-call)
    if (previousStatus === 'on-call' && newStatus !== 'available' && newStatus !== 'after-call-work') {
      toast({
        title: 'Cannot change status',
        description: 'Please end the current call first',
        variant: 'destructive'
      })
      return
    }
    
    // Clear any existing timers
    if (autoCallTimerRef.current) {
      clearTimeout(autoCallTimerRef.current)
      autoCallTimerRef.current = null
    }
    if (betweenCallTimerRef.current) {
      clearTimeout(betweenCallTimerRef.current)
      betweenCallTimerRef.current = null
    }
    
    setStoreStatus(newStatus)
    
    // Only show toast for manual status changes, not automatic ones
    // Don't show toast when coming from after-call-work (automatic transition) or when going on-call
    if (previousStatus !== 'after-call-work' && newStatus !== 'on-call') {
      const description = newStatus === 'available' 
        ? 'You are now available to receive calls' 
        : newStatus === 'break'
        ? 'You are on break - no calls will be routed'
        : newStatus === 'offline'
        ? 'You are offline - sign back in when ready'
        : newStatus === 'after-call-work'
        ? 'Wrapping up call - new calls blocked'
        : newStatus === 'do-not-disturb'
        ? 'Do Not Disturb enabled'
        : 'Status updated'
        
      toast({
        title: `Status: ${getStatusLabel(newStatus)}`,
        description
      })
    }
    
    // Trigger callback
    onStatusChange?.(newStatus)
    
    // Start auto-call timer if becoming available
    if (newStatus === 'available' && autoCallEnabled && onAutoCall) {
      // Simulate queue of calls
      const queueSize = Math.floor(Math.random() * 5) + 2 // 2-6 calls in queue
      setCallsInQueue(queueSize)
      
      autoCallTimerRef.current = setTimeout(() => {
        if (useAgentStatusStore.getState().status === 'available') {
          onAutoCall()
        }
      }, autoCallDelay)
    } else {
      // Clear queue when not available
      setCallsInQueue(0)
    }
  }, [status, setStoreStatus, toast, onStatusChange, onAutoCall, autoCallEnabled, autoCallDelay, getStatusLabel, setCallsInQueue])
  
  // Handle call ended - integrate with after-call work
  const handleCallEnded = useCallback((callDuration: number) => {
    incrementCallsHandled()
    updateHandleTime(callDuration)
    setLastCallEndTime(new Date())
    
    // Decrement queue
    const currentQueue = useAgentStatusStore.getState().callsInQueue
    if (currentQueue > 0) {
      setCallsInQueue(currentQueue - 1)
    }
    
    // Start after-call work if configured and enabled
    if (settings.calls.afterCallWorkTime > 0) {
      startAfterCallWork(settings.calls.afterCallWorkTime)
      
      // Show toast notification
      toast({
        title: 'After-call work started',
        description: `Work time: ${settings.calls.afterCallWorkTime} seconds. New calls will be blocked.`,
      })
      
      return // Don't schedule next call - timer will handle it
    }
    
    // No after-call work - set to available only if not already set
    // This prevents conflicts with immediate status reset in call controls
    const currentStatus = useAgentStatusStore.getState().status
    if (currentStatus === 'on-call') {
      setStatus('available')
    } else {
    }
    
    // Get updated status after potential change and check auto-call
    const updatedStatus = useAgentStatusStore.getState().status
    const currentAutoCallEnabled = useAgentStatusStore.getState().autoCallEnabled
    
    // If still available and auto-call enabled, trigger next call after delay
    if (updatedStatus === 'available' && currentAutoCallEnabled && onAutoCall) {
      betweenCallTimerRef.current = setTimeout(() => {
        if (useAgentStatusStore.getState().status === 'available') {
          // Add more calls to queue randomly
          if (Math.random() > 0.3) { // 70% chance of new calls
            const currentQueue = useAgentStatusStore.getState().callsInQueue
            const newCalls = Math.floor(Math.random() * 3) + 1 // 1-3 new calls
            setCallsInQueue(currentQueue + newCalls)
          }
          onAutoCall()
        }
      }, betweenCallDelay)
    } else {
    }
  }, [onAutoCall, betweenCallDelay, incrementCallsHandled, updateHandleTime, setCallsInQueue, setLastCallEndTime, settings.calls.afterCallWorkTime, startAfterCallWork, toast, setStatus])
  
  // Handle Do Not Disturb toggle from settings
  const handleDoNotDisturbToggle = useCallback((enabled: boolean, duration: number) => {
    if (enabled) {
      const currentStatus = useAgentStatusStore.getState().status
      const originalStatus = currentStatus === 'do-not-disturb' ? 'available' : currentStatus
      startDoNotDisturb(duration, originalStatus)
      
      toast({
        title: 'Do Not Disturb enabled',
        description: `Calls will be blocked for ${duration} minutes`,
      })
    } else {
      cancelDoNotDisturb()
      
      toast({
        title: 'Do Not Disturb disabled',
        description: 'You are now available to receive calls',
      })
    }
  }, [startDoNotDisturb, cancelDoNotDisturb, toast])
  
  // Toggle between available and break
  const toggleAvailability = useCallback(() => {
    if (status === 'available') {
      setStatus('break')
    } else if (status === 'break' || status === 'offline') {
      setStatus('available')
    }
  }, [status, setStatus])
  
  // Cleanup timers on unmount and page unload
  useEffect(() => {
    const cleanupTimers = () => {
      if (autoCallTimerRef.current) {
        clearTimeout(autoCallTimerRef.current)
        autoCallTimerRef.current = null
      }
      if (betweenCallTimerRef.current) {
        clearTimeout(betweenCallTimerRef.current)
        betweenCallTimerRef.current = null
      }
      // Reset queue on unload to prevent phantom calls
      setCallsInQueue(0)
    }
    
    // Clean up on page unload/refresh
    const handleBeforeUnload = () => {
      cleanupTimers()
    }
    
    window.addEventListener('beforeunload', handleBeforeUnload)
    
    // Clean up on unmount
    return () => {
      cleanupTimers()
      window.removeEventListener('beforeunload', handleBeforeUnload)
    }
  }, [setCallsInQueue])
  
  // Watch for status changes from timers (after-call work expiring)
  useEffect(() => {
    
    // If status changed to available and it wasn't from a manual action
    // (happens when after-call work timer expires)
    if (status === 'available' && afterCallWorkSecondsRemaining === 0) {
      
      // Check if auto-call is enabled and we have the callback
      if (autoCallEnabled && onAutoCall) {
        
        // Simulate queue refill
        const currentQueue = useAgentStatusStore.getState().callsInQueue
        if (currentQueue === 0) {
          const queueSize = Math.floor(Math.random() * 3) + 1 // 1-3 calls
          setCallsInQueue(queueSize)
        }
        
        // Trigger auto-call with a small delay
        setTimeout(() => {
          if (useAgentStatusStore.getState().status === 'available') {
            onAutoCall()
          }
        }, 2000) // 2 second delay after ACW ends
      }
    }
  }, [status, afterCallWorkSecondsRemaining, autoCallEnabled, onAutoCall, setCallsInQueue])
  
  // Reset daily metrics at midnight
  useEffect(() => {
    const checkMidnight = () => {
      const now = new Date()
      const tomorrow = new Date(now)
      tomorrow.setDate(tomorrow.getDate() + 1)
      tomorrow.setHours(0, 0, 0, 0)
      
      const msUntilMidnight = tomorrow.getTime() - now.getTime()
      
      setTimeout(() => {
        useAgentStatusStore.getState().resetDailyMetrics()
        checkMidnight() // Schedule next check
      }, msUntilMidnight)
    }
    
    checkMidnight()
  }, [])
  
  return {
    // State
    status,
    statusSince,
    callsHandledToday,
    averageHandleTime,
    callsInQueue,
    autoCallEnabled,
    lastCallEndTime,
    timeInStatus,
    afterCallWorkSecondsRemaining,
    doNotDisturbSecondsRemaining,
    
    // Actions
    setStatus,
    toggleAvailability,
    handleCallEnded,
    setAutoCallEnabled,
    handleDoNotDisturbToggle,
    startAfterCallWork,
    cancelAfterCallWork,
    startDoNotDisturb,
    cancelDoNotDisturb,
    canAcceptCalls,
    
    // Utilities
    formatTime,
    getStatusColor,
    getStatusIcon,
    getStatusLabel
  }
}
===END FILE===

===BEGIN FILE: src/hooks/use-app-logout.ts===
import { useAuth } from '../contexts/auth-context'
import { useRoleConfig } from '../contexts/role-context'
import { useAgentStore } from '../stores/agent-store'
import { useIntentStore } from '../stores/intent-store'
import { useWebSocket } from '../contexts/websocket-context'
import { useAgentStatusStore } from '../stores/agent-status-store'

/**
 * Custom hook that provides a comprehensive logout function
 * that clears all application state including auth, role, stores, etc.
 */
export function useAppLogout() {
  const { logout } = useAuth()
  const { resetRole } = useRoleConfig()
  const { clearAgentData } = useAgentStore()
  const { clearIntents } = useIntentStore()
  const { disconnect, isConnected } = useWebSocket()
  const { endCall, setStatus } = useAgentStatusStore()

  const performLogout = () => {
    // End any active call
    endCall()
    
    // Set agent status to offline
    setStatus('offline')
    
    // Disconnect WebSocket if connected
    if (isConnected) {
      disconnect()
    }
    
    // Reset role to default
    resetRole()
    
    // Clear agent store data
    if (clearAgentData) {
      clearAgentData()
    }
    
    // Clear intent store data  
    if (clearIntents) {
      clearIntents()
    }
    
    // Clear auth (this also clears localStorage and navigates)
    logout()
  }

  return { logout: performLogout }
}
===END FILE===

===BEGIN FILE: src/hooks/use-column-layout.ts===
import { useState, useCallback, useEffect } from 'react'
import { useRoleConfig } from '../contexts/role-context'

export type ColumnState = 'normal' | 'collapsed' | 'maximized'

export interface ColumnLayoutState {
  customer: ColumnState
  embedded: ColumnState
  spaceCopilot: ColumnState
  kms: ColumnState
}

const DEFAULT_LAYOUT: ColumnLayoutState = {
  customer: 'normal',
  embedded: 'normal',
  spaceCopilot: 'normal',
  kms: 'normal'
}

const STORAGE_KEY = 'ccaas-layout-v2'

export function useColumnLayout() {
  const { canManageColumns, currentRole } = useRoleConfig()
  
  // Load persisted layout
  const loadLayout = (): ColumnLayoutState => {
    try {
      const saved = localStorage.getItem(`${STORAGE_KEY}-${currentRole}`)
      return saved ? JSON.parse(saved) : DEFAULT_LAYOUT
    } catch {
      return DEFAULT_LAYOUT
    }
  }

  const [layout, setLayout] = useState<ColumnLayoutState>(loadLayout)

  // Listen for storage changes from other components/tabs
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === `${STORAGE_KEY}-${currentRole}` && e.newValue) {
        try {
          const newLayout = JSON.parse(e.newValue)
          setLayout(newLayout)
        } catch (error) {
        }
      }
    }

    // Also listen for custom events for same-tab updates
    const handleLayoutUpdate = (e: CustomEvent) => {
      if (e.detail) {
        setLayout(e.detail)
      }
    }

    window.addEventListener('storage', handleStorageChange)
    window.addEventListener('layout-updated', handleLayoutUpdate as EventListener)
    
    return () => {
      window.removeEventListener('storage', handleStorageChange)
      window.removeEventListener('layout-updated', handleLayoutUpdate as EventListener)
    }
  }, [currentRole])

  // Save layout to localStorage and broadcast update
  const saveLayout = useCallback((newLayout: ColumnLayoutState) => {
    try {
      localStorage.setItem(`${STORAGE_KEY}-${currentRole}`, JSON.stringify(newLayout))
      // Dispatch custom event for same-tab updates (use setTimeout to avoid React warning)
      setTimeout(() => {
        window.dispatchEvent(new CustomEvent('layout-updated', { detail: newLayout }))
      }, 0)
    } catch (error) {
    }
  }, [currentRole])

  // Update a specific column state
  const updateColumn = useCallback((column: keyof ColumnLayoutState, state: ColumnState) => {
    
    if (!canManageColumns()) {
      return
    }

    setLayout(prev => {
      const newLayout = { ...prev }
      
      // If maximizing a column, collapse others
      if (state === 'maximized') {
        Object.keys(newLayout).forEach(key => {
          if (key !== column) {
            newLayout[key as keyof ColumnLayoutState] = 'collapsed'
          }
        })
      }
      
      newLayout[column] = state
      saveLayout(newLayout)
      
      // Force a re-render by creating a new object
      return { ...newLayout }
    })
  }, [canManageColumns, saveLayout])

  // Apply complete layout (for presets)
  const applyLayout = useCallback((newLayout: Partial<ColumnLayoutState>) => {
    if (!canManageColumns()) {
      return
    }
    
    setLayout(prev => {
      const updated = { ...prev, ...newLayout }
      saveLayout(updated)
      return updated
    })
  }, [canManageColumns, saveLayout])

  // Reset to default layout
  const resetLayout = useCallback(() => {
    if (!canManageColumns()) return
    
    setLayout(DEFAULT_LAYOUT)
    saveLayout(DEFAULT_LAYOUT)
  }, [canManageColumns, saveLayout])

  // Toggle column between normal and collapsed
  const toggleColumn = useCallback((column: keyof ColumnLayoutState) => {
    if (!canManageColumns()) return
    
    const currentState = layout[column]
    const newState = currentState === 'collapsed' ? 'normal' : 'collapsed'
    updateColumn(column, newState)
  }, [layout, updateColumn, canManageColumns])

  // Get CSS classes for column based on state
  const getColumnClasses = useCallback((column: keyof ColumnLayoutState): string => {
    const state = layout[column]
    
    switch (state) {
      case 'collapsed':
        return 'w-12 min-w-[48px] max-w-[48px] overflow-hidden'
      case 'maximized':
        return 'flex-1'
      case 'normal':
      default:
        // Return default column widths based on column type
        switch (column) {
          case 'customer':
            return 'w-[360px] min-w-[280px] max-w-[480px]'
          case 'embedded':
            return 'flex-1 min-w-[400px]'
          case 'spaceCopilot':
          case 'kms':
            return 'w-[640px] min-w-[400px] max-w-[800px]'
          default:
            return 'flex-1'
        }
    }
  }, [layout])

  // Check if any column is maximized
  const hasMaximizedColumn = Object.values(layout).some(state => state === 'maximized')

  return {
    layout,
    updateColumn,
    applyLayout,
    toggleColumn,
    resetLayout,
    getColumnClasses,
    hasMaximizedColumn,
    canManageColumns: canManageColumns(),
    // Helper methods
    isCollapsed: (column: keyof ColumnLayoutState) => layout[column] === 'collapsed',
    isMaximized: (column: keyof ColumnLayoutState) => layout[column] === 'maximized',
    isNormal: (column: keyof ColumnLayoutState) => layout[column] === 'normal'
  }
}
===END FILE===

===BEGIN FILE: src/hooks/use-config.ts===
/**
 * Configuration Hook
 * React hook for loading and accessing JSON configuration files
 */

import { useState, useEffect, useCallback } from 'react'
import { 
  configService,
  CustomerProfilesConfig,
  AgentProfilesConfig,
  KnowledgeArticlesConfig,
  TranscriptScenariosConfig,
  InteractionTemplatesConfig,
  loadCustomerProfiles,
  loadAgentProfiles,
  loadKnowledgeArticles,
  loadTranscriptScenarios,
  loadInteractionTemplates
} from '../services/config.service'

interface UseConfigResult<T> {
  data: T | null
  loading: boolean
  error: Error | null
  reload: () => Promise<void>
}

/**
 * Generic hook for loading any configuration
 */
export function useConfig<T = any>(configPath: string): UseConfigResult<T> {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const loadConfig = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      const configData = await configService.loadConfig<T>(configPath)
      setData(configData)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to load configuration'))
      setData(null)
    } finally {
      setLoading(false)
    }
  }, [configPath])

  useEffect(() => {
    loadConfig()
  }, [loadConfig])

  const reload = useCallback(async () => {
    configService.clearCache(configPath)
    await loadConfig()
  }, [configPath, loadConfig])

  return { data, loading, error, reload }
}

/**
 * Hook for customer profiles configuration
 */
export function useCustomerProfiles(): UseConfigResult<CustomerProfilesConfig> {
  const [data, setData] = useState<CustomerProfilesConfig | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const loadConfig = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      const configData = await loadCustomerProfiles()
      setData(configData)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to load customer profiles'))
      setData(null)
    } finally {
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    loadConfig()
  }, [loadConfig])

  const reload = useCallback(async () => {
    configService.clearCache('customer-profiles')
    await loadConfig()
  }, [loadConfig])

  return { data, loading, error, reload }
}

/**
 * Hook for agent profiles configuration
 */
export function useAgentProfiles(): UseConfigResult<AgentProfilesConfig> {
  const [data, setData] = useState<AgentProfilesConfig | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const loadConfig = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      const configData = await loadAgentProfiles()
      setData(configData)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to load agent profiles'))
      setData(null)
    } finally {
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    loadConfig()
  }, [loadConfig])

  const reload = useCallback(async () => {
    configService.clearCache('agent-profiles')
    await loadConfig()
  }, [loadConfig])

  return { data, loading, error, reload }
}

/**
 * Hook for knowledge articles configuration
 */
export function useKnowledgeArticles(): UseConfigResult<KnowledgeArticlesConfig> {
  const [data, setData] = useState<KnowledgeArticlesConfig | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const loadConfig = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      const configData = await loadKnowledgeArticles()
      setData(configData)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to load knowledge articles'))
      setData(null)
    } finally {
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    loadConfig()
  }, [loadConfig])

  const reload = useCallback(async () => {
    configService.clearCache('knowledge-articles')
    await loadConfig()
  }, [loadConfig])

  return { data, loading, error, reload }
}

/**
 * Hook for transcript scenarios configuration
 */
export function useTranscriptScenarios(): UseConfigResult<TranscriptScenariosConfig> {
  const [data, setData] = useState<TranscriptScenariosConfig | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const loadConfig = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      const configData = await loadTranscriptScenarios()
      setData(configData)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to load transcript scenarios'))
      setData(null)
    } finally {
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    loadConfig()
  }, [loadConfig])

  const reload = useCallback(async () => {
    configService.clearCache('transcript-scenarios')
    await loadConfig()
  }, [loadConfig])

  return { data, loading, error, reload }
}

/**
 * Hook for interaction templates configuration
 */
export function useInteractionTemplates(): UseConfigResult<InteractionTemplatesConfig> {
  const [data, setData] = useState<InteractionTemplatesConfig | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const loadConfig = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      const configData = await loadInteractionTemplates()
      setData(configData)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to load interaction templates'))
      setData(null)
    } finally {
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    loadConfig()
  }, [loadConfig])

  const reload = useCallback(async () => {
    configService.clearCache('interaction-templates')
    await loadConfig()
  }, [loadConfig])

  return { data, loading, error, reload }
}

/**
 * Utility hook for getting a specific customer profile by ID
 */
export function useCustomerProfile(customerId: string) {
  const { data: profiles, loading, error } = useCustomerProfiles()
  
  const customer = profiles?.customerProfiles.find(p => p.id === customerId) || null
  
  return { customer, loading, error }
}

/**
 * Utility hook for getting a specific agent profile by ID
 */
export function useAgentProfile(agentId: string) {
  const { data: profiles, loading, error } = useAgentProfiles()
  
  const agent = profiles?.agentProfiles[agentId] || profiles?.defaultAgent || null
  
  return { agent, loading, error }
}

/**
 * Utility hook for getting random mock data
 */
export function useMockData() {
  const customerProfiles = useCustomerProfiles()
  const agentProfiles = useAgentProfiles()
  const knowledgeArticles = useKnowledgeArticles()
  const transcriptScenarios = useTranscriptScenarios()
  const interactionTemplates = useInteractionTemplates()

  const loading = [
    customerProfiles.loading,
    agentProfiles.loading,
    knowledgeArticles.loading,
    transcriptScenarios.loading,
    interactionTemplates.loading
  ].some(Boolean)

  const error = [
    customerProfiles.error,
    agentProfiles.error,
    knowledgeArticles.error,
    transcriptScenarios.error,
    interactionTemplates.error
  ].find(Boolean)

  const getRandomCustomer = useCallback(() => {
    if (!customerProfiles.data) return null
    const profiles = customerProfiles.data.customerProfiles
    return profiles[Math.floor(Math.random() * profiles.length)]
  }, [customerProfiles.data])

  const getRandomAgent = useCallback((agentId?: string) => {
    if (!agentProfiles.data) return null
    if (agentId && agentProfiles.data.agentProfiles[agentId]) {
      return agentProfiles.data.agentProfiles[agentId]
    }
    const profiles = Object.values(agentProfiles.data.agentProfiles)
    return profiles[Math.floor(Math.random() * profiles.length)]
  }, [agentProfiles.data])

  const getRandomKnowledgeArticles = useCallback((count = 3) => {
    if (!knowledgeArticles.data) return []
    const articles = knowledgeArticles.data.knowledgeArticles
    const shuffled = [...articles].sort(() => 0.5 - Math.random())
    return shuffled.slice(0, count)
  }, [knowledgeArticles.data])

  const getRandomTranscriptScenario = useCallback(() => {
    if (!transcriptScenarios.data) return null
    const scenarios = transcriptScenarios.data.transcriptScenarios
    return scenarios[Math.floor(Math.random() * scenarios.length)]
  }, [transcriptScenarios.data])

  const getRandomInteractions = useCallback((count = 3) => {
    if (!interactionTemplates.data) return []
    const templates = interactionTemplates.data.interactionTemplates
    const shuffled = [...templates].sort(() => 0.5 - Math.random())
    return shuffled.slice(0, count)
  }, [interactionTemplates.data])

  return {
    loading,
    error,
    getRandomCustomer,
    getRandomAgent,
    getRandomKnowledgeArticles,
    getRandomTranscriptScenario,
    getRandomInteractions,
    // Direct access to all data
    customerProfiles: customerProfiles.data,
    agentProfiles: agentProfiles.data,
    knowledgeArticles: knowledgeArticles.data,
    transcriptScenarios: transcriptScenarios.data,
    interactionTemplates: interactionTemplates.data
  }
}
===END FILE===

===BEGIN FILE: src/hooks/use-container-size.ts===
import { useEffect, useState, useRef, useCallback } from 'react'

interface ContainerSize {
  width: number
  height: number
  isSmall: boolean
  isMedium: boolean
  isLarge: boolean
}

interface UseContainerSizeOptions {
  debounceMs?: number
  smallBreakpoint?: number
  mediumBreakpoint?: number
}

export function useContainerSize(options: UseContainerSizeOptions = {}): [
  React.RefObject<HTMLDivElement>,
  ContainerSize
] {
  const {
    debounceMs = 100,
    smallBreakpoint = 400,
    mediumBreakpoint = 800
  } = options

  const containerRef = useRef<HTMLDivElement>(null)
  const [size, setSize] = useState<ContainerSize>({
    width: 0,
    height: 0,
    isSmall: true,
    isMedium: false,
    isLarge: false
  })

  const updateSize = useCallback(() => {
    if (!containerRef.current) return

    const { offsetWidth, offsetHeight } = containerRef.current
    
    const newSize: ContainerSize = {
      width: offsetWidth,
      height: offsetHeight,
      isSmall: offsetWidth < smallBreakpoint,
      isMedium: offsetWidth >= smallBreakpoint && offsetWidth < mediumBreakpoint,
      isLarge: offsetWidth >= mediumBreakpoint
    }

    setSize(prevSize => {
      // Only update if dimensions actually changed
      if (prevSize.width !== newSize.width || prevSize.height !== newSize.height) {
        return newSize
      }
      return prevSize
    })
  }, [smallBreakpoint, mediumBreakpoint])

  useEffect(() => {
    if (!containerRef.current) return

    // Create ResizeObserver for more accurate container size detection
    const resizeObserver = new ResizeObserver((entries) => {
      if (entries.length > 0) {
        const entry = entries[0]
        const { width, height } = entry.contentRect
        
        const newSize: ContainerSize = {
          width,
          height,
          isSmall: width < smallBreakpoint,
          isMedium: width >= smallBreakpoint && width < mediumBreakpoint,
          isLarge: width >= mediumBreakpoint
        }

        setSize(prevSize => {
          if (prevSize.width !== newSize.width || prevSize.height !== newSize.height) {
            return newSize
          }
          return prevSize
        })
      }
    })

    resizeObserver.observe(containerRef.current)
    
    // Initial measurement
    updateSize()

    // Fallback with window resize for older browsers
    let debounceTimer: NodeJS.Timeout
    const handleResize = () => {
      clearTimeout(debounceTimer)
      debounceTimer = setTimeout(updateSize, debounceMs)
    }

    window.addEventListener('resize', handleResize)

    return () => {
      resizeObserver.disconnect()
      window.removeEventListener('resize', handleResize)
      clearTimeout(debounceTimer)
    }
  }, [updateSize, debounceMs])

  return [containerRef, size]
}
===END FILE===

===BEGIN FILE: src/hooks/use-debounce.ts===
import { useState, useEffect } from 'react'

/**
 * Custom hook for debouncing values
 * Delays updating the debounced value until after the specified delay
 * 
 * @param value - The value to debounce
 * @param delay - Delay in milliseconds (default: 300ms)
 * @returns The debounced value
 */
export function useDebounce<T>(value: T, delay: number = 300): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    // Set up a timer to update the debounced value after the delay
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    // Clean up the timer if value changes or component unmounts
    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])

  return debouncedValue
}
===END FILE===

===BEGIN FILE: src/hooks/use-embedded-app-search.ts===
import { useState, useEffect, useRef, useMemo } from 'react'
import { useDebounce } from './use-debounce'
import { useAuth } from '../contexts/auth-context'
import { useAgentStore } from '../stores/agent-store'
import { useIntentStore } from '../stores/intent-store'
import { useRoleConfig } from '../contexts/role-context'
import {
  searchEmbeddedApps,
  getPopularEmbeddedApps,
  getEmbeddedAppsByCategory,
  trackEmbeddedAppLaunch,
  type EmbeddedAppSearchResult,
  type EmbeddedAppSearchRequest,
  type UserContext
} from '../services/embedded-app-search.service'

const DEBOUNCE_MS = 300
const MAX_QUERY_LENGTH = 256
const CACHE_SIZE = 20

interface UseEmbeddedAppSearchOptions {
  autoSearch?: boolean
  minQueryLength?: number
}

export function useEmbeddedAppSearch(options: UseEmbeddedAppSearchOptions = {}) {
  const { autoSearch = true, minQueryLength = 2 } = options
  
  // State management
  const [query, setQuery] = useState('')
  const [results, setResults] = useState<EmbeddedAppSearchResult[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [total, setTotal] = useState(0)
  const [popularApps, setPopularApps] = useState<EmbeddedAppSearchResult[]>([])

  // Context from stores
  const { user } = useAuth()
  const { agentData } = useAgentStore()
  const { embeddedAppIntent } = useIntentStore()
  const { currentRole } = useRoleConfig()

  // Build user context for enhanced search accuracy
  const userContext: UserContext = useMemo(() => {
    // Map auth roles to search roles (keep lowercase for database compatibility)
    const mapAuthRoleToSearchRole = (authRole?: string) => {
      switch (authRole) {
        case 'chat_agent':
          return 'chat_agent'
        case 'supervisor':
          return 'supervisor'
        case 'manager':
          return 'manager'
        case 'admin':
          return 'admin'
        case 'agent':
        default:
          return 'agent'
      }
    }

    const resolvedRole = mapAuthRoleToSearchRole(currentRole || user?.role || agentData?.role)
    
    return {
      role: resolvedRole,
      customerTier: agentData?.customer?.tier || 'standard',
      currentIntent: embeddedAppIntent
    }
  }, [currentRole, user?.role, agentData?.role, agentData?.customer?.tier, embeddedAppIntent])

  const debouncedQuery = useDebounce(query, DEBOUNCE_MS)
  const abortRef = useRef<AbortController | null>(null)
  const cacheRef = useRef<Map<string, EmbeddedAppSearchResult[]>>(new Map())

  // Load popular apps on mount
  useEffect(() => {
    let mounted = true
    const controller = new AbortController()

    const loadPopularApps = async () => {
      try {
        const apps = await getPopularEmbeddedApps(userContext, { signal: controller.signal })
        if (mounted) {
          setPopularApps(apps)
        }
      } catch (error) {
        if ((error as any)?.name !== 'AbortError' && mounted) {
        }
      }
    }

    loadPopularApps()

    return () => {
      mounted = false
      controller.abort()
    }
  }, [userContext.role]) // Reload when role changes

  // Main search effect
  useEffect(() => {
    if (!autoSearch) return

    const performSearch = async () => {
      const trimmedQuery = debouncedQuery.trim().slice(0, MAX_QUERY_LENGTH)
      
      // Clear results for empty or too short queries
      if (!trimmedQuery || trimmedQuery.length < minQueryLength) {
        setResults([])
        setTotal(0)
        setLoading(false)
        setError(null)
        return
      }

      // Check cache first
      const cacheKey = `${trimmedQuery}:${userContext.role}:${userContext.currentIntent}`
      const cached = cacheRef.current.get(cacheKey)
      if (cached) {
        setResults(cached)
        setTotal(cached.length)
        setLoading(false)
        return
      }

      // Cancel previous request
      if (abortRef.current) {
        abortRef.current.abort()
      }
      const controller = new AbortController()
      abortRef.current = controller

      setLoading(true)
      setError(null)

      try {
        const searchRequest: EmbeddedAppSearchRequest = {
          query: trimmedQuery,
          limit: 20
        }

        const response = await searchEmbeddedApps(
          searchRequest,
          userContext,
          { signal: controller.signal }
        )

        if (!controller.signal.aborted) {
          setResults(response.results)
          setTotal(response.total)

          // Cache results
          cacheRef.current.set(cacheKey, response.results)
          if (cacheRef.current.size > CACHE_SIZE) {
            const firstKey = cacheRef.current.keys().next().value
            cacheRef.current.delete(firstKey)
          }
        }
      } catch (error) {
        if ((error as any)?.name !== 'AbortError') {
          setError(error instanceof Error ? error.message : 'Search failed')
          setResults([])
          setTotal(0)
        }
      } finally {
        if (!controller.signal.aborted) {
          setLoading(false)
        }
      }
    }

    performSearch()

    return () => {
      if (abortRef.current) {
        abortRef.current.abort()
      }
    }
  }, [debouncedQuery, userContext.role, userContext.currentIntent, autoSearch, minQueryLength])

  // Manual search function
  const searchManual = async (searchQuery: string): Promise<EmbeddedAppSearchResult[]> => {
    try {
      const searchRequest: EmbeddedAppSearchRequest = {
        query: searchQuery.trim().slice(0, MAX_QUERY_LENGTH),
        limit: 20
      }

      const response = await searchEmbeddedApps(searchRequest, userContext)
      return response.results
    } catch (error) {
      throw error
    }
  }

  // Get apps by category
  const getByCategory = async (category: string): Promise<EmbeddedAppSearchResult[]> => {
    try {
      return await getEmbeddedAppsByCategory(category, userContext)
    } catch (error) {
      throw error
    }
  }

  // Launch app with tracking
  const launchApp = async (app: EmbeddedAppSearchResult) => {
    try {
      // Extract appKey from URL if not directly available
      const appKey = app.appKey || (app.url ? app.url.replace('/embedded-apps/', '') : app.id)
      
      // Track the launch (silently fail if tracking doesn't work)
      if (appKey) {
        await trackEmbeddedAppLaunch(appKey, userContext).catch(() => {})
      }
      
      // Return the app data with context for embedded column
      return {
        ...app,
        appKey, // Ensure appKey is included
        context: {
          customerId: agentData?.customer?.id,
          agentId: agentData?.agentId || `${currentRole}-001`,
          customerName: agentData?.customer?.name,
          intent: app.supportedIntents?.[0] || embeddedAppIntent || 'manual_launch',
          userContext
        }
      }
    } catch (error) {
      // Still return app data even if launch fails
      const appKey = app.appKey || (app.url ? app.url.replace('/embedded-apps/', '') : app.id)
      return {
        ...app,
        appKey,
        context: {
          customerId: agentData?.customer?.id,
          agentId: agentData?.agentId || `${currentRole}-001`,
          customerName: agentData?.customer?.name,
          intent: app.supportedIntents?.[0] || embeddedAppIntent || 'manual_launch',
          userContext
        }
      }
    }
  }

  // Clear search
  const clearSearch = () => {
    setQuery('')
    setResults([])
    setTotal(0)
    setError(null)
    if (abortRef.current) {
      abortRef.current.abort()
    }
  }

  // Get suggested apps based on current intent
  const getSuggestedApps = (): EmbeddedAppSearchResult[] => {
    const safePopularApps = popularApps || []
    if (!embeddedAppIntent) return safePopularApps.slice(0, 6)
    
    // Filter apps that support the current intent
    const intentMatchingApps = safePopularApps.filter(app => 
      app?.supportedIntents && Array.isArray(app.supportedIntents) && app.supportedIntents.includes(embeddedAppIntent)
    )
    
    // If we have intent-matching apps, return them, otherwise return popular apps
    return intentMatchingApps.length > 0 
      ? intentMatchingApps.slice(0, 6)
      : safePopularApps.slice(0, 6)
  }

  const hasQuery = query.trim().length >= minQueryLength
  const hasResults = results.length > 0
  
  return {
    // Search state
    query,
    setQuery,
    results,
    loading,
    error,
    total,
    
    // Popular/suggested apps
    popularApps,
    suggestedApps: getSuggestedApps(),
    
    // Functions
    searchManual,
    getByCategory,
    launchApp,
    clearSearch,
    
    // Computed state
    hasResults,
    hasQuery,
    isEmpty: !loading && !hasQuery && results.length === 0,
    
    // Context info
    userContext
  }
}
===END FILE===

===BEGIN FILE: src/hooks/use-iframe-health-monitor.ts===
import { useEffect, useRef, useState } from 'react'

interface IframeHealthMonitorOptions {
  iframeRef: React.RefObject<HTMLIFrameElement>
  checkInterval?: number // milliseconds
  timeout?: number // milliseconds
  onCrash?: () => void
  onRecover?: () => void
}

export function useIframeHealthMonitor({
  iframeRef,
  checkInterval = 5000, // Check every 5 seconds
  timeout = 10000, // Consider crashed after 10 seconds
  onCrash,
  onRecover
}: IframeHealthMonitorOptions) {
  const [isHealthy, setIsHealthy] = useState(true)
  const [lastPingTime, setLastPingTime] = useState<Date | null>(null)
  const lastResponseRef = useRef<Date>(new Date())
  const healthCheckIntervalRef = useRef<NodeJS.Timeout | null>(null)
  const crashTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  
  useEffect(() => {
    // Listen for health responses from iframe
    const handleMessage = (event: MessageEvent) => {
      if (event.data?.type === 'health.pong') {
        const now = new Date()
        lastResponseRef.current = now
        
        if (!isHealthy) {
          // Iframe recovered
          setIsHealthy(true)
          onRecover?.()
        }
        
        // Clear crash timeout
        if (crashTimeoutRef.current) {
          clearTimeout(crashTimeoutRef.current)
        }
      }
    }
    
    window.addEventListener('message', handleMessage)
    
    // Start health check interval
    healthCheckIntervalRef.current = setInterval(() => {
      if (iframeRef.current?.contentWindow) {
        const pingTime = new Date()
        setLastPingTime(pingTime)
        
        try {
          iframeRef.current.contentWindow.postMessage({ type: 'health.ping' }, '*')
          
          // Set timeout for response
          crashTimeoutRef.current = setTimeout(() => {
            const timeSinceLastResponse = new Date().getTime() - lastResponseRef.current.getTime()
            
            if (timeSinceLastResponse > timeout && isHealthy) {
              // Iframe not responding
              setIsHealthy(false)
              onCrash?.()
            }
          }, timeout)
        } catch (error) {
          // Error sending ping
          if (isHealthy) {
            setIsHealthy(false)
            onCrash?.()
          }
        }
      }
    }, checkInterval)
    
    return () => {
      window.removeEventListener('message', handleMessage)
      
      if (healthCheckIntervalRef.current) {
        clearInterval(healthCheckIntervalRef.current)
      }
      
      if (crashTimeoutRef.current) {
        clearTimeout(crashTimeoutRef.current)
      }
    }
  }, [iframeRef, checkInterval, timeout, isHealthy, onCrash, onRecover, lastPingTime])
  
  return {
    isHealthy,
    lastResponseTime: lastResponseRef.current,
    lastPingTime
  }
}
===END FILE===

===BEGIN FILE: src/hooks/use-keyboard-shortcut.ts===
import { useEffect, useCallback } from 'react'

interface KeyboardShortcutConfig {
  key: string
  ctrlKey?: boolean
  metaKey?: boolean
  shiftKey?: boolean
  altKey?: boolean
  preventDefault?: boolean
}

/**
 * Custom hook for handling keyboard shortcuts
 * Supports modifier keys and prevents default behavior
 * 
 * @param config - Keyboard shortcut configuration
 * @param callback - Function to call when shortcut is pressed
 * @param dependencies - Dependencies for the callback
 */
export function useKeyboardShortcut(
  config: KeyboardShortcutConfig,
  callback: () => void,
  dependencies: React.DependencyList = []
) {
  const handleKeyPress = useCallback((event: KeyboardEvent) => {
    const {
      key,
      ctrlKey = false,
      metaKey = false,
      shiftKey = false,
      altKey = false,
      preventDefault = true
    } = config

    // Check if the key matches
    if (event.key.toLowerCase() !== key.toLowerCase()) {
      return
    }

    // Check modifier keys
    const modifiersMatch = 
      event.ctrlKey === ctrlKey &&
      event.metaKey === metaKey &&
      event.shiftKey === shiftKey &&
      event.altKey === altKey

    if (modifiersMatch) {
      if (preventDefault) {
        event.preventDefault()
        event.stopPropagation()
      }
      callback()
    }
  }, [config, callback, ...dependencies])

  useEffect(() => {
    document.addEventListener('keydown', handleKeyPress)
    
    return () => {
      document.removeEventListener('keydown', handleKeyPress)
    }
  }, [handleKeyPress])
}

/**
 * Convenience hook for Ctrl/Cmd+F shortcut
 * Automatically handles cross-platform modifier keys
 */
export function useGlobalSearch(callback: () => void, dependencies: React.DependencyList = []) {
  // Use metaKey for Mac (Cmd) and ctrlKey for Windows/Linux
  const isMac = typeof window !== 'undefined' && window.navigator.platform.toUpperCase().indexOf('MAC') >= 0

  useKeyboardShortcut(
    {
      key: 'f',
      ...(isMac ? { metaKey: true } : { ctrlKey: true }),
      preventDefault: true
    },
    callback,
    dependencies
  )
}
===END FILE===

===BEGIN FILE: src/hooks/use-kms.ts===
import { useState, useCallback } from 'react'
import { kmsService, type KMSArticle, type KMSLinkInfo } from '../services/kms.service'

/**
 * Hook for managing KMS operations - article opening, linking, etc.
 */
export function useKMS() {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  /**
   * Open a KMS article by ID or URL
   */
  const openKMSArticle = useCallback(async (
    articleIdOrUrl: string,
    openInNewTab: boolean = false
  ): Promise<{ success: boolean; articleId?: string; error?: string }> => {
    setIsLoading(true)
    setError(null)

    try {
      const linkInfo = kmsService.normalizeKMSLink(articleIdOrUrl)
      
      if (!linkInfo.isValid) {
        throw new Error('Invalid KMS article reference')
      }

      if (openInNewTab) {
        // Open in new browser tab
        const shareableLink = kmsService.generateShareableLink(linkInfo.articleId)
        window.open(shareableLink, '_blank', 'noopener,noreferrer')
        return { success: true, articleId: linkInfo.articleId }
      } else {
        // Signal to parent component to open in KMS column
        // This would typically dispatch an event or call a callback
        window.dispatchEvent(new CustomEvent('kms:open-article', {
          detail: { articleId: linkInfo.articleId }
        }))
        return { success: true, articleId: linkInfo.articleId }
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to open KMS article'
      setError(errorMessage)
      return { success: false, error: errorMessage }
    } finally {
      setIsLoading(false)
    }
  }, [])

  /**
   * Extract and enrich KMS links from text
   */
  const processTextForKMSLinks = useCallback(async (text: string): Promise<{
    hasKMSLinks: boolean
    links: Array<KMSLinkInfo & { metadata?: Partial<KMSArticle> }>
    enrichedText: string
  }> => {
    const links = kmsService.extractKMSLinks(text)
    
    if (links.length === 0) {
      return {
        hasKMSLinks: false,
        links: [],
        enrichedText: text
      }
    }

    // Enrich links with metadata
    const enrichedLinks = await Promise.all(
      links.map(async (link) => {
        const metadata = await kmsService.getArticleMetadata(link.articleId)
        return { ...link, metadata }
      })
    )

    // Replace text with formatted links
    let enrichedText = text
    enrichedLinks.forEach(link => {
      if (link.metadata) {
        const formattedLink = kmsService.formatKMSLinkForDisplay(link, link.metadata)
        enrichedText = enrichedText.replace(link.originalUrl, formattedLink)
      }
    })

    return {
      hasKMSLinks: true,
      links: enrichedLinks,
      enrichedText
    }
  }, [])

  /**
   * Generate a shareable link for an article
   */
  const shareKMSArticle = useCallback((articleId: string): string => {
    return kmsService.generateShareableLink(articleId)
  }, [])

  /**
   * Check if a URL is a KMS link
   */
  const isKMSLink = useCallback((url: string): boolean => {
    return kmsService.isKMSLink(url)
  }, [])

  return {
    isLoading,
    error,
    openKMSArticle,
    processTextForKMSLinks,
    shareKMSArticle,
    isKMSLink
  }
}
===END FILE===

===BEGIN FILE: src/hooks/use-media-query.ts===
import { useEffect, useState } from 'react'

export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState<boolean>(false)

  useEffect(() => {
    const media = window.matchMedia(query)
    
    // Set initial value
    setMatches(media.matches)
    
    // Create event listener function
    const listener = (event: MediaQueryListEvent) => {
      setMatches(event.matches)
    }
    
    // Add the listener
    if (media.addEventListener) {
      media.addEventListener('change', listener)
    } else {
      // Fallback for older browsers
      media.addListener(listener as any)
    }
    
    // Clean up
    return () => {
      if (media.removeEventListener) {
        media.removeEventListener('change', listener)
      } else {
        // Fallback for older browsers
        media.removeListener(listener as any)
      }
    }
  }, [query])

  return matches
}
===END FILE===

===BEGIN FILE: src/hooks/use-role-config.ts===
import { useState, useEffect, useRef } from 'react'
import { useToast } from './use-toast'

export type UserRole = 'agent' | 'chat' | 'manager'

export interface RoleConfig {
  widgets: {
    customer: boolean
    transcript: boolean
    sentiment: boolean
    summary: boolean
    intent: boolean
    actions: boolean
    knowledge: boolean
    priority: boolean
  }
  features: {
    spaceCopilot: boolean
    kmsAccess: boolean
    embeddedApps: boolean
    settingsAccess: boolean
    telemetryAccess: boolean
  }
  intents: string[]
  columns: {
    canCollapse: boolean
    canResize: boolean
    persistLayout: boolean
  }
}

const DEFAULT_CONFIGS: Record<UserRole, RoleConfig> = {
  agent: {
    widgets: {
      customer: true,
      transcript: true,
      sentiment: true,
      summary: true,
      intent: true,
      actions: true,
      knowledge: true,
      priority: true
    },
    features: {
      spaceCopilot: true,
      kmsAccess: true,
      embeddedApps: true,
      settingsAccess: true,
      telemetryAccess: false
    },
    intents: [
      'credit_card_transactions',
      'account_inquiry',
      'customer_details',
      'payment_issues',
      'general_support'
    ],
    columns: {
      canCollapse: true,
      canResize: true,
      persistLayout: true
    }
  },
  chat: {
    widgets: {
      customer: true,
      transcript: true,
      sentiment: true,
      summary: false,
      intent: true,
      actions: true,
      knowledge: true,
      priority: false
    },
    features: {
      spaceCopilot: true,
      kmsAccess: true,
      embeddedApps: false,
      settingsAccess: true,
      telemetryAccess: false
    },
    intents: [
      'customer_details',
      'general_support',
      'account_inquiry'
    ],
    columns: {
      canCollapse: false,
      canResize: false,
      persistLayout: true
    }
  },
  manager: {
    widgets: {
      customer: true,
      transcript: true,
      sentiment: true,
      summary: true,
      intent: true,
      actions: true,
      knowledge: true,
      priority: true
    },
    features: {
      spaceCopilot: true,
      kmsAccess: true,
      embeddedApps: true,
      settingsAccess: true,
      telemetryAccess: true
    },
    intents: [
      'credit_card_transactions',
      'account_inquiry',
      'customer_details',
      'payment_issues',
      'general_support',
      'dispute_resolution',
      'fraud_detection'
    ],
    columns: {
      canCollapse: true,
      canResize: true,
      persistLayout: true
    }
  }
}

export function useRoleConfig(initialRole: UserRole = 'agent') {
  const [currentRole, setCurrentRole] = useState<UserRole>(initialRole)
  const [config, setConfig] = useState<RoleConfig>(DEFAULT_CONFIGS[initialRole])
  const [isLoading, setIsLoading] = useState(false)
  const { toast } = useToast()
  const isInitialMount = useRef(true)

  // Simulate fetching role config from API
  const fetchRoleConfig = async (role: UserRole): Promise<RoleConfig> => {
    setIsLoading(true)
    
    try {
      // Remove artificial delay for demo responsiveness
      // await new Promise(resolve => setTimeout(resolve, 500))
      
      // In production, this would be:
      // const response = await fetch(`/api/ui-config/roles/${role}`)
      // return await response.json()
      
      return DEFAULT_CONFIGS[role]
    } catch (error) {
      toast({
        title: "Configuration Error",
        description: "Failed to load role configuration. Using defaults.",
        variant: "destructive"
      })
      return DEFAULT_CONFIGS[role]
    } finally {
      setIsLoading(false)
    }
  }

  const updateRole = async (newRole: UserRole, showNotification = true) => {
    if (newRole === currentRole) return

    // Role changing
    const newConfig = await fetchRoleConfig(newRole)
    
    setCurrentRole(newRole)
    setConfig(newConfig)
    
    // Persist role selection
    localStorage.setItem('ccaas-ui-role', newRole)
    
    // Role changed
    
    // Only show notification if explicitly requested (not on initial load)
    if (showNotification) {
      toast({
        title: "Role Updated",
        description: `Switched to ${newRole === 'agent' ? 'Voice Agent' : newRole === 'chat' ? 'Chat Agent' : 'Supervisor'} role`,
      })
    }
  }

  // Load persisted role on mount
  useEffect(() => {
    // Only run once on initial mount
    if (!isInitialMount.current) return
    isInitialMount.current = false
    
    const savedRole = localStorage.getItem('ccaas-ui-role') as UserRole
    if (savedRole && savedRole !== currentRole) {
      // Don't show notification on initial load
      updateRole(savedRole, false)
    }
  }, [])

  return {
    currentRole,
    config,
    isLoading,
    updateRole,
    // Helper functions
    canAccessWidget: (widget: keyof RoleConfig['widgets']) => config.widgets[widget],
    canAccessFeature: (feature: keyof RoleConfig['features']) => config.features[feature],
    getAvailableIntents: () => config.intents,
    canManageColumns: () => config.columns.canCollapse || config.columns.canResize
  }
}
===END FILE===

===BEGIN FILE: src/hooks/use-sample-notifications.tsx===
import { useEffect } from 'react'
import { useNotificationStore } from '../stores/notification-store'

// ✅ EXTERNALIZED: Sample notifications moved to /public/config/sample-notifications.json

async function loadSampleNotifications() {
  try {
    const response = await fetch('/config/sample-notifications.json')
    if (!response.ok) {
      throw new Error(`Failed to load sample notifications: ${response.status}`)
    }
    const data = await response.json()
    return data.notifications
  } catch (error) {
    // Failed to load sample notifications, using fallback
    return [
      {
        delay: 2000,
        type: 'system',
        title: 'System Ready',
        description: 'Application loaded successfully',
        icon: 'info'
      }
    ]
  }
}

export function useSampleNotifications() {
  const { addNotification } = useNotificationStore()
  
  useEffect(() => {
    // Load and schedule notifications from config
    loadSampleNotifications().then(notifications => {
      const timers: NodeJS.Timeout[] = []
      
      notifications.forEach((notification: any) => {
        const timer = setTimeout(() => {
          addNotification({
            type: notification.type,
            title: notification.title,
            description: notification.description,
            icon: notification.icon,
            actionLabel: notification.actionLabel
          })
        }, notification.delay)
        
        timers.push(timer)
      })
      
      return () => {
        timers.forEach(timer => clearTimeout(timer))
      }
    })
  }, [addNotification])
}
===END FILE===

===BEGIN FILE: src/hooks/use-search-api.ts===
import { useEffect, useMemo, useRef, useState } from 'react'
import { useDebounce } from './use-debounce'
import { searchQuery, type RawSearchResult } from '../services/search.service'
import { useAuth } from '../contexts/auth-context'

export interface SearchResult {
  id: string
  title: string
  category: string
  product?: string
  url: string
  snippet: string
  score?: number
}

const MAX_QUERY_LENGTH = 256
const DEBOUNCE_MS = 200
const CACHE_SIZE = 10

function deriveEntitlementHeader(role?: string, department?: string): string | undefined {
  if (!role && !department) return undefined
  const groups: string[] = []
  // Match database entitlements (uppercase for roles)
  if (role === 'admin') groups.push('ADMIN')
  if (role === 'supervisor') groups.push('SUPERVISOR')
  if (role === 'manager') groups.push('MANAGER')
  if (role === 'chat_agent') groups.push('CHAT_AGENT')
  if (role === 'agent') groups.push('AGENT')
  // Map departments to database entitlements
  if (department) {
    const deptLower = department.toLowerCase()
    if (deptLower.includes('premier')) groups.push('premier')
    else if (deptLower.includes('retail')) groups.push('retail')
    else if (deptLower.includes('wealth')) groups.push('wealth')
    else if (deptLower.includes('business')) groups.push('business')
    else if (deptLower.includes('card')) groups.push('cards')
    else if (deptLower.includes('digital')) groups.push('digital')
    else if (deptLower.includes('experience')) groups.push('experience')
    else groups.push(department.replace(/\s+/g, '-').toLowerCase())
  }
  // Add common entitlements for all agents
  groups.push('basic')
  return groups.join(',') || undefined
}

export function useSearchAPI() {
  // Keep initial hook order stable: states first (prevents Fast Refresh hook order errors)
  const [query, setQuery] = useState('')
  const [results, setResults] = useState<SearchResult[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [total, setTotal] = useState(0)
  const { user } = useAuth()

  const entitlement = useMemo(
    () => deriveEntitlementHeader(user?.role, user?.department),
    [user?.role, user?.department]
  )

  const debouncedQuery = useDebounce(query, DEBOUNCE_MS)
  const abortRef = useRef<AbortController | null>(null)

  // simple LRU-ish in-memory cache for the session
  const cacheRef = useRef<Map<string, { results: SearchResult[]; total: number }>>(new Map())

  useEffect(() => {
    const run = async () => {
      const trimmed = debouncedQuery.trim().slice(0, MAX_QUERY_LENGTH)
      if (!trimmed) {
        setResults([])
        setTotal(0)
        setLoading(false)
        setError(null)
        return
      }

      // Cache hit
      const cached = cacheRef.current.get(trimmed)
      if (cached) {
        setResults(cached.results)
        setTotal(cached.total)
      }

      // cancel previous
      if (abortRef.current) abortRef.current.abort()
      const controller = new AbortController()
      abortRef.current = controller

      setLoading(true)
      setError(null)
      try {
        const { results: raw, total: t } = await searchQuery(
          { q: trimmed, topK: 20, offset: 0 },
          { signal: controller.signal, entitlement }
        )

        const normalized: SearchResult[] = raw.slice(0, 20).map((r: RawSearchResult) => ({
          id: r.id,
          title: r.title,
          category: r.category || 'Document',
          product: r.product,
          url: r.url,
          snippet: sanitizeSnippet(r.snippet),
          score: r.score
        }))

        // show top 5 by default; UI can choose to show more
        setResults(normalized)
        setTotal(typeof t === 'number' ? t : normalized.length)

        // maintain LRU-ish cache size
        cacheRef.current.set(trimmed, { results: normalized, total: t })
        if (cacheRef.current.size > CACHE_SIZE) {
          const firstKey = cacheRef.current.keys().next().value
          cacheRef.current.delete(firstKey)
        }
      } catch (err) {
        if ((err as any)?.name === 'AbortError') return
        // optional fallback disabled per request (no mock)
        setResults([])
        setTotal(0)
        setError(err instanceof Error ? err.message : 'Search failed')
      } finally {
        setLoading(false)
      }
    }

    run()
    return () => {
      if (abortRef.current) abortRef.current.abort()
    }
  }, [debouncedQuery, entitlement])

  const clearSearch = () => {
    setQuery('')
    setResults([])
    setTotal(0)
    setError(null)
  }

  return {
    query,
    setQuery,
    results,
    loading,
    error,
    total,
    clearSearch,
    hasResults: results.length > 0,
    hasQuery: query.trim().length > 0
  }
}

function sanitizeSnippet(snippet: string | undefined): string {
  if (!snippet) return ''
  // Strip any HTML tags to avoid unsafe rendering
  return snippet.replace(/<[^>]*>/g, '')
}
===END FILE===

===BEGIN FILE: src/hooks/use-toast.tsx===
import React, { createContext, useContext, useState, useCallback } from 'react'
import { Toast, ToastContainer, ToastProps } from '../components/ui/toast'

interface ToastContextValue {
  toast: (props: Omit<ToastProps, 'id' | 'onClose'>) => void
  dismiss: (id: string) => void
}

const ToastContext = createContext<ToastContextValue | null>(null)

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = useState<ToastProps[]>([])
  
  const toast = useCallback((props: Omit<ToastProps, 'id' | 'onClose'>) => {
    const id = Date.now().toString()
    const newToast: ToastProps = {
      ...props,
      id,
      onClose: () => dismiss(id),
    }
    
    setToasts((prev) => [...prev, newToast])
    
    // Auto dismiss after 5 seconds
    setTimeout(() => {
      dismiss(id)
    }, 5000)
  }, [])
  
  const dismiss = useCallback((id: string) => {
    setToasts((prev) => prev.filter((t) => t.id !== id))
  }, [])
  
  return (
    <ToastContext.Provider value={{ toast, dismiss }}>
      {children}
      <ToastContainer>
        {toasts.map((toastProps) => (
          <Toast key={toastProps.id} {...toastProps} />
        ))}
      </ToastContainer>
    </ToastContext.Provider>
  )
}

export function useToast() {
  const context = useContext(ToastContext)
  if (!context) {
    throw new Error('useToast must be used within ToastProvider')
  }
  return context
}
===END FILE===

===BEGIN FILE: src/hooks/use-widget-layout.ts===
import { useCallback, useEffect, useState } from 'react'
import { useWidgetLayoutStore } from '../stores/widget-layout-store'
import { useRoleConfig } from '../contexts/role-context'

interface UseWidgetLayoutOptions {
  column: 'customer' | 'spaceCopilot' | 'kms' | 'embedded'
  widgetId: string
  defaultSize?: number
  minSize?: number
  maxSize?: number
}

export function useWidgetLayout({
  column,
  widgetId,
  defaultSize = 50,
  minSize = 10,
  maxSize = 90
}: UseWidgetLayoutOptions) {
  const { currentRole } = useRoleConfig()
  const { setWidgetSize, getWidgetSize } = useWidgetLayoutStore()
  
  // Get stored size or use default
  const storedSize = getWidgetSize(column, widgetId)
  const [size, setSize] = useState(storedSize?.height || defaultSize)
  
  // Handle resize
  const handleResize = useCallback((newSize: number) => {
    // Clamp size within bounds
    const clampedSize = Math.max(minSize, Math.min(maxSize, newSize))
    setSize(clampedSize)
    
    // Save to store
    setWidgetSize(column, widgetId, { 
      height: clampedSize,
      minHeight: minSize,
      maxHeight: maxSize
    })
  }, [column, widgetId, minSize, maxSize, setWidgetSize])
  
  // Reset to default
  const resetSize = useCallback(() => {
    setSize(defaultSize)
    setWidgetSize(column, widgetId, { 
      height: defaultSize,
      minHeight: minSize,
      maxHeight: maxSize
    })
  }, [column, widgetId, defaultSize, minSize, maxSize, setWidgetSize])
  
  // Update when role changes
  useEffect(() => {
    const storedSize = getWidgetSize(column, widgetId)
    if (storedSize?.height && storedSize.height !== size) {
      setSize(storedSize.height)
    }
  }, [currentRole, column, widgetId]) // Remove getWidgetSize from deps to prevent infinite loop
  
  return {
    size,
    handleResize,
    resetSize,
    minSize: storedSize?.minHeight || minSize,
    maxSize: storedSize?.maxHeight || maxSize
  }
}

// Hook for managing panel groups
export function useColumnPanels(column: 'customer' | 'spaceCopilot' | 'kms' | 'embedded') {
  const { resetWidgetSizes } = useWidgetLayoutStore()
  
  const resetColumnSizes = useCallback(() => {
    resetWidgetSizes(column)
  }, [column, resetWidgetSizes])
  
  return {
    resetColumnSizes
  }
}
===END FILE===

===BEGIN FILE: src/index.css===
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom animations for incoming call notification */
@keyframes gradient-x {
  0%, 100% {
    transform: translateX(-100%);
  }
  50% {
    transform: translateX(100%);
  }
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%) skewX(-12deg);
  }
  100% {
    transform: translateX(200%) skewX(-12deg);
  }
}

@keyframes wave-border {
  0%, 100% {
    border-color: rgba(59, 130, 246, 0.3);
    box-shadow: 0 0 20px rgba(59, 130, 246, 0.2);
  }
  33% {
    border-color: rgba(34, 197, 94, 0.3);
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.2);
  }
  66% {
    border-color: rgba(168, 85, 247, 0.3);
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.2);
  }
}

.animate-gradient-x {
  animation: gradient-x 3s ease-in-out infinite;
  background-size: 200% 100%;
}

.animate-shimmer {
  animation: shimmer 3s ease-in-out infinite;
}

.animate-wave-border {
  animation: wave-border 4s ease-in-out infinite;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 13%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 13%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 13%;
    --primary: 356 100% 43%;  /* HSBC Red: #DB0011 */
    --primary-foreground: 0 0% 100%;
    --secondary: 0 0% 96%;
    --secondary-foreground: 0 0% 13%;
    --muted: 0 0% 96%;
    --muted-foreground: 0 0% 45%;
    --accent: 356 100% 43%;
    --accent-foreground: 0 0% 100%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89%;
    --input: 0 0% 89%;
    --ring: 356 100% 43%;
    --radius: 0.375rem;
    
    /* HSBC Brand Colors */
    --hsbc-red: 356 100% 43%;
    --hsbc-black: 0 0% 0%;
    --hsbc-gray: 0 0% 20%;
    --hsbc-light-gray: 0 0% 96%;
  }

  .dark {
    --background: 0 0% 9%;
    --foreground: 0 0% 95%;
    --card: 0 0% 9%;
    --card-foreground: 0 0% 95%;
    --popover: 0 0% 9%;
    --popover-foreground: 0 0% 95%;
    --primary: 356 100% 43%;  /* HSBC Red stays consistent */
    --primary-foreground: 0 0% 100%;
    --secondary: 0 0% 17%;
    --secondary-foreground: 0 0% 95%;
    --muted: 0 0% 17%;
    --muted-foreground: 0 0% 65%;
    --accent: 356 100% 43%;
    --accent-foreground: 0 0% 100%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 17%;
    --input: 0 0% 17%;
    --ring: 356 100% 43%;
    
    /* HSBC Brand Colors (Dark Mode) */
    --hsbc-red: 356 100% 43%;
    --hsbc-black: 0 0% 0%;
    --hsbc-gray: 0 0% 20%;
    --hsbc-light-gray: 0 0% 17%;
  }
}

@layer base {
  * {
    @apply border-border;
    font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
  }
  body {
    @apply bg-background text-foreground;
    font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
    font-weight: 400;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  
  /* Ensure all input elements use the same font */
  input, textarea, select, button {
    font-family: inherit;
  }
  
  /* Ensure font-semibold uses Segoe UI Semibold */
  .font-semibold {
    font-weight: 600;
  }
  
  /* Ensure font-medium uses proper weight */
  .font-medium {
    font-weight: 500;
  }
  
  /* Ensure font-bold uses proper weight */
  .font-bold {
    font-weight: 700;
  }
}

@layer components {
  /* Consistent red hover effect for icon buttons */
  .icon-button-red-hover {
    @apply hover:text-destructive transition-colors;
  }
}

/* React Grid Layout styles */
.react-grid-layout {
  position: relative;
  transition: height 200ms ease;
}

.react-grid-item {
  transition: all 200ms ease;
  transition-property: left, top, width, height;
}

.react-grid-item.cssTransforms {
  transition-property: transform, width, height;
}

.react-grid-item.resizing {
  transition: none;
  z-index: 1;
  will-change: width, height;
}

.react-grid-item.react-draggable-dragging {
  transition: none;
  z-index: 3;
  will-change: transform;
}

.react-grid-item > .react-resizable-handle {
  position: absolute;
  width: 20px;
  height: 20px;
}

.react-grid-item > .react-resizable-handle::after {
  content: "";
  position: absolute;
  right: 3px;
  bottom: 3px;
  width: 5px;
  height: 5px;
  border-right: 2px solid rgba(0, 0, 0, 0.4);
  border-bottom: 2px solid rgba(0, 0, 0, 0.4);
}

.react-resizable-handle {
  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2IDYiIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmYwMCIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSI2cHgiIGhlaWdodD0iNnB4Ij48ZyBvcGFjaXR5PSIwLjMwMiI+PHBhdGggZD0iTSA2IDYgTCAwIDYgTCAwIDQuMiBMIDQuMiA0LjIgTCA0LjIgNC4yIEwgNC4yIDAgTCA2IDAgTCA2IDYgTCA2IDYgWiIgZmlsbD0iIzAwMDAwMCIvPjwvZz48L3N2Zz4=');
  background-position: bottom right;
  background-repeat: no-repeat;
  background-origin: content-box;
  box-sizing: border-box;
  cursor: se-resize;
}
===END FILE===

===BEGIN FILE: src/lib/utils.ts===
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

===END FILE===

===BEGIN FILE: src/main.tsx===
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <App />
)

===END FILE===

===BEGIN FILE: src/pages/login.tsx===
import { useState } from 'react'
import { useAuth } from '../contexts/auth-context'
import { Button } from '../components/ui/button'
import { Input } from '../components/ui/input'
import { Label } from '../components/ui/label'
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '../components/ui/card'
import { Alert, AlertDescription } from '../components/ui/alert'
import { Loader2, Lock, Mail, Shield, TrendingUp, Users, Headphones } from 'lucide-react'
import { useNavigate } from 'react-router-dom'

export function LoginPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const { login } = useAuth()
  const navigate = useNavigate()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError('')
    setIsLoading(true)

    try {
      const success = await login(email, password)
      if (!success) {
        setError('Invalid email or password. Try agent@hsbc.com / demo123')
      }
    } catch (err) {
      setError('An error occurred. Please try again.')
    } finally {
      setIsLoading(false)
    }
  }

  const fillDemoCredentials = () => {
    setEmail('agent@hsbc.com')
    setPassword('demo123')
    setError('')
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 flex flex-col">
      {/* Header */}
      <div className="p-4 flex justify-between items-center">
        <div className="flex items-center gap-2">
          <img 
            src="/hsbc-logo.png" 
            alt="HSBC" 
            className="h-8 w-auto"
          />
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1 flex items-center justify-center p-4">
        <div className="w-full max-w-6xl grid md:grid-cols-2 gap-8 items-center">
          {/* Left Side - Branding */}
          <div className="hidden md:block space-y-8">
            <div>
              <h1 className="text-4xl font-bold text-gray-900 mb-4">
                HSBC Contact Center
              </h1>
              <p className="text-xl text-gray-600">
                AI-Powered Agent Support Platform
              </p>
            </div>

            <div className="space-y-6">
              <div className="flex items-start gap-4">
                <div className="rounded-lg bg-red-100 p-3">
                  <TrendingUp className="h-6 w-6 text-red-600" />
                </div>
                <div>
                  <h3 className="font-semibold text-gray-900 mb-1">
                    Smart Call Assistance
                  </h3>
                  <p className="text-sm text-gray-600">
                    Get instant customer mood insights and call summaries powered by AI
                  </p>
                </div>
              </div>

              <div className="flex items-start gap-4">
                <div className="rounded-lg bg-red-100 p-3">
                  <Users className="h-6 w-6 text-red-600" />
                </div>
                <div>
                  <h3 className="font-semibold text-gray-900 mb-1">
                    Enhanced Customer Service
                  </h3>
                  <p className="text-sm text-gray-600">
                    Deliver exceptional banking support with intelligent recommendations
                  </p>
                </div>
              </div>

              <div className="flex items-start gap-4">
                <div className="rounded-lg bg-red-100 p-3">
                  <Shield className="h-6 w-6 text-red-600" />
                </div>
                <div>
                  <h3 className="font-semibold text-gray-900 mb-1">
                    Secure & Compliant
                  </h3>
                  <p className="text-sm text-gray-600">
                    Bank-grade security with full regulatory compliance
                  </p>
                </div>
              </div>

              <div className="flex items-start gap-4">
                <div className="rounded-lg bg-red-100 p-3">
                  <Headphones className="h-6 w-6 text-red-600" />
                </div>
                <div>
                  <h3 className="font-semibold text-gray-900 mb-1">
                    Instant Updates
                  </h3>
                  <p className="text-sm text-gray-600">
                    Real-time call information delivered instantly to your screen
                  </p>
                </div>
              </div>
            </div>

            <div className="pt-4 border-t border-gray-200">
              <p className="text-sm text-gray-500">
                Trusted by over 10,000 agents worldwide
              </p>
            </div>
          </div>

          {/* Right Side - Login Form */}
          <div>
            <Card className="w-full max-w-md mx-auto shadow-xl">
              <CardHeader className="space-y-1 pb-4">
                <CardTitle className="text-2xl font-bold">Welcome back</CardTitle>
                <CardDescription>
                  Sign in to your HSBC agent account
                </CardDescription>
              </CardHeader>
              <CardContent>
                <form onSubmit={handleSubmit} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="email">Email</Label>
                    <div className="relative">
                      <Mail className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
                      <Input
                        id="email"
                        type="email"
                        placeholder="agent@hsbc.com"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        className="pl-10"
                        required
                        disabled={isLoading}
                      />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="password">Password</Label>
                    <div className="relative">
                      <Lock className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
                      <Input
                        id="password"
                        type="password"
                        placeholder="Enter your password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        className="pl-10"
                        required
                        disabled={isLoading}
                      />
                    </div>
                  </div>

                  {error && (
                    <Alert variant="destructive">
                      <AlertDescription>{error}</AlertDescription>
                    </Alert>
                  )}

                  <Button
                    type="submit"
                    className="w-full bg-red-600 hover:bg-red-700"
                    disabled={isLoading}
                  >
                    {isLoading ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Signing in...
                      </>
                    ) : (
                      'Sign In'
                    )}
                  </Button>
                </form>

                <div className="mt-6 space-y-3">
                  <div className="relative">
                    <div className="absolute inset-0 flex items-center">
                      <span className="w-full border-t" />
                    </div>
                    <div className="relative flex justify-center text-xs uppercase">
                      <span className="bg-background px-2 text-muted-foreground">
                        Demo Accounts
                      </span>
                    </div>
                  </div>

                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => fillDemoCredentials()}
                    disabled={isLoading}
                    className="w-full"
                  >
                    Use Demo Account
                  </Button>

                  <p className="text-xs text-center text-muted-foreground">
                    Demo account: agent@hsbc.com / demo123
                  </p>
                </div>
              </CardContent>
              <CardFooter className="flex flex-col space-y-2 text-center">
                <div className="text-xs text-muted-foreground">
                  By signing in, you agree to HSBC's Terms of Service and Privacy Policy
                </div>
                <div className="text-xs text-muted-foreground">
                  © 2025 HSBC Holdings plc. All rights reserved.
                </div>
              </CardFooter>
            </Card>
          </div>
        </div>
      </div>
    </div>
  )
}
===END FILE===

===BEGIN FILE: src/services/audio.service.ts===
/**
 * Audio Service - Handles call ringtones and audio notifications
 */

interface AudioPlaybackResult {
  success: boolean
  error?: string
}

// Ringtone options mapping (only using available files)
const RINGTONE_PATHS = {
  'default': '/electro_hsbc.mp3',
  'gentle': '/electro_hsbc.mp3',
  'professional': '/electro_hsbc.mp3', 
  'urgent': '/electro_hsbc.mp3'
}

class AudioService {
  private ringtone: HTMLAudioElement | null = null
  private isPlaying: boolean = false
  private readonly defaultVolume: number = 0.7

  /**
   * Get agent settings for audio configuration
   */
  private getAgentSettings() {
    const saved = localStorage.getItem('agent-settings')
    if (saved) {
      try {
        return JSON.parse(saved)
      } catch {
        return null
      }
    }
    return null
  }

  /**
   * Initialize the ringtone audio element
   */
  private initRingtone(): void {
    if (!this.ringtone) {
      const settings = this.getAgentSettings()
      const ringtoneType = settings?.audio?.ringtone || 'default'
      const volume = settings?.audio?.volume || 70
      
      const ringtonePath = RINGTONE_PATHS[ringtoneType as keyof typeof RINGTONE_PATHS] || RINGTONE_PATHS.default
      
      this.ringtone = new Audio(ringtonePath)
      this.ringtone.loop = true
      this.ringtone.volume = volume / 100 // Convert percentage to 0-1
      
      // Handle audio events
      this.ringtone.addEventListener('ended', () => {
        this.isPlaying = false
      })
      
      this.ringtone.addEventListener('error', (e: Event) => {
      })

      this.ringtone.addEventListener('canplaythrough', () => {
      })
    }
  }

  /**
   * Play the incoming call ringtone
   */
  async playRingtone(): Promise<AudioPlaybackResult> {
    // Check if sound notifications are enabled
    const settings = this.getAgentSettings()
    if (!settings?.notifications?.sounds?.incoming) {
      return { success: false, error: 'Incoming call sounds disabled' }
    }

    this.initRingtone()
    
    if (!this.ringtone || this.isPlaying) {
      return { success: false, error: 'Ringtone already playing or not initialized' }
    }

    this.ringtone.currentTime = 0

    try {
      await this.ringtone.play()
      this.isPlaying = true
      return { success: true }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      if (errorMessage.includes('NotAllowedError') || errorMessage.includes('play')) {
      } else {
      }
      return { success: false, error: errorMessage }
    }
  }

  /**
   * Stop the ringtone (when call is answered/rejected)
   */
  stopRingtone(): void {
    if (this.ringtone) {
      try {
        this.ringtone.pause()
        this.ringtone.currentTime = 0
        this.isPlaying = false
      } catch (error) {
        this.isPlaying = false
      }
    } else {
      // Force stop any playing audio elements
      const audioElements = document.querySelectorAll('audio')
      audioElements.forEach(audio => {
        if (!audio.paused) {
          audio.pause()
          audio.currentTime = 0
        }
      })
      this.isPlaying = false
    }
  }

  /**
   * Check if ringtone is currently playing
   */
  isRingtoneActive(): boolean {
    return this.isPlaying
  }

  /**
   * Force stop all audio on the page (emergency stop)
   */
  forceStopAllAudio(): void {
    // Stop our managed ringtone
    this.stopRingtone()
    
    // Force stop any other audio elements
    const audioElements = document.querySelectorAll('audio')
    audioElements.forEach(audio => {
      if (!audio.paused) {
        audio.pause()
        audio.currentTime = 0
      }
    })
    
    // Reset our state
    this.isPlaying = false
  }

  /**
   * Play a short notification sound for other events
   */
  playNotification(): void {
    // Could add other notification sounds here
  }

  /**
   * Set ringtone volume (0.0 to 1.0)
   */
  setVolume(volume: number): void {
    const clampedVolume = Math.max(0, Math.min(1, volume))
    
    if (this.ringtone) {
      this.ringtone.volume = clampedVolume
    }
  }

  /**
   * Get current volume level
   */
  getVolume(): number {
    return this.ringtone?.volume ?? this.defaultVolume
  }

  /**
   * Test/preview a specific ringtone
   */
  async testRingtone(ringtoneType: string = 'default'): Promise<AudioPlaybackResult> {
    // Force reinitialize with new ringtone
    this.cleanup()
    
    const ringtonePath = RINGTONE_PATHS[ringtoneType as keyof typeof RINGTONE_PATHS] || RINGTONE_PATHS.default
    const settings = this.getAgentSettings()
    const volume = settings?.audio?.volume || 70
    
    this.ringtone = new Audio(ringtonePath)
    this.ringtone.volume = volume / 100
    this.ringtone.currentTime = 0

    try {
      // Play for 3 seconds only (test mode)
      await this.ringtone.play()
      this.isPlaying = true
      
      // Stop after 3 seconds
      setTimeout(() => {
        this.stopRingtone()
      }, 3000)
      
      return { success: true }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      return { success: false, error: errorMessage }
    }
  }

  /**
   * Preload the audio file for better performance
   */
  preloadAudio(): void {
    this.initRingtone()
    if (this.ringtone) {
      this.ringtone.load()
    }
  }

  /**
   * Clean up audio resources
   */
  cleanup(): void {
    this.stopRingtone()
    if (this.ringtone) {
      this.ringtone.removeEventListener('ended', () => {})
      this.ringtone.removeEventListener('error', () => {})
      this.ringtone.removeEventListener('canplaythrough', () => {})
      this.ringtone = null
    }
  }
}

// Export singleton instance
export const audioService = new AudioService()
export default audioService
export type { AudioPlaybackResult }
===END FILE===

===BEGIN FILE: src/services/config.service.ts===
/**
 * Configuration Service
 * Handles loading and caching of JSON configuration files
 */

interface ConfigCache {
  [key: string]: {
    data: any
    timestamp: number
    expiry: number
  }
}

// Cache configuration data for 5 minutes
const CACHE_DURATION = 5 * 60 * 1000

class ConfigurationService {
  private cache: ConfigCache = {}
  private loadingPromises: Map<string, Promise<any>> = new Map()

  /**
   * Load configuration from JSON file with caching
   */
  async loadConfig<T = any>(configPath: string): Promise<T> {
    // Check cache first
    const cached = this.cache[configPath]
    if (cached && Date.now() < cached.expiry) {
      return cached.data as T
    }

    // Check if already loading to prevent duplicate requests
    if (this.loadingPromises.has(configPath)) {
      return this.loadingPromises.get(configPath)!
    }

    // Load configuration
    const loadPromise = this.fetchConfig<T>(configPath)
    this.loadingPromises.set(configPath, loadPromise)

    try {
      const data = await loadPromise
      
      // Cache the result
      this.cache[configPath] = {
        data,
        timestamp: Date.now(),
        expiry: Date.now() + CACHE_DURATION
      }

      return data
    } finally {
      this.loadingPromises.delete(configPath)
    }
  }

  /**
   * Fetch configuration from file
   */
  private async fetchConfig<T>(configPath: string): Promise<T> {
    try {
      const response = await fetch(`/config/${configPath}.json`)
      
      if (!response.ok) {
        throw new Error(`Failed to load config: ${configPath} (${response.status})`)
      }

      const data = await response.json()
      return data as T
    } catch (error) {
      throw error
    }
  }

  /**
   * Clear cache for specific config or all configs
   */
  clearCache(configPath?: string): void {
    if (configPath) {
      delete this.cache[configPath]
    } else {
      this.cache = {}
    }
  }

  /**
   * Get cached config without loading (returns null if not cached)
   */
  getCached<T = any>(configPath: string): T | null {
    const cached = this.cache[configPath]
    if (cached && Date.now() < cached.expiry) {
      return cached.data as T
    }
    return null
  }

  /**
   * Preload multiple configurations
   */
  async preloadConfigs(configPaths: string[]): Promise<void> {
    const promises = configPaths.map(path => 
      this.loadConfig(path).catch(error => {
        return null
      })
    )
    
    await Promise.all(promises)
  }
}

// Singleton instance
export const configService = new ConfigurationService()

// Type definitions for known configurations
export interface CustomerProfile {
  id: string
  name: string
  cin: string
  tier: string
  accountNumber: string
  email: string
  phone: string
  location: string
  joinDate: string
  totalInteractions: number
  lastCCAASDate: string
  segment: string
  gender: string
  careNeed: boolean
}

export interface CustomerProfilesConfig {
  customerProfiles: CustomerProfile[]
  randomCustomerTemplate: CustomerProfile
}

export interface AgentProfile {
  agentName: string
  department: string
  agentId: string
  specialization: string
  languages: string[]
  experience: string
  certifications: string[]
}

export interface AgentProfilesConfig {
  agentProfiles: Record<string, AgentProfile>
  defaultAgent: AgentProfile
}

export interface KnowledgeArticle {
  id: string
  title: string
  category: string
  relevance: number
  excerpt: string
  url: string
  content: string
  lastUpdated: string
  tags: string[]
}

export interface KnowledgeArticlesConfig {
  knowledgeArticles: KnowledgeArticle[]
  categories: string[]
}

export interface TranscriptMessage {
  id: string
  timestamp: string
  speaker: 'agent' | 'customer'
  text: string
}

export interface TranscriptScenario {
  id: string
  title: string
  category: string
  messages: TranscriptMessage[]
}

export interface TranscriptScenariosConfig {
  transcriptScenarios: TranscriptScenario[]
  messageTemplates: {
    greetings: string[]
    clarifications: string[]
    confirmations: string[]
    closings: string[]
  }
}

export interface InteractionTemplate {
  id: string
  type: string
  title: string
  status: string
  date: string | null
  details: string
  icon: string
  duration?: string | null
  priority: string
}

export interface InteractionTemplatesConfig {
  interactionTemplates: InteractionTemplate[]
  interactionTypes: Array<{
    type: string
    icon: string
    label: string
    color: string
  }>
  statusTypes: Array<{
    status: string
    label: string
    color: string
    description: string
  }>
}

// Convenience functions for specific configurations
export const loadCustomerProfiles = () => 
  configService.loadConfig<CustomerProfilesConfig>('customer-profiles')

export const loadAgentProfiles = () => 
  configService.loadConfig<AgentProfilesConfig>('agent-profiles')

export const loadKnowledgeArticles = () => 
  configService.loadConfig<KnowledgeArticlesConfig>('knowledge-articles')

export const loadTranscriptScenarios = () => 
  configService.loadConfig<TranscriptScenariosConfig>('transcript-scenarios')

export const loadInteractionTemplates = () => 
  configService.loadConfig<InteractionTemplatesConfig>('interaction-templates')

// Preload all configurations
export const preloadAllConfigs = () => configService.preloadConfigs([
  'customer-profiles',
  'agent-profiles', 
  'knowledge-articles',
  'transcript-scenarios',
  'interaction-templates'
])

export default configService
===END FILE===

===BEGIN FILE: src/services/embedded-app-search.service.ts===
export interface EmbeddedAppSearchRequest {
  query: string
  limit?: number
  category?: string
}

export interface EmbeddedAppSearchResult {
  id: string
  appKey: string
  title: string
  description: string
  category: string
  primaryKeywords: string[]
  secondaryKeywords: string[]
  searchAliases: string[]
  roleAccess: string[]
  supportedIntents: string[]
  iconUrl?: string
  url?: string
  averageRating?: number
  usageCount?: number
  relevanceScore?: number
}

export interface EmbeddedAppSearchResponse {
  results: EmbeddedAppSearchResult[]
  total: number
  query: string
  timeTaken: number
}

export interface UserContext {
  role?: string
  customerTier?: string
  currentIntent?: string
}

const DEFAULT_SEARCH_ENDPOINT = import.meta.env.VITE_SEARCH_API_URL 
  ? `${import.meta.env.VITE_SEARCH_API_URL}/apps` 
  : '/api/search/apps'

export async function searchEmbeddedApps(
  request: EmbeddedAppSearchRequest,
  userContext?: UserContext,
  options?: { signal?: AbortSignal }
): Promise<EmbeddedAppSearchResponse> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json'
  }

  // Add context headers for enhanced search accuracy
  if (userContext?.role) {
    headers['X-Agent-Role'] = userContext.role
  }
  if (userContext?.customerTier) {
    headers['X-Customer-Tier'] = userContext.customerTier
  }
  if (userContext?.currentIntent) {
    headers['X-Current-Intent'] = userContext.currentIntent
  }
  
  // Sending request with headers

  // Convert frontend format to backend format
  const backendRequest = {
    q: request.query,
    topK: request.limit || 20,
    filters: request.category ? { category: request.category } : undefined
  }

  const response = await fetch(DEFAULT_SEARCH_ENDPOINT, {
    method: 'POST',
    headers,
    body: JSON.stringify(backendRequest),
    signal: options?.signal
  })

  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Unknown error')
    throw new Error(`Embedded app search failed (${response.status}): ${errorText}`)
  }

  const data = await response.json()
  
  // Transform backend response to frontend format
  return {
    results: data.results || [],
    total: data.total || 0,
    query: request.query,
    timeTaken: data.tookMs || 0
  }
}

export async function getEmbeddedApp(
  appKey: string,
  userContext?: UserContext,
  options?: { signal?: AbortSignal }
): Promise<EmbeddedAppSearchResult> {
  const headers: Record<string, string> = {}

  if (userContext?.role) {
    headers['X-Agent-Role'] = userContext.role
  }

  const response = await fetch(`${DEFAULT_SEARCH_ENDPOINT}/${appKey}`, {
    method: 'GET',
    headers,
    signal: options?.signal
  })

  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Unknown error')
    throw new Error(`Failed to get embedded app (${response.status}): ${errorText}`)
  }

  return response.json()
}

export async function trackEmbeddedAppLaunch(
  appKey: string,
  userContext?: UserContext
): Promise<void> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json'
  }

  if (userContext?.role) {
    headers['X-Agent-Role'] = userContext.role
  }

  await fetch(`${DEFAULT_SEARCH_ENDPOINT}/${appKey}/launch`, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      timestamp: new Date().toISOString(),
      context: userContext
    })
  }).catch(error => {
    // Track silently - don't fail app launch if tracking fails
  })
}

export async function getPopularEmbeddedApps(
  userContext?: UserContext,
  options?: { signal?: AbortSignal }
): Promise<EmbeddedAppSearchResult[]> {
  const headers: Record<string, string> = {}

  if (userContext?.role) {
    headers['X-Agent-Role'] = userContext.role
  }

  const response = await fetch(`${DEFAULT_SEARCH_ENDPOINT}/popular`, {
    method: 'GET',
    headers,
    signal: options?.signal
  })

  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Unknown error')
    throw new Error(`Failed to get popular apps (${response.status}): ${errorText}`)
  }

  const data = await response.json()
  // Handle both array and object response formats
  return Array.isArray(data) ? data : (data.results || [])
}

export async function getEmbeddedAppsByCategory(
  category: string,
  userContext?: UserContext,
  options?: { signal?: AbortSignal }
): Promise<EmbeddedAppSearchResult[]> {
  const headers: Record<string, string> = {}

  if (userContext?.role) {
    headers['X-Agent-Role'] = userContext.role
  }

  const response = await fetch(`${DEFAULT_SEARCH_ENDPOINT}/categories/${encodeURIComponent(category)}`, {
    method: 'GET',
    headers,
    signal: options?.signal
  })

  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Unknown error')
    throw new Error(`Failed to get apps by category (${response.status}): ${errorText}`)
  }

  const data = await response.json()
  // Handle both array and object response formats
  return Array.isArray(data) ? data : (data.results || [])
}
===END FILE===

===BEGIN FILE: src/services/intent-service.ts===
/**
 * Intent Configuration Service
 * Manages dynamic intent configuration loaded from JSON
 */

export interface IntentConfig {
  displayName: string
  icon: string
  category: string
  hasEmbeddedApp: boolean
  description: string
}

export interface IntentConfigData {
  version: string
  lastUpdated: string
  intents: Record<string, IntentConfig>
  categories: Record<string, {
    name: string
    color: string
  }>
}

class IntentService {
  private config: IntentConfigData | null = null
  private configPromise: Promise<IntentConfigData> | null = null
  private lastFetchTime: number = 0
  private readonly CACHE_DURATION = 60000 // 1 minute cache in production

  /**
   * Load intent configuration from JSON file
   */
  async loadConfig(forceReload = false): Promise<IntentConfigData> {
    // Return cached config if still valid - clear cache to reload new intents
    if (this.config && !forceReload) {
      return this.config
    }

    // If already loading, return the existing promise
    if (this.configPromise && !forceReload) {
      return this.configPromise
    }

    // Load from JSON file
    this.configPromise = fetch('/intent-config.json')
      .then(response => {
        if (!response.ok) {
          throw new Error(`Failed to load intent config: ${response.statusText}`)
        }
        return response.json()
      })
      .then((data: IntentConfigData) => {
        this.config = data
        this.configPromise = null
        return data
      })
      .catch(error => {
        this.configPromise = null
        throw error // Don't hide the error - let it propagate
      })

    return this.configPromise
  }

  /**
   * Get intent configuration by ID
   */
  async getIntent(intentId: string): Promise<IntentConfig | null> {
    const config = await this.loadConfig()
    return config.intents[intentId] || config.intents['unknown'] || null
  }

  /**
   * Get all intents that have embedded apps
   */
  async getEmbeddedAppIntents(): Promise<Record<string, IntentConfig>> {
    const config = await this.loadConfig()
    const result: Record<string, IntentConfig> = {}
    
    for (const [id, intent] of Object.entries(config.intents)) {
      if (intent.hasEmbeddedApp) {
        result[id] = intent
      }
    }
    
    return result
  }

  /**
   * Map intent from AI service to display info
   * Handles both "Account Inquiry" and "account_inquiry" formats
   */
  async mapIntent(intentName: string): Promise<{
    id: string
    displayName: string
    icon: string
    hasEmbeddedApp: boolean
  }> {
    // Convert to snake_case for lookup
    const intentId = this.toSnakeCase(intentName)
    const intent = await this.getIntent(intentId)
    
    if (!intent) {
      // Unknown intent - return with formatted name
      return {
        id: intentId,
        displayName: this.formatIntentName(intentId),
        icon: 'help-circle',
        hasEmbeddedApp: false
      }
    }

    return {
      id: intentId,
      displayName: intent.displayName,
      icon: intent.icon,
      hasEmbeddedApp: intent.hasEmbeddedApp
    }
  }

  /**
   * Format intent ID to human-readable name
   */
  private formatIntentName(intentId: string): string {
    return intentId
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ')
  }

  /**
   * Convert intent name from AI service format to snake_case ID
   * e.g., "Account Inquiry" -> "account_inquiry"
   */
  private toSnakeCase(intentName: string): string {
    return intentName
      .toLowerCase()
      .replace(/\s+/g, '_')
      .replace(/[^a-z0-9_]/g, '')
  }

  /**
   * Check if intent has embedded app support
   */
  async hasEmbeddedApp(intentId: string): Promise<boolean> {
    const intent = await this.getIntent(intentId)
    return intent?.hasEmbeddedApp || false
  }

  /**
   * Get category information for an intent
   */
  async getIntentCategory(intentId: string): Promise<{ name: string; color: string } | null> {
    const config = await this.loadConfig()
    const intent = config.intents[intentId]
    
    if (!intent) return null
    
    return config.categories[intent.category] || null
  }

  /**
   * Reload configuration (useful for development)
   */
  async reload(): Promise<IntentConfigData> {
    return this.loadConfig(true)
  }
}

// Export singleton instance
export const intentService = new IntentService()

// Export for component usage
export default intentService
===END FILE===

===BEGIN FILE: src/services/kms.service.ts===
/**
 * KMS Service - Handles Knowledge Management System operations
 * Supports article linking, normalization, and opening from various contexts
 */

export interface KMSArticle {
  id: string
  title: string
  category: string
  author: string
  lastUpdated: string
  readTime: string
  averageRating: number
  totalRatings: number
  helpfulVotes: number
  content: string
  tags: string[]
  url?: string
}

export interface KMSLinkInfo {
  articleId: string
  title?: string
  category?: string
  isValid: boolean
  normalizedUrl: string
  originalUrl: string
}

class KMSService {
  // ✅ FIXED: KMS base URL now configurable via environment variable
  private readonly KMS_BASE_URL = import.meta.env.VITE_KNOWLEDGE_PORTAL_BASE_URL || 'https://knowledge.hsbc.com'
  private readonly KMS_INTERNAL_PREFIX = '/knowledge/'
  
  /**
   * Normalize various KMS link formats to a standard format
   */
  normalizeKMSLink(url: string): KMSLinkInfo {
    // Handle different KMS URL patterns:
    // - https://knowledge.hsbc.com/article/kb-001
    // - /knowledge/kb-001  
    // - kb-001 (article ID only)
    // - KMS-CC-001 (prefixed article ID)
    
    let articleId = ''
    let isValid = false
    let normalizedUrl = url
    
    try {
      // Extract article ID from various formats
      if (url.includes('knowledge.hsbc.com')) {
        const match = url.match(/\/article\/([^/?#]+)/)
        articleId = match?.[1] || ''
      } else if (url.startsWith('/knowledge/')) {
        articleId = url.replace('/knowledge/', '').split('?')[0].split('#')[0]
      } else if (url.startsWith('KMS-') || url.startsWith('kb-') || url.startsWith('KB-')) {
        articleId = url
      } else if (url.match(/^[a-zA-Z0-9-_]+$/)) {
        // Simple alphanumeric ID
        articleId = url
      }
      
      if (articleId) {
        normalizedUrl = `${this.KMS_BASE_URL}/article/${articleId}`
        isValid = true
      }
      
    } catch (error) {
      // Error normalizing KMS link
    }
    
    return {
      articleId,
      isValid,
      normalizedUrl,
      originalUrl: url
    }
  }
  
  /**
   * Extract KMS links from text content (chat messages, descriptions, etc.)
   */
  extractKMSLinks(text: string): KMSLinkInfo[] {
    const links: KMSLinkInfo[] = []
    
    // Patterns to match KMS links in text
    const patterns = [
      // Full URLs
      /https?:\/\/knowledge\.hsbc\.com\/article\/([^/\s]+)/g,
      // Relative paths
      /\/knowledge\/([^/\s]+)/g,
      // Article references like "See KMS-CC-001" or "Check kb-001"
      /(KMS-[A-Z0-9-]+|kb-[A-Z0-9-]+|KB-[A-Z0-9-]+)/g,
    ]
    
    patterns.forEach(pattern => {
      let match
      while ((match = pattern.exec(text)) !== null) {
        const fullMatch = match[0]
        const linkInfo = this.normalizeKMSLink(fullMatch)
        
        if (linkInfo.isValid && !links.some(l => l.articleId === linkInfo.articleId)) {
          links.push(linkInfo)
        }
      }
    })
    
    return links
  }
  
  /**
   * Get article metadata by ID (mock implementation - would call real API)
   */
  async getArticleMetadata(articleId: string): Promise<Partial<KMSArticle> | null> {
    // Mock data - in real implementation, this would call the KMS API
    const mockArticles: Record<string, Partial<KMSArticle>> = {
      'kb-001': {
        id: 'kb-001',
        title: 'Querying recurring or continuous day loan transactions on a Credit Card',
        category: 'Credit Cards',
        author: 'Knowledge Team'
      },
      'KMS-CC-001': {
        id: 'KMS-CC-001',
        title: 'Credit Card Transaction Disputes',
        category: 'Credit Cards',
        author: 'Support Team'
      },
      'KMS-DISPUTE-001': {
        id: 'KMS-DISPUTE-001',
        title: 'Unauthorized Transaction Dispute Process',
        category: 'Disputes',
        author: 'Fraud Team'
      },
      'KMS-DISPUTE-002': {
        id: 'KMS-DISPUTE-002',
        title: 'Duplicate Charge Dispute Process',
        category: 'Disputes',
        author: 'Fraud Team'
      },
      'KMS-DISPUTE-003': {
        id: 'KMS-DISPUTE-003',
        title: 'Wrong Amount Dispute Process',
        category: 'Disputes',
        author: 'Fraud Team'
      }
    }
    
    return mockArticles[articleId] || null
  }
  
  /**
   * Generate a shareable KMS link
   */
  generateShareableLink(articleId: string): string {
    return `${this.KMS_BASE_URL}/article/${articleId}?utm_source=agent_ui&utm_medium=share`
  }
  
  /**
   * Check if a URL is a KMS link
   */
  isKMSLink(url: string): boolean {
    const linkInfo = this.normalizeKMSLink(url)
    return linkInfo.isValid
  }
  
  /**
   * Create a formatted link for display in chat or UI
   */
  formatKMSLinkForDisplay(linkInfo: KMSLinkInfo, metadata?: Partial<KMSArticle>): string {
    if (metadata?.title) {
      return `📖 ${metadata.title} (${linkInfo.articleId})`
    }
    return `📖 Knowledge Article ${linkInfo.articleId}`
  }
}

// Export singleton instance
export const kmsService = new KMSService()
===END FILE===

===BEGIN FILE: src/services/search.service.ts===
export interface SearchQueryFilters {
  category?: string
  product?: string
  country_code?: string
  locale?: string
}

export interface SearchQueryRequest {
  q: string
  filters?: SearchQueryFilters
  topK?: number
  offset?: number
}

export interface RawSearchResult {
  id: string
  title: string
  url: string
  snippet: string
  category?: string
  product?: string
  score?: number
  locale?: string
  country_code?: string
}

export interface SearchQueryResponse {
  results: RawSearchResult[]
  total: number
  tookMs?: number
}

const DEFAULT_ENDPOINT: string = (import.meta as any)?.env?.VITE_SEARCH_API_URL || '/api/search/query'

export async function searchQuery(
  body: SearchQueryRequest,
  options?: { signal?: AbortSignal; entitlement?: string; endpoint?: string }
): Promise<SearchQueryResponse> {
  const endpoint = options?.endpoint || DEFAULT_ENDPOINT

  const headers: Record<string, string> = {
    'Content-Type': 'application/json'
  }
  if (options?.entitlement) {
    headers['X-Agent-Entitlement'] = options.entitlement
  }

  const startedAt = performance.now()

  const response = await fetch(endpoint, {
    method: 'POST',
    headers,
    body: JSON.stringify(body),
    signal: options?.signal
  })

  const tookMs = Math.round(performance.now() - startedAt)

  if (!response.ok) {
    const message = await safeReadError(response)
    throw new Error(`Search request failed (${response.status}): ${message}`)
  }

  const data = (await response.json()) as Partial<SearchQueryResponse>
  return {
    results: Array.isArray(data?.results) ? (data!.results as RawSearchResult[]) : [],
    total: typeof data?.total === 'number' ? (data!.total as number) : 0,
    tookMs: typeof data?.tookMs === 'number' ? (data!.tookMs as number) : tookMs
  }
}

async function safeReadError(res: Response): Promise<string> {
  try {
    const text = await res.text()
    return text?.slice(0, 512) || 'Unknown error'
  } catch {
    return 'Unknown error'
  }
}



===END FILE===

===BEGIN FILE: src/services/url-builder.service.ts===
/**
 * URL Builder Service for Embedded Applications
 * Handles context-aware and manual mode URL generation for third-party apps
 */

import { traceLog } from '../utils/debug'

export interface CustomerContext {
  customerId: string
  accountNumber?: string
  customerName?: string
  customerTier?: string
  intent?: string
  callerId?: string
  email?: string
  phone?: string
  location?: string
  cin?: string
  accountType?: string
}

export interface AppUrlConfig {
  appKey: string
  baseUrl: string
  routes: {
    home: string
    search?: string
    customer?: string
    transactions?: string
    balance?: string
    fraud?: string
    [key: string]: string | undefined
  }
  paramMapping: {
    [key: string]: string | undefined
  }
}

// Base URL for embedded apps - use environment variable with fallback
const EMBEDDED_APP_BASE_URL = import.meta.env.VITE_EMBEDDED_APP_URL || 'http://localhost:5175'

// Configuration for each embedded app
// In production, this would come from a configuration service
const appConfigs: Record<string, AppUrlConfig> = {
  // Card Management Apps
  'credit_card_management': {
    appKey: 'credit_card_management',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/',
      search: '/search',
      customer: '/customer/:customerId',
      transactions: '/customer/:customerId/transactions',
      disputes: '/customer/:customerId/disputes',
      limits: '/customer/:customerId/limits'
    },
    paramMapping: {
      customerId: 'cust_id',
      accountId: 'acct_num',
      intent: 'context'
    }
  },
  'credit_card_transactions': {
    appKey: 'credit_card_transactions',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/',
      customer: '/customer/:customerId/transactions',
      search: '/transactions/search'
    },
    paramMapping: {
      customerId: 'cust_id',
      accountId: 'card_number'
    }
  },
  
  // Security Apps
  'fraud_alert': {
    appKey: 'fraud_alert',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/fraud',
      alerts: '/fraud/alerts',
      customer: '/fraud/customer/:customerId/alerts'
    },
    paramMapping: {
      customerId: 'customer',
      alertId: 'alert_id'
    }
  },
  
  // Loan Apps
  'mortgage_application': {
    appKey: 'mortgage_application',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/mortgage',
      customer: '/mortgage/customer/:customerId',
      application: '/mortgage/application/:customerId'
    },
    paramMapping: {
      customerId: 'cust_id',
      applicationId: 'app_id'
    }
  },
  'student_loan': {
    appKey: 'student_loan',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/loans/student',
      customer: '/loans/student/:customerId'
    },
    paramMapping: {
      customerId: 'cust_id',
      loanId: 'loan_id'
    }
  },
  
  // Account Apps
  'account_balance_inquiry': {
    appKey: 'account_balance_inquiry',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/balance',
      customer: '/balance/:customerId',
      quick: '/balance/quick/:customerId'
    },
    paramMapping: {
      customerId: 'cust_id',
      accountId: 'acct_id'
    }
  },
  
  'account_balance': {
    appKey: 'account_balance',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/',
      customer: '/:customerId',
      balance: '/balance/:customerId'
    },
    paramMapping: {
      customerId: 'customerId',
      accountId: 'accountNumber',
      intent: 'intent'
    }
  },
  
  // Wealth Management (Supervisor Only)
  'wealth_management': {
    appKey: 'wealth_management',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/wealth',
      customer: '/wealth/customer/:customerId',
      portfolio: '/wealth/customer/:customerId/portfolio',
      advisory: '/wealth/customer/:customerId/advisory'
    },
    paramMapping: {
      customerId: 'client_id',
      tier: 'client_tier'
    }
  },
  
  // Manager Tools
  'team_performance': {
    appKey: 'team_performance',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/team/dashboard',
      metrics: '/team/metrics',
      agents: '/team/agents'
    },
    paramMapping: {
      teamId: 'team_id',
      date: 'report_date'
    }
  },
  'quality_assurance': {
    appKey: 'quality_assurance',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/quality',
      review: '/quality/review',
      scoring: '/quality/scoring/:agentId'
    },
    paramMapping: {
      agentId: 'agent_id',
      callId: 'call_id'
    }
  },
  
  // Admin Tools
  'system_admin': {
    appKey: 'system_admin',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/admin/system',
      config: '/admin/system/config',
      monitoring: '/admin/system/monitoring'
    },
    paramMapping: {
      service: 'service_name'
    }
  },
  
  // Chat Agent Tools
  'quick_balance': {
    appKey: 'quick_balance',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/quick/balance',
      customer: '/quick/balance/:customerId'
    },
    paramMapping: {
      customerId: 'cust_id'
    }
  },
  'chat_templates': {
    appKey: 'chat_templates',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/chat/templates',
      category: '/chat/templates/:category'
    },
    paramMapping: {
      category: 'template_category'
    }
  },
  
  // Default configuration for unknown apps
  'default': {
    appKey: 'default',
    baseUrl: EMBEDDED_APP_BASE_URL,
    routes: {
      home: '/'
    },
    paramMapping: {
      customerId: 'customer_id',
      accountId: 'account_id'
    }
  }
}

// Intent to route mapping
const intentRouteMap: Record<string, (config: AppUrlConfig) => string> = {
  'credit_card_transactions': (config) => config.routes.transactions || config.routes.customer || config.routes.home,
  'fraud_alert': (config) => config.routes.alerts || config.routes.customer || config.routes.home,
  'account_balance_inquiry': (config) => config.routes.balance || config.routes.customer || config.routes.home,
  'account_balance': (config) => config.routes.balance || config.routes.customer || config.routes.home,
  'mortgage_application': (config) => config.routes.application || config.routes.customer || config.routes.home,
  'portfolio_analysis_request': (config) => config.routes.portfolio || config.routes.customer || config.routes.home,
  'investment_advice': (config) => config.routes.advisory || config.routes.customer || config.routes.home,
  'dispute_charge': (config) => config.routes.disputes || config.routes.customer || config.routes.home,
  'account_upgrade': (config) => config.routes.customer || config.routes.home,
  'loan_application': (config) => config.routes.customer || config.routes.home
}

/**
 * Build URL for embedded app based on context
 */
export function buildAppUrl(
  appKey: string,
  hasContext: boolean,
  context?: CustomerContext,
  additionalParams?: Record<string, string>
): string {
  traceLog('🛠️ [TRACE] buildAppUrl called with:', {
    appKey,
    hasContext,
    customerId: context?.customerId,
    customerName: context?.customerName,
    context,
    additionalParams,
    timestamp: new Date().toISOString(),
    callStack: new Error().stack?.split('\n').slice(1, 4).map(line => line.trim())
  })
  
  const config = appConfigs[appKey] || appConfigs['default']
  
  // No context - return home or search page
  if (!hasContext || !context?.customerId) {
    traceLog('🏠 [TRACE] buildAppUrl - No context detected, building manual mode URL:', {
      hasContext,
      contextExists: !!context,
      customerId: context?.customerId,
      decision: 'MANUAL_MODE'
    })
    const baseUrl = `${config.baseUrl}${config.routes.home}`
    
    // Add role and mode parameters for manual navigation
    const params = new URLSearchParams()
    params.append('mode', 'manual')
    params.append('appKey', appKey) // Always pass the appKey so the app knows which view to show
    if (additionalParams?.role) {
      params.append('role', additionalParams.role)
    }
    
    const url = `${baseUrl}?${params.toString()}`
    traceLog('🏠 [TRACE] buildAppUrl - Manual mode URL generated:', url)
    return url
  }
  
  // With context - build deep link
  traceLog('🎯 [TRACE] buildAppUrl - Has context, building context mode URL with deep link:', {
    hasContext,
    customerId: context?.customerId,
    decision: 'CONTEXT_MODE'
  })
  return buildDeepLink(config, context, { ...additionalParams, appKey })
}

/**
 * Build deep link with customer context
 */
function buildDeepLink(
  config: AppUrlConfig,
  context: CustomerContext,
  additionalParams?: Record<string, string>
): string {
  const { intent, customerId, accountNumber, customerTier, email, phone, location, cin, accountType } = context
  traceLog('🔗 [TRACE] buildDeepLink called with:', {
    intent,
    customerId,
    accountNumber,
    customerTier,
    additionalParams,
    config: config.appKey,
    timestamp: new Date().toISOString()
  })
  
  // Get appropriate route based on intent
  let route = config.routes.home
  if (intent && intentRouteMap[intent]) {
    route = intentRouteMap[intent](config)
  } else if (config.routes.customer) {
    route = config.routes.customer
  }
  
  // Replace path parameters
  let url = `${config.baseUrl}${route}`
  url = url.replace(':customerId', encodeURIComponent(customerId))
  
  // Build query parameters
  const params = new URLSearchParams()
  
  // Add mode
  params.append('mode', 'context')
  
  // Add appKey if provided
  if (additionalParams?.appKey) {
    params.append('appKey', additionalParams.appKey)
  }
  
  // Add mapped parameters
  if (accountNumber && config.paramMapping.accountId) {
    params.append(config.paramMapping.accountId, accountNumber)
  }
  if (intent && config.paramMapping.intent) {
    params.append(config.paramMapping.intent, intent)
  }
  if (customerTier && config.paramMapping.tier) {
    params.append(config.paramMapping.tier, customerTier)
  }
  
  // Add customer name
  if (context.customerName) {
    params.append('customerName', context.customerName)
  }
  
  // Add customer email
  if (email) {
    params.append('email', email)
  }
  
  // Add customer phone
  if (phone) {
    params.append('phone', phone)
  }
  
  // Add customer location
  if (location) {
    params.append('location', location)
  }
  
  // Add CIN
  if (cin) {
    params.append('cin', cin)
  }
  
  // Add account type
  if (accountType) {
    params.append('accountType', accountType)
  }
  
  // Add any additional parameters
  if (additionalParams) {
    Object.entries(additionalParams).forEach(([key, value]) => {
      if (!params.has(key)) {
        params.append(key, value)
      }
    })
  }
  
  const queryString = params.toString()
  const finalUrl = queryString ? `${url}?${queryString}` : url
  traceLog('🎯 [TRACE] buildDeepLink - Final context mode URL generated:', {
    finalUrl,
    route,
    queryString,
    timestamp: new Date().toISOString()
  })
  return finalUrl
}

/**
 * Extract app key from URL
 */
export function extractAppKeyFromUrl(url: string): string {
  // Try to extract from /embedded-apps/{appKey} pattern
  const match = url.match(/\/embedded-apps\/([^/?]+)/)
  if (match) {
    return match[1]
  }
  
  // Try to extract from query parameters
  const urlObj = new URL(url, 'http://localhost')
  const appKey = urlObj.searchParams.get('appKey')
  if (appKey) {
    return appKey
  }
  
  // Default fallback
  return 'default'
}

/**
 * Check if an app requires customer context
 */
export function requiresCustomerContext(appKey: string): boolean {
  const contextRequiredApps = [
    'credit_card_management',
    'credit_card_transactions',
    'fraud_alert',
    'account_balance_inquiry',
    'account_balance',
    'mortgage_application',
    'student_loan',
    'wealth_management',
    'quick_balance'
  ]
  
  return contextRequiredApps.includes(appKey)
}

/**
 * Get app configuration
 */
export function getAppConfig(appKey: string): AppUrlConfig {
  return appConfigs[appKey] || appConfigs['default']
}

/**
 * Check if app is available for role
 */
export function isAppAvailableForRole(appKey: string, role: string): boolean {
  // This would typically check against the database
  // For now, we'll use a simple mapping
  const roleApps: Record<string, string[]> = {
    'chat_agent': ['quick_balance', 'chat_templates', 'faq_assistant', 'account_balance_inquiry'],
    'agent': ['credit_card_management', 'fraud_alert', 'mortgage_application', 'account_balance_inquiry', 'international_transfer', 'student_loan', 'account_upgrade', 'business_loan'],
    'supervisor': ['wealth_management', 'escalation_hub', 'team_overview', 'credit_card_management', 'fraud_alert'],
    'manager': ['team_performance', 'quality_assurance', 'audit_dashboard', 'escalation_hub'],
    'admin': ['system_admin', 'user_management', 'audit_logs', 'security_center']
  }
  
  return roleApps[role]?.includes(appKey) || false
}
===END FILE===

===BEGIN FILE: src/stores/agent-status-store.ts===
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type AgentStatus = 'available' | 'on-call' | 'break' | 'offline' | 'after-call-work' | 'do-not-disturb'
export type CallState = 'idle' | 'incoming' | 'ringing' | 'active' | 'ended'

export interface CallerInfo {
  id?: string
  name: string
  number: string // Changed from phone to number
  location?: string // Changed from email to location
  accountNumber?: string
  accountId?: string
  priority: 'URGENT' | 'HIGH' | 'MEDIUM' | 'LOW' // Updated priority values
  issueCategory?: string
  issueDescription?: string
  avatar?: string
}

interface AgentStatusState {
  // Current status
  status: AgentStatus
  
  // Status timestamps
  statusSince: Date
  lastStatusChange: Date
  
  // Call state management
  callState: CallState
  currentCallerId: string
  callerInfo: CallerInfo | null
  callDuration: number
  callStartTime: Date | null
  isMuted: boolean
  isOnHold: boolean
  
  // Call metrics
  callsHandledToday: number
  totalHandleTime: number
  lastCallEndTime: Date | null
  
  // Queue information
  callsInQueue: number
  autoCallEnabled: boolean
  autoAcceptCalls: boolean
  
  // Time tracking
  timeInStatus: {
    available: number
    'on-call': number
    break: number
    offline: number
    'after-call-work': number
    'do-not-disturb': number
  }
  
  // Timer states for after-call work and DND
  afterCallWorkTimer: NodeJS.Timeout | null
  afterCallWorkSecondsRemaining: number
  doNotDisturbTimer: NodeJS.Timeout | null
  doNotDisturbSecondsRemaining: number
  doNotDisturbOriginalStatus: AgentStatus | null
  
  // Actions
  setStatus: (status: AgentStatus) => void
  incrementCallsHandled: () => void
  updateHandleTime: (duration: number) => void
  setCallsInQueue: (count: number) => void
  setAutoCallEnabled: (enabled: boolean) => void
  setAutoAcceptCalls: (enabled: boolean) => void
  updateTimeInStatus: () => void
  resetDailyMetrics: () => void
  setLastCallEndTime: (time: Date | null) => void
  
  // Call state actions
  setCallState: (state: CallState) => void
  setCallerInfo: (info: CallerInfo | null) => void
  setCurrentCallerId: (id: string) => void
  setCallDuration: (duration: number) => void
  setIsMuted: (muted: boolean) => void
  setIsOnHold: (onHold: boolean) => void
  startCall: (callerId: string, callerInfo: CallerInfo) => void
  acceptCall: () => void
  endCall: () => void
  
  // New actions for after-call work and DND
  startAfterCallWork: (durationSeconds: number) => void
  cancelAfterCallWork: () => void
  startDoNotDisturb: (durationMinutes: number, originalStatus?: AgentStatus) => void
  cancelDoNotDisturb: () => void
  canAcceptCalls: () => boolean
}

export const useAgentStatusStore = create<AgentStatusState>()(
  persist(
    (set, get) => ({
      // Initial state - ALWAYS start offline regardless of persisted state
      status: 'offline' as AgentStatus,
      statusSince: new Date(),
      lastStatusChange: new Date(),
      
      // Call state - always reset to idle on load
      callState: 'idle' as CallState,
      currentCallerId: '',
      callerInfo: null,
      callDuration: 0,
      callStartTime: null,
      isMuted: false,
      isOnHold: false,
      
      // Metrics
      callsHandledToday: 0,
      totalHandleTime: 0,
      lastCallEndTime: null,
      
      // Queue - always reset to 0 on load
      callsInQueue: 0,
      autoCallEnabled: true,
      autoAcceptCalls: false, // Default to manual accept
      
      // Time tracking (in seconds)
      timeInStatus: {
        available: 0,
        'on-call': 0,
        break: 0,
        offline: 0,
        'after-call-work': 0,
        'do-not-disturb': 0
      },
      
      // Timer state
      afterCallWorkTimer: null,
      afterCallWorkSecondsRemaining: 0,
      doNotDisturbTimer: null,
      doNotDisturbSecondsRemaining: 0,
      doNotDisturbOriginalStatus: null,
      
      // Actions
      setStatus: (newStatus) => {
        const state = get()
        const now = new Date()
        
        
        // Clear any running timers when changing status
        if (state.afterCallWorkTimer) {
          clearInterval(state.afterCallWorkTimer)
        }
        if (state.doNotDisturbTimer) {
          clearInterval(state.doNotDisturbTimer)
        }
        
        // Update time spent in previous status
        const timeSpent = Math.floor((now.getTime() - state.statusSince.getTime()) / 1000)
        const updatedTimeInStatus = { ...state.timeInStatus }
        updatedTimeInStatus[state.status] += timeSpent
        
        set({
          status: newStatus,
          statusSince: now,
          lastStatusChange: now,
          timeInStatus: updatedTimeInStatus,
          // Reset queue when going offline/break
          callsInQueue: newStatus === 'available' ? state.callsInQueue : 0,
          // Clear timer states
          afterCallWorkTimer: null,
          afterCallWorkSecondsRemaining: 0,
          doNotDisturbTimer: null,
          doNotDisturbSecondsRemaining: 0,
          doNotDisturbOriginalStatus: null
        })
      },
      
      incrementCallsHandled: () => set((state) => ({
        callsHandledToday: state.callsHandledToday + 1
      })),
      
      updateHandleTime: (duration) => set((state) => ({
        totalHandleTime: state.totalHandleTime + duration
      })),
      
      setCallsInQueue: (count) => set({ callsInQueue: count }),
      
      setAutoCallEnabled: (enabled) => set({ autoCallEnabled: enabled }),
      
      setAutoAcceptCalls: (enabled) => set({ autoAcceptCalls: enabled }),
      
      setLastCallEndTime: (time) => set({ lastCallEndTime: time }),
      
      // Call state actions
      setCallState: (state) => set({ callState: state }),
      
      setCallerInfo: (info) => set({ callerInfo: info }),
      
      setCurrentCallerId: (id) => set({ currentCallerId: id }),
      
      setCallDuration: (duration) => set({ callDuration: duration }),
      
      setIsMuted: (muted) => set({ isMuted: muted }),
      
      setIsOnHold: (onHold) => set({ isOnHold: onHold }),
      
      startCall: (callerId, callerInfo) => set({
        callState: 'incoming',
        currentCallerId: callerId,
        callerInfo: callerInfo,
        callDuration: 0,
        callStartTime: null, // Will be set when call is accepted
        isMuted: false,
        isOnHold: false
      }),
      
      acceptCall: () => {
        const state = get()
        set({
          callState: 'active',
          callStartTime: new Date(),
          status: 'on-call'
        })
      },
      
      endCall: () => {
        const state = get()
        // Calculate call duration if call was active
        let duration = 0
        if (state.callStartTime) {
          duration = Math.floor((new Date().getTime() - state.callStartTime.getTime()) / 1000)
        }
        
        set({
          callState: 'idle',
          currentCallerId: '',
          callerInfo: null,
          callDuration: 0,
          callStartTime: null,
          isMuted: false,
          isOnHold: false,
          status: 'available'
        })
        
        // Update metrics if there was a call
        if (duration > 0) {
          get().incrementCallsHandled()
          get().updateHandleTime(duration)
        }
      },
      
      updateTimeInStatus: () => {
        const state = get()
        const now = new Date()
        const timeSpent = Math.floor((now.getTime() - state.statusSince.getTime()) / 1000)
        const updatedTimeInStatus = { ...state.timeInStatus }
        updatedTimeInStatus[state.status] += timeSpent
        
        set({
          timeInStatus: updatedTimeInStatus,
          statusSince: now
        })
      },
      
      resetDailyMetrics: () => set({
        callsHandledToday: 0,
        totalHandleTime: 0,
        timeInStatus: {
          available: 0,
          'on-call': 0,
          break: 0,
          offline: 0,
          'after-call-work': 0,
          'do-not-disturb': 0
        }
      }),
      
      // After-call work functionality
      startAfterCallWork: (durationSeconds) => {
        const state = get()
        
        // Clear any existing timer
        if (state.afterCallWorkTimer) {
          clearInterval(state.afterCallWorkTimer)
        }
        
        // Set status and start countdown
        set({
          status: 'after-call-work',
          statusSince: new Date(),
          lastStatusChange: new Date(),
          afterCallWorkSecondsRemaining: durationSeconds
        })
        
        // Create countdown timer
        const timer = setInterval(() => {
          const currentState = get()
          const remaining = currentState.afterCallWorkSecondsRemaining - 1
          
          if (remaining <= 0) {
            // Timer finished - only change to available if still in after-call-work status
            clearInterval(currentState.afterCallWorkTimer!)
            
            // Only change to available if we're still in after-call-work status
            // (user might have gone on break or offline while timer was running)
            if (currentState.status === 'after-call-work') {
              set({
                status: 'available',
                statusSince: new Date(),
                lastStatusChange: new Date(),
                afterCallWorkTimer: null,
                afterCallWorkSecondsRemaining: 0
              })
            } else {
              set({
                afterCallWorkTimer: null,
                afterCallWorkSecondsRemaining: 0
              })
            }
          } else {
            set({ afterCallWorkSecondsRemaining: remaining })
          }
        }, 1000)
        
        set({ afterCallWorkTimer: timer })
      },
      
      cancelAfterCallWork: () => {
        const state = get()
        if (state.afterCallWorkTimer) {
          clearInterval(state.afterCallWorkTimer)
        }
        // Only change to available if currently in after-call-work status
        if (state.status === 'after-call-work') {
          set({
            status: 'available',
            statusSince: new Date(),
            lastStatusChange: new Date(),
            afterCallWorkTimer: null,
            afterCallWorkSecondsRemaining: 0
          })
        } else {
          // Just clear the timer without changing status
          set({
            afterCallWorkTimer: null,
            afterCallWorkSecondsRemaining: 0
          })
        }
      },
      
      // Do Not Disturb functionality
      startDoNotDisturb: (durationMinutes, originalStatus = 'available') => {
        const state = get()
        
        // Clear any existing timer
        if (state.doNotDisturbTimer) {
          clearInterval(state.doNotDisturbTimer)
        }
        
        const durationSeconds = durationMinutes * 60
        
        // Set DND status
        set({
          status: 'do-not-disturb',
          statusSince: new Date(),
          lastStatusChange: new Date(),
          doNotDisturbSecondsRemaining: durationSeconds,
          doNotDisturbOriginalStatus: originalStatus
        })
        
        // Create countdown timer
        const timer = setInterval(() => {
          const currentState = get()
          const remaining = currentState.doNotDisturbSecondsRemaining - 1
          
          if (remaining <= 0) {
            // Timer finished - only restore if still in DND status
            clearInterval(currentState.doNotDisturbTimer!)
            
            // Only change status if we're still in do-not-disturb
            // (user might have manually changed status while timer was running)
            if (currentState.status === 'do-not-disturb') {
              const restoreStatus = currentState.doNotDisturbOriginalStatus || 'available'
              set({
                status: restoreStatus,
                statusSince: new Date(),
                lastStatusChange: new Date(),
                doNotDisturbTimer: null,
                doNotDisturbSecondsRemaining: 0,
                doNotDisturbOriginalStatus: null
              })
            } else {
              set({
                doNotDisturbTimer: null,
                doNotDisturbSecondsRemaining: 0,
                doNotDisturbOriginalStatus: null
              })
            }
          } else {
            set({ doNotDisturbSecondsRemaining: remaining })
          }
        }, 1000)
        
        set({ doNotDisturbTimer: timer })
      },
      
      cancelDoNotDisturb: () => {
        const state = get()
        if (state.doNotDisturbTimer) {
          clearInterval(state.doNotDisturbTimer)
        }
        // Only restore status if currently in do-not-disturb
        if (state.status === 'do-not-disturb') {
          set({
            status: state.doNotDisturbOriginalStatus || 'available',
            statusSince: new Date(),
            lastStatusChange: new Date(),
            doNotDisturbTimer: null,
            doNotDisturbSecondsRemaining: 0,
            doNotDisturbOriginalStatus: null
          })
        } else {
          // Just clear the timer without changing status
          set({
            doNotDisturbTimer: null,
            doNotDisturbSecondsRemaining: 0,
            doNotDisturbOriginalStatus: null
          })
        }
      },
      
      // Check if agent can accept calls
      canAcceptCalls: () => {
        const state = get()
        // Can only accept calls if available (not on-call, break, offline, etc)
        return state.status === 'available' && state.autoCallEnabled
      }
    }),
    {
      name: 'agent-status-storage',
      partialize: (state) => ({
        // Don't persist status - always start as offline
        // status: state.status,
        callsHandledToday: state.callsHandledToday,
        totalHandleTime: state.totalHandleTime,
        timeInStatus: state.timeInStatus,
        autoCallEnabled: state.autoCallEnabled,
        // Don't persist queue or autoAccept - reset on reload
        // callsInQueue: state.callsInQueue,
        // autoAcceptCalls: state.autoAcceptCalls
      }),
      onRehydrateStorage: () => (state) => {
        // Force status to offline and reset queue on rehydration
        if (state) {
          state.status = 'offline'
          state.callsInQueue = 0
          state.autoAcceptCalls = false
          state.statusSince = new Date()
          state.lastStatusChange = new Date()
        }
      }
    }
  )
)
===END FILE===

===BEGIN FILE: src/stores/agent-store.ts===
import { create } from 'zustand'
import { shallow } from 'zustand/shallow'

interface AgentData {
  // Agent Information
  agentId: string
  agentName: string
  department: string
  role?: 'call' | 'chat' | 'supervisor' | 'manager' // Job function role
  status: 'active' | 'idle' | 'offline'
  
  // Call Information
  callerId: string
  callDuration: number
  queuePosition: number
  
  // Real-time Metrics
  sentiment: {
    score: number
    label: 'positive' | 'neutral' | 'negative'
    trend: 'up' | 'down' | 'stable'
    change: number
  }
  // Rolling sentiment history (most recent last)
  sentimentHistory: number[]
  
  priority: {
    level: 'LOW' | 'MEDIUM' | 'HIGH' | 'URGENT'
    waitTime: number
    estimatedResolution: number
    escalation: boolean
  }
  
  // AI-Generated Content
  summary: {
    text: string
    category: string
    lastUpdated: Date
    confidence: number
  }
  
  intent: {
    type: string
    confidence: number
    detectionMs?: number
    accuracy?: number | string
    appUrl?: string      // URL for embedded app (from WebSocket)
    appTitle?: string    // Display title for embedded app (from WebSocket)
  }
  
  actions: Array<{
    id: string
    action: string
    priority: 'low' | 'medium' | 'high'
    completed: boolean
    details?: string
  }>
  
  // Transcript
  transcript: Array<{
    id: string
    timestamp: Date
    speaker: 'agent' | 'customer'
    text: string
  }>
  
  // Knowledge Base Articles (AI-generated recommendations)
  knowledgeArticles: Array<{
    id: string
    title: string
    category: string
    relevance: number
    excerpt: string
    url: string
    content?: string
    isNew?: boolean
  }>
  
  // Customer Information
  customer: {
    name: string
    id: string
    tier: string
    accountNumber: string
    accountType?: string
    cin?: string
    email: string
    phone: string
    location: string
    joinDate: string
    totalInteractions: number
    lastCCAASDate: string
    verificationStatus?: 'verified' | 'pending'
    riskLevel?: 'low' | 'medium' | 'high'
    gender?: string
    careNeed?: boolean | string
    interactionHistory?: Array<{
      interaction_medium: string
      timestamp: string
      summary: string
      [key: string]: any
    }>
  }
  
  // Performance Metrics
  metrics: {
    avgHandleTime: number
    resolutionRate: number
    customerSatisfaction: number
    callsHandled: number
    firstCallResolution: number
  }
}

interface AgentStore {
  // State
  agentData: Partial<AgentData>
  isConnected: boolean
  connectionStatus: 'disconnected' | 'connecting' | 'connected' | 'error'
  lastUpdate: Date | null
  
  // Actions
  updateAgentData: (data: Partial<AgentData>) => void
  updateSentiment: (sentiment: AgentData['sentiment']) => void
  updatePriority: (priority: AgentData['priority']) => void
  updateSummary: (summary: AgentData['summary']) => void
  updateIntent: (intent: AgentData['intent']) => void
  addTranscriptEntry: (entry: AgentData['transcript'][0]) => void
  updateActions: (actions: AgentData['actions']) => void
  setActionsDirectly: (actions: AgentData['actions']) => void  // For local checkbox updates
  updateKnowledgeArticles: (articles: AgentData['knowledgeArticles']) => void
  updateCustomer: (customer: AgentData['customer']) => void
  updateMetrics: (metrics: AgentData['metrics']) => void
  setConnectionStatus: (status: AgentStore['connectionStatus']) => void
  reset: () => void
  
  // Clear methods for refresh functionality
  clearSentiment: () => void
  clearPriority: () => void
  clearSummary: () => void
  clearIntent: () => void
  clearActions: () => void
  clearTranscript: () => void
  clearKnowledgeArticles: () => void
  clearCustomer: () => void
  clearMetrics: () => void
  clearAgentData: () => void
}

const initialState = {
  agentData: {},
  isConnected: false,
  connectionStatus: 'disconnected' as const,
  lastUpdate: null,
}

const isShallowEqual = (obj1: any, obj2: any): boolean => {
  if (obj1 === obj2) return true
  if (!obj1 || !obj2) return false
  
  const keys1 = Object.keys(obj1)
  const keys2 = Object.keys(obj2)
  
  if (keys1.length !== keys2.length) return false
  
  for (const key of keys1) {
    if (obj1[key] !== obj2[key]) return false
  }
  
  return true
}

export const useAgentStore = create<AgentStore>((set) => ({
  ...initialState,
  
  updateAgentData: (data) => {
    return set((state) => {
      const newAgentData = { ...state.agentData, ...data }
      if (isShallowEqual(state.agentData, newAgentData)) {
        return state
      }
      return {
        agentData: newAgentData,
        lastUpdate: new Date(),
      }
    })
  },
  
  updateSentiment: (sentiment) =>
    set((state) => {
      if (isShallowEqual(state.agentData.sentiment, sentiment)) {
        return state
      }
      const prevHistory = (state.agentData as any).sentimentHistory || []
      const newHistory = [...prevHistory, sentiment?.score ?? 0].slice(-100)
      return {
        agentData: { ...state.agentData, sentiment, sentimentHistory: newHistory },
        lastUpdate: new Date(),
      }
    }),
  
  updatePriority: (priority) =>
    set((state) => {
      if (isShallowEqual(state.agentData.priority, priority)) {
        return state
      }
      return {
        agentData: { ...state.agentData, priority },
        lastUpdate: new Date(),
      }
    }),
  
  updateSummary: (summary) =>
    set((state) => {
      if (isShallowEqual(state.agentData.summary, summary)) {
        return state
      }
      return {
        agentData: { ...state.agentData, summary },
        lastUpdate: new Date(),
      }
    }),
  
  updateIntent: (intent) =>
    set((state) => {
      if (isShallowEqual(state.agentData.intent, intent)) {
        return state
      }
      return {
        agentData: { ...state.agentData, intent },
        lastUpdate: new Date(),
      }
    }),
  
  addTranscriptEntry: (entry) =>
    set((state) => ({
      agentData: {
        ...state.agentData,
        transcript: [...(state.agentData.transcript || []), entry],
      },
      lastUpdate: new Date(),
    })),
  
  updateActions: (actions) =>
    set((state) => {
      // Preserve completed status from existing actions
      const existingActions = state.agentData.actions || []
      
      const completedMap = new Map(
        existingActions.map(action => [action.id, action.completed])
      )
      
      // Merge new actions with preserved completed status
      // Backend doesn't send completed field - it's managed entirely in frontend
      const mergedActions = actions.map(action => {
        const existingCompleted = completedMap.get(action.id)
        const newCompleted = existingCompleted !== undefined ? existingCompleted : false
        return {
          ...action,
          completed: newCompleted
        }
      })
      
      return {
        agentData: { ...state.agentData, actions: mergedActions },
        lastUpdate: new Date(),
      }
    }),
  
  // For local checkbox updates - use the actions directly without merging
  setActionsDirectly: (actions) =>
    set((state) => ({
      agentData: { ...state.agentData, actions },
      lastUpdate: new Date(),
    })),
  
  updateKnowledgeArticles: (knowledgeArticles) =>
    set((state) => {
      // Get existing articles
      const existingArticles = state.agentData.knowledgeArticles || []
      
      // Create a map of existing articles by ID for quick lookup
      const existingMap = new Map(
        existingArticles.map(article => [article.id, article])
      )
      
      // Process new articles
      const newArticles = knowledgeArticles.map((article: any) => ({
        ...article,
        isNew: !existingMap.has(article.id), // Mark as new if not seen before
        timestamp: new Date() // Add timestamp for sorting
      }))
      
      // Merge new articles with existing ones
      // New articles are added to the beginning for visibility
      const mergedArticles = [
        ...newArticles.filter((article: any) => !existingMap.has(article.id)), // New articles first
        ...existingArticles // Keep existing articles
      ]
      
      
      return {
        agentData: { ...state.agentData, knowledgeArticles: mergedArticles },
        lastUpdate: new Date(),
      }
    }),
  
  updateCustomer: (customer) =>
    set((state) => {
      if (isShallowEqual(state.agentData.customer, customer)) {
        return state
      }
      return {
        agentData: { ...state.agentData, customer },
        lastUpdate: new Date(),
      }
    }),
  
  updateMetrics: (metrics) =>
    set((state) => ({
      agentData: { ...state.agentData, metrics },
      lastUpdate: new Date(),
    })),
  
  setConnectionStatus: (connectionStatus) =>
    set({
      connectionStatus,
      isConnected: connectionStatus === 'connected',
    }),
  
  reset: () => set(initialState),
  
  // Clear methods for refresh functionality
  clearSentiment: () =>
    set((state) => ({
      agentData: { ...state.agentData, sentiment: undefined, sentimentHistory: [] },
      lastUpdate: new Date(),
    })),
  
  clearPriority: () =>
    set((state) => ({
      agentData: { ...state.agentData, priority: undefined },
      lastUpdate: new Date(),
    })),
  
  clearSummary: () =>
    set((state) => ({
      agentData: { ...state.agentData, summary: undefined },
      lastUpdate: new Date(),
    })),
  
  clearIntent: () =>
    set((state) => ({
      agentData: { ...state.agentData, intent: undefined },
      lastUpdate: new Date(),
    })),
  
  clearActions: () =>
    set((state) => ({
      agentData: { ...state.agentData, actions: [] },
      lastUpdate: new Date(),
    })),
  
  clearTranscript: () =>
    set((state) => ({
      agentData: { ...state.agentData, transcript: [] },
      lastUpdate: new Date(),
    })),
  
  clearKnowledgeArticles: () =>
    set((state) => ({
      agentData: { ...state.agentData, knowledgeArticles: [] },
      lastUpdate: new Date(),
    })),
  
  clearCustomer: () =>
    set((state) => ({
      agentData: { ...state.agentData, customer: undefined },
      lastUpdate: new Date(),
    })),
  
  clearMetrics: () =>
    set((state) => ({
      agentData: { ...state.agentData, metrics: undefined },
      lastUpdate: new Date(),
    })),
    
  clearAgentData: () => set(initialState),
}))
===END FILE===

===BEGIN FILE: src/stores/intent-store.ts===
import { create } from 'zustand'

interface Intent {
  id: string
  name: string
  icon: string
  context: Record<string, any>
  confidence: number
  appUrl?: string  // URL path to the embedded app (e.g., '/embedded-apps/credit_card_management')
  appTitle?: string  // Display title for the app (e.g., 'Credit Card Management')
}

interface IntentStore {
  // State
  availableIntents: Intent[]
  currentIntent: string | null
  embeddedAppIntent: string | null  // Intent currently displayed in embedded app
  intentHistory: Intent[]
  
  // Actions
  setAvailableIntents: (intents: Intent[] | ((prev: Intent[]) => Intent[])) => void
  selectIntent: (intentId: string) => void
  setEmbeddedAppIntent: (intentId: string) => void  // Manually set embedded app intent
  clearIntents: () => void
  updateIntentContext: (context: Record<string, any>) => void
}

export const useIntentStore = create<IntentStore>((set, get) => ({
  availableIntents: [],
  currentIntent: null,
  embeddedAppIntent: null,
  intentHistory: [],
  
  setAvailableIntents: (intents) => {
    try {
      // Handle both direct arrays and callback functions (like useState)
      const currentIntents = get().availableIntents || []
      const currentEmbeddedIntent = get().embeddedAppIntent
      
      let newIntents
      if (typeof intents === 'function') {
        try {
          newIntents = intents(currentIntents)
        } catch (error) {
          newIntents = currentIntents
        }
      } else {
        newIntents = intents
      }
      
      const validIntents = Array.isArray(newIntents) ? newIntents : []
      
      if (!Array.isArray(newIntents)) {
        // newIntents is not an array, defaulting to empty array
      }
      
      // Find which intent was newly added (instead of always selecting first)
      const newlyAddedIntent = validIntents.find(intent => 
        !currentIntents.some(existing => existing.id === intent.id)
      )
      
      // Use newly added intent if found, otherwise keep current selection, fallback to first
      const currentSelection = get().currentIntent
      const targetIntent = newlyAddedIntent?.id || currentSelection || validIntents[0]?.id || null
      
      
      // Only set embeddedAppIntent if it's not already set (first intent arrival)
      const embeddedIntent = currentEmbeddedIntent || targetIntent
      
      try {
        set({ 
          availableIntents: validIntents,
          currentIntent: targetIntent, // Select actual newly detected intent
          embeddedAppIntent: embeddedIntent // Keep embedded app on first intent unless manually changed
        })
      } catch (error) {
        // Error updating store state
      }
    } catch (error) {
      // Critical error in setAvailableIntents
    }
  },
  
  selectIntent: (intentId) => {
    try {
      
      const availableIntents = get().availableIntents || []
      
      const intent = availableIntents.find(i => i.id === intentId)
      
      if (intent) {
        try {
          set(state => ({
            currentIntent: intentId,
            intentHistory: [...state.intentHistory, intent]
            // NOTE: We do NOT change embeddedAppIntent here - that's only changed manually
          }))
        } catch (error) {
          return
        }
        
        // We do NOT notify embedded app here anymore - only when setEmbeddedAppIntent is called
      } else {
      }
    } catch (error) {
      // Critical error in selectIntent
    }
  },
  
  setEmbeddedAppIntent: (intentId) => {
    try {
      
      const availableIntents = get().availableIntents || []
      const intent = availableIntents.find(i => i.id === intentId)
      
      
      if (intent) {
        
        set({
          embeddedAppIntent: intentId,
          currentIntent: intentId // Also update dropdown selection
        })
      } else {
      }
    } catch (error) {
      // Error in setEmbeddedAppIntent
    }
  },
  
  updateIntentContext: (context) => {
    const currentId = get().currentIntent
    const availableIntents = get().availableIntents || []
    const currentIntent = availableIntents.find(i => i.id === currentId)
    if (currentIntent) {
      const updatedIntents = (get().availableIntents || []).map(intent =>
        intent.id === currentId 
          ? { ...intent, context: { ...intent.context, ...context } }
          : intent
      )
      set({ availableIntents: updatedIntents })
      
      // The embedded app column component will handle sending context updates to the iframe
    }
  },
  
  clearIntents: () => set({ 
    availableIntents: [], 
    currentIntent: null,
    embeddedAppIntent: null,
    intentHistory: []
  })
}))
===END FILE===

===BEGIN FILE: src/stores/notification-store.ts===
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type NotificationType = 'knowledge' | 'ai_coaching' | 'system' | 'alert' | 'success'

export interface Notification {
  id: string
  type: NotificationType
  title: string
  description: string
  timestamp: Date
  read: boolean
  icon?: string
  metadata?: any
  actionLabel?: string
  actionCallback?: () => void
}

interface NotificationStore {
  notifications: Notification[]
  unreadCount: number
  isOpen: boolean
  
  // Actions
  addNotification: (notification: Omit<Notification, 'id' | 'timestamp' | 'read'>) => void
  markAsRead: (id: string) => void
  markAllAsRead: () => void
  dismissNotification: (id: string) => void
  clearAll: () => void
  toggleOpen: () => void
  setOpen: (open: boolean) => void
}

export const useNotificationStore = create<NotificationStore>()(
  persist(
    (set, get) => ({
      notifications: [],
      unreadCount: 0,
      isOpen: false,
      
      addNotification: (notification) => {
        const newNotification: Notification = {
          ...notification,
          id: `notif-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          timestamp: new Date(),
          read: false
        }
        
        set((state) => {
          const updatedNotifications = [newNotification, ...state.notifications]
          // Keep only last 50 notifications
          const trimmedNotifications = updatedNotifications.slice(0, 50)
          
          return {
            notifications: trimmedNotifications,
            unreadCount: trimmedNotifications.filter(n => !n.read).length
          }
        })
      },
      
      markAsRead: (id) => {
        set((state) => {
          const updatedNotifications = state.notifications.map(n => 
            n.id === id ? { ...n, read: true } : n
          )
          
          return {
            notifications: updatedNotifications,
            unreadCount: updatedNotifications.filter(n => !n.read).length
          }
        })
      },
      
      markAllAsRead: () => {
        set((state) => ({
          notifications: state.notifications.map(n => ({ ...n, read: true })),
          unreadCount: 0
        }))
      },
      
      dismissNotification: (id) => {
        set((state) => {
          const updatedNotifications = state.notifications.filter(n => n.id !== id)
          
          return {
            notifications: updatedNotifications,
            unreadCount: updatedNotifications.filter(n => !n.read).length
          }
        })
      },
      
      clearAll: () => {
        set({ notifications: [], unreadCount: 0 })
      },
      
      toggleOpen: () => {
        set((state) => ({ isOpen: !state.isOpen }))
      },
      
      setOpen: (open) => {
        set({ isOpen: open })
      }
    }),
    {
      name: 'ccaas-notifications',
      partialize: (state) => ({
        notifications: state.notifications.slice(0, 20), // Only persist last 20
        unreadCount: state.unreadCount
      })
    }
  )
)
===END FILE===

===BEGIN FILE: src/stores/selectors/agent-selectors.ts===
import { useAgentStore } from '../agent-store'
import { shallow } from 'zustand/shallow'

// Constants for stable default values
const EMPTY_ARRAY: any[] = []
const DEFAULT_CUSTOMER_NAME = 'Customer'
const DEFAULT_AGENT_NAME = 'Agent'

// ===============================
// Granular Data Selectors
// ===============================

// Transcript selector - only re-renders when transcript changes
export const useTranscript = () => 
  useAgentStore(state => state.agentData.transcript || EMPTY_ARRAY)

// Customer selector - only re-renders when customer data changes
export const useCustomer = () => 
  useAgentStore(state => state.agentData.customer)

// Connection status selector
export const useConnectionStatus = () => 
  useAgentStore(state => state.connectionStatus)

// Sentiment selector
export const useSentiment = () => 
  useAgentStore(state => state.agentData.sentiment)

// Intent selector
export const useIntent = () => 
  useAgentStore(state => state.agentData.intent)

// Knowledge articles selector
export const useKnowledgeArticles = () => 
  useAgentStore(state => state.agentData.knowledgeArticles || EMPTY_ARRAY)

// Actions selector
export const useActions = () => 
  useAgentStore(state => state.agentData.actions || EMPTY_ARRAY)

// Priority selector
export const usePriority = () => 
  useAgentStore(state => state.agentData.priority)

// Summary selector
export const useSummary = () => 
  useAgentStore(state => state.agentData.summary)

// Metrics selector
export const useMetrics = () => 
  useAgentStore(state => state.agentData.metrics)

// Agent data selector (when you really need the whole object)
export const useAgentData = () => 
  useAgentStore(state => state.agentData)

// ===============================
// Computed Selectors
// ===============================

// Customer name selector - just the name string
export const useCustomerName = () => 
  useAgentStore(state => state.agentData.customer?.name || DEFAULT_CUSTOMER_NAME)

// Agent name selector - just the name string
export const useAgentName = () => 
  useAgentStore(state => state.agentData.agentName || DEFAULT_AGENT_NAME)

// Check if there's an active call
export const useHasActiveCall = () => 
  useAgentStore(state => 
    state.connectionStatus === 'connected' && 
    state.agentData.callerId !== undefined
  )

// Get transcript length (useful for scroll behavior)
export const useTranscriptLength = () => 
  useAgentStore(state => state.agentData.transcript?.length || 0)

// Check if connected
export const useIsConnected = () => 
  useAgentStore(state => state.isConnected)

// ===============================
// Grouped Action Selectors
// ===============================

// All clear actions grouped - using stable references
export const useClearActions = () => {
  const clearSentiment = useAgentStore(state => state.clearSentiment)
  const clearPriority = useAgentStore(state => state.clearPriority)
  const clearSummary = useAgentStore(state => state.clearSummary)
  const clearIntent = useAgentStore(state => state.clearIntent)
  const clearActionsFunc = useAgentStore(state => state.clearActions)
  const clearTranscript = useAgentStore(state => state.clearTranscript)
  const clearCustomer = useAgentStore(state => state.clearCustomer)
  const clearMetrics = useAgentStore(state => state.clearMetrics)
  const clearKnowledgeArticles = useAgentStore(state => state.clearKnowledgeArticles)
  const clearAgentData = useAgentStore(state => state.clearAgentData)
  
  return {
    clearSentiment,
    clearPriority,
    clearSummary,
    clearIntent,
    clearActions: clearActionsFunc,
    clearTranscript,
    clearCustomer,
    clearMetrics,
    clearKnowledgeArticles,
    clearAgentData
  }
}

// All update actions grouped - using stable references
export const useUpdateActions = () => {
  const updateAgentData = useAgentStore(state => state.updateAgentData)
  const updateSentiment = useAgentStore(state => state.updateSentiment)
  const updatePriority = useAgentStore(state => state.updatePriority)
  const updateSummary = useAgentStore(state => state.updateSummary)
  const updateIntent = useAgentStore(state => state.updateIntent)
  const updateActionsFunc = useAgentStore(state => state.updateActions)
  const setActionsDirectly = useAgentStore(state => state.setActionsDirectly)
  const updateKnowledgeArticles = useAgentStore(state => state.updateKnowledgeArticles)
  const updateCustomer = useAgentStore(state => state.updateCustomer)
  const updateMetrics = useAgentStore(state => state.updateMetrics)
  const addTranscriptEntry = useAgentStore(state => state.addTranscriptEntry)
  
  return {
    updateAgentData,
    updateSentiment,
    updatePriority,
    updateSummary,
    updateIntent,
    updateActions: updateActionsFunc,
    setActionsDirectly,
    updateKnowledgeArticles,
    updateCustomer,
    updateMetrics,
    addTranscriptEntry
  }
}

// Connection management actions - using stable references
export const useConnectionActions = () => {
  const setConnectionStatus = useAgentStore(state => state.setConnectionStatus)
  const reset = useAgentStore(state => state.reset)
  return { setConnectionStatus, reset }
}

// ===============================
// Combined Selectors for Common Use Cases
// ===============================

// For call control components that need priority and update function
export const useCallControl = () => {
  const priority = useAgentStore(state => state.agentData.priority)
  const updatePriority = useAgentStore(state => state.updatePriority)
  const agentData = useAgentStore(state => state.agentData)
  return { priority, updatePriority, agentData }
}

// For transcript components that need transcript and customer name
export const useTranscriptData = () => {
  const transcript = useAgentStore(state => state.agentData.transcript || EMPTY_ARRAY)
  const customerName = useAgentStore(state => state.agentData.customer?.name || DEFAULT_CUSTOMER_NAME)
  return { transcript, customerName }
}

// For customer column that needs customer and connection status
export const useCustomerColumnData = () => {
  const customer = useAgentStore(state => state.agentData.customer)
  const connectionStatus = useAgentStore(state => state.connectionStatus)
  return { customer, connectionStatus }
}

// For KMS column that needs knowledge articles
export const useKMSData = () => {
  const knowledgeArticles = useAgentStore(state => state.agentData.knowledgeArticles || EMPTY_ARRAY)
  return { knowledgeArticles }
}

// ===============================
// Performance Monitoring Selectors
// ===============================

// Last update time (useful for debugging)
export const useLastUpdate = () =>
  useAgentStore(state => state.lastUpdate)

// ===============================
// Subscription Pattern for Heavy Components
// ===============================

// Subscribe to specific parts of the store imperatively
// Usage: const unsubscribe = subscribeToTranscript(callback)
export const subscribeToTranscript = (callback: (transcript: any[]) => void) =>
  useAgentStore.subscribe(
    (state) => callback(state.agentData.transcript || EMPTY_ARRAY)
  )

export const subscribeToCustomer = (callback: (customer: any) => void) =>
  useAgentStore.subscribe(
    (state) => callback(state.agentData.customer)
  )

export const subscribeToConnectionStatus = (callback: (status: string) => void) =>
  useAgentStore.subscribe(
    (state) => callback(state.connectionStatus)
  )
===END FILE===

===BEGIN FILE: src/stores/selectors/embedded-app-selectors.ts===
// Granular selectors for embedded app column to prevent unnecessary re-renders
import { useAgentStore } from '../agent-store'
import { useIntentStore } from '../intent-store'

// Constants for stable default values
const EMPTY_CUSTOMER = null
const EMPTY_INTENT = null

// Agent data selectors
export const useCustomerData = () => 
  useAgentStore(state => state.agentData.customer || EMPTY_CUSTOMER)

export const useCallerId = () => 
  useAgentStore(state => state.agentData.callerId || '')

export const useAgentId = () => 
  useAgentStore(state => state.agentData.agentId || '')

export const useWebSocketIntent = () => 
  useAgentStore(state => state.agentData.intent || EMPTY_INTENT)

// Combined selector for customer context - memoized to prevent object recreation
export const useCustomerContext = () => {
  const customer = useCustomerData()
  const callerId = useCallerId()
  
  if (!customer) return null
  
  return {
    customerId: customer.id || '',
    accountNumber: customer.accountNumber,
    customerName: customer.name,
    customerTier: customer.tier,
    callerId: callerId,
    email: customer.email,
    phone: customer.phone,
    location: customer.location,
    cin: customer.cin,
    accountType: customer.accountType
  }
}

// Intent store selectors
export const useEmbeddedAppIntent = () => 
  useIntentStore(state => state.embeddedAppIntent)

export const useAvailableIntents = () => 
  useIntentStore(state => state.availableIntents)
===END FILE===

===BEGIN FILE: src/stores/widget-layout-store.ts===
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface WidgetSize {
  width?: number
  height?: number
  minWidth?: number
  maxWidth?: number
  minHeight?: number
  maxHeight?: number
}

interface WidgetLayoutState {
  // Widget sizes per column
  customerWidgets: Record<string, WidgetSize>
  spaceCopilotWidgets: Record<string, WidgetSize>
  kmsWidgets: Record<string, WidgetSize>
  embeddedWidgets: Record<string, WidgetSize>
  
  // Actions
  setWidgetSize: (column: string, widgetId: string, size: Partial<WidgetSize>) => void
  getWidgetSize: (column: string, widgetId: string) => WidgetSize | undefined
  resetWidgetSizes: (column?: string) => void
  resetAllWidgetSizes: () => void
}

const DEFAULT_WIDGET_SIZES: Record<string, Record<string, WidgetSize>> = {
  customerWidgets: {
    'customer-info': { height: 40, minHeight: 30, maxHeight: 60 },
    'interaction-history': { height: 60, minHeight: 40, maxHeight: 70 }
  },
  spaceCopilotWidgets: {
    'transcript': { height: 50, minHeight: 30, maxHeight: 70 },
    'ai-assistance': { height: 50, minHeight: 30, maxHeight: 70 }
  },
  kmsWidgets: {
    'search': { height: 15, minHeight: 10, maxHeight: 25 },
    'articles': { height: 85, minHeight: 75, maxHeight: 90 }
  },
  embeddedWidgets: {}
}

export const useWidgetLayoutStore = create<WidgetLayoutState>()(
  persist(
    (set, get) => ({
      customerWidgets: DEFAULT_WIDGET_SIZES.customerWidgets,
      spaceCopilotWidgets: DEFAULT_WIDGET_SIZES.spaceCopilotWidgets,
      kmsWidgets: DEFAULT_WIDGET_SIZES.kmsWidgets,
      embeddedWidgets: DEFAULT_WIDGET_SIZES.embeddedWidgets,

      setWidgetSize: (column, widgetId, size) => {
        set((state) => ({
          [`${column}Widgets`]: {
            ...state[`${column}Widgets` as keyof typeof state] as Record<string, WidgetSize>,
            [widgetId]: {
              ...(state[`${column}Widgets` as keyof typeof state] as Record<string, WidgetSize>)?.[widgetId],
              ...size
            }
          }
        }))
      },

      getWidgetSize: (column, widgetId) => {
        const state = get()
        return (state[`${column}Widgets` as keyof typeof state] as Record<string, WidgetSize>)?.[widgetId]
      },

      resetWidgetSizes: (column) => {
        if (column) {
          set({
            [`${column}Widgets`]: DEFAULT_WIDGET_SIZES[`${column}Widgets`]
          })
        }
      },

      resetAllWidgetSizes: () => {
        set({
          customerWidgets: DEFAULT_WIDGET_SIZES.customerWidgets,
          spaceCopilotWidgets: DEFAULT_WIDGET_SIZES.spaceCopilotWidgets,
          kmsWidgets: DEFAULT_WIDGET_SIZES.kmsWidgets,
          embeddedWidgets: DEFAULT_WIDGET_SIZES.embeddedWidgets
        })
      }
    }),
    {
      name: 'widget-layout-storage',
      partialize: (state) => ({
        customerWidgets: state.customerWidgets,
        spaceCopilotWidgets: state.spaceCopilotWidgets,
        kmsWidgets: state.kmsWidgets,
        embeddedWidgets: state.embeddedWidgets
      })
    }
  )
)
===END FILE===

===BEGIN FILE: src/styles/search-animations.css===
/* Fluid animations for beautiful search bar */

/* CSS Variables for maintainability */
:root {
  --search-primary-color: rgb(239, 68, 68);
  --search-primary-light: rgb(252, 165, 165);
  --search-animation-duration: 4s;
  --search-transition-timing: cubic-bezier(0.4, 0, 0.2, 1);
  --search-border-radius: 0.75rem;
}

/* Gradient flow animation */
@keyframes gradient-flow {
  0% { 
    background-position: 0% 50%;
  }
  50% { 
    background-position: 100% 50%;
  }
  100% { 
    background-position: 0% 50%;
  }
}

/* Pulse glow animation for loading state */
@keyframes pulse-glow {
  0%, 100% { 
    box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
  }
  50% { 
    box-shadow: 0 0 20px 5px rgba(239, 68, 68, 0.2);
  }
}

/* Subtle wave animation */
@keyframes wave {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
}

/* Gradient border wrapper with animation */
.gradient-border-animated {
  padding: 1px;
  border-radius: var(--search-border-radius);
  background: linear-gradient(90deg, 
    var(--search-primary-color),
    var(--search-primary-light),
    var(--search-primary-color),
    var(--search-primary-light),
    var(--search-primary-color)
  );
  background-size: 200% 200%;
  animation: gradient-flow var(--search-animation-duration) ease infinite;
  transition: background-position 0.3s var(--search-transition-timing);
  will-change: auto;
  position: relative;
  z-index: 10;
  /* Optimize for GPU acceleration */
  transform: translateZ(0);
  backface-visibility: hidden;
}

/* Focused state - faster animation without scale */
.gradient-border-animated:focus-within {
  animation: gradient-flow calc(var(--search-animation-duration) / 2) ease infinite;
  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.1);
}

/* The search input itself */
.search-input-animated {
  transition: all 0.3s var(--search-transition-timing);
  position: relative;
  overflow: hidden;
  /* Prevent text selection issues during animations */
  -webkit-user-select: text;
  user-select: text;
}

/* Loading state pulse */
.search-input-loading {
  animation: pulse-glow 1.5s ease-in-out infinite;
}

/* Wave effect overlay */
.search-wave-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent,
    rgba(239, 68, 68, 0.1),
    transparent
  );
  transform: translateX(-100%);
  pointer-events: none;
  /* Ensure overlay doesn't interfere with input */
  z-index: 1;
}

/* Trigger wave on typing */
.search-wave-active {
  animation: wave 1s ease-out;
}

/* Result card animations */
.search-result-card {
  transition: transform 0.2s ease-out, background-color 0.2s ease-out;
  contain: layout;
  /* Optimize reflows */
  will-change: transform, background-color;
}

.search-result-card:hover {
  transform: translateX(4px);
  background-color: rgb(249, 250, 251);
}

/* Dark mode hover state */
@media (prefers-color-scheme: dark) {
  .search-result-card:hover {
    background-color: rgb(31, 41, 55);
  }
}

/* Tab animations */
.search-tab {
  transition: all 0.2s ease-out;
  position: relative;
}

.search-tab::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 0;
  height: 2px;
  background-color: rgb(239, 68, 68);
  transition: width 0.3s ease-out;
}

.search-tab[data-state="active"]::after {
  width: 100%;
}

/* Reduce motion for accessibility */
@media (prefers-reduced-motion: reduce) {
  .gradient-border-animated,
  .search-input-animated,
  .search-result-card,
  .search-tab::after {
    animation: none !important;
    transition: none !important;
  }
}

/* Smooth fade in for results */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.search-results-container {
  animation: fadeIn 0.3s ease-out;
  transform: translateZ(0);
  backface-visibility: hidden;
}
===END FILE===

===BEGIN FILE: src/types/chat-types.ts===
export type CustomerStatus = 'waiting' | 'in_progress' | 'completed'
export type CustomerPriority = 'high' | 'medium' | 'low'
export type CustomerPersonality = 'frustrated' | 'polite' | 'confused' | 'impatient' | 'friendly'
export type IssueCategory = 'account' | 'payments' | 'loans' | 'technical' | 'cards' | 'general'

export interface Customer {
  id: string
  name: string
  avatar?: string
  email: string
  phone?: string
  accountNumber?: string
  status: CustomerStatus
  priority: CustomerPriority
  personality: CustomerPersonality
  issueCategory: IssueCategory
  issueTitle: string
  issueDescription: string
  waitTime: number // in minutes
  joinedAt: Date
  assignedAgentId?: string
  estimatedResolutionTime?: number // in minutes
}

export interface ChatMessage {
  id: string
  text: string
  sender: 'customer' | 'agent'
  timestamp: Date
  customerId: string
  agentId?: string
  isTyping?: boolean
}

export interface ChatConversation {
  id: string
  customerId: string
  agentId: string
  messages: ChatMessage[]
  startTime: Date
  endTime?: Date
  status: 'active' | 'completed' | 'abandoned'
  satisfactionRating?: number
  resolutionNotes?: string
}

export interface QueueMetrics {
  totalWaiting: number
  averageWaitTime: number
  highPriorityCount: number
  mediumPriorityCount: number
  lowPriorityCount: number
  longestWaitTime: number
}

export interface AIResponseContext {
  customer: Customer
  conversation: ChatMessage[]
  lastAgentMessage: string
  conversationStage: 'greeting' | 'problem_identification' | 'troubleshooting' | 'resolution' | 'closing'
}

export interface CustomerQueueSettings {
  maxQueueSize: number
  newCustomerInterval: number // seconds between new customers joining
  responseDelayMin: number // minimum seconds for customer response
  responseDelayMax: number // maximum seconds for customer response
  autoCompleteChance: number // probability (0-1) that customer will be satisfied and end chat
}
===END FILE===

===BEGIN FILE: src/utils/chat-ai-responses.ts===
import { Customer, ChatMessage, AIResponseContext, CustomerPersonality, IssueCategory } from '../types/chat-types'

// ✅ EXTERNALIZED: All hardcoded chat responses moved to /public/config/chat-ai-responses.json
let chatResponsesConfig: any = null

// Initialize config loading when module is imported
loadChatResponsesConfig().catch(() => {})

async function loadChatResponsesConfig() {
  if (!chatResponsesConfig) {
    try {
      const response = await fetch('/config/chat-ai-responses.json')
      if (!response.ok) {
        throw new Error(`Failed to load chat responses config: ${response.status}`)
      }
      chatResponsesConfig = await response.json()
    } catch (error) {
      // Minimal fallback data
      chatResponsesConfig = {
        personalityResponses: {
          polite: {
            greeting: ["Hello, thank you for helping me today."],
            clarification: ["Of course, let me provide more details."],
            solution_positive: ["That's perfect, thank you!"],
            solution_negative: ["I understand, thank you for trying."]
          },
          frustrated: {
            greeting: ["I need help with this issue."],
            clarification: ["Let me explain again."],
            solution_positive: ["Finally, thank you."],
            solution_negative: ["This is frustrating."]
          },
          confused: {
            greeting: ["I'm not sure what's happening."],
            clarification: ["Could you explain that?"],
            solution_positive: ["Oh, I see now!"],
            solution_negative: ["I'm still confused."]
          },
          impatient: {
            greeting: ["I need this fixed quickly."],
            clarification: ["Can we speed this up?"],
            solution_positive: ["Good, thanks for being fast."],
            solution_negative: ["This is taking too long."]
          },
          friendly: {
            greeting: ["Hi there! Hope you're having a great day."],
            clarification: ["Sure thing! Let me explain."],
            solution_positive: ["That's fantastic! Thank you!"],
            solution_negative: ["Oh well, that's okay!"]
          }
        },
        issueResponses: {
          account: {
            details: ["I noticed this issue with my account balance."],
            resolution_request: ["Can you please fix this?"]
          },
          payments: {
            details: ["My payment didn't go through properly."],
            resolution_request: ["Can you process this payment?"]
          },
          loans: {
            details: ["I have a question about my loan."],
            resolution_request: ["Can you help with my loan terms?"]
          },
          technical: {
            details: ["I'm having trouble with the app."],
            resolution_request: ["Can you fix this technical issue?"]
          },
          cards: {
            details: ["My card isn't working properly."],
            resolution_request: ["Can you help with my card?"]
          },
          general: {
            details: ["I have a general question."],
            resolution_request: ["What are my options?"]
          }
        },
        closingResponses: [
          "Thank you for your help.",
          "That's all I needed.",
          "I appreciate your assistance."
        ],
        thankYouMessages: {
          polite: ["Thank you so much!"],
          frustrated: ["Thanks for finally getting that sorted."],
          confused: ["Thanks for explaining that clearly."],
          impatient: ["Thanks for handling this quickly."],
          friendly: ["You've been absolutely wonderful!"]
        },
        responseDelays: {
          frustrated: { base: 1500, variation: 500 },
          impatient: { base: 1500, variation: 300 },
          polite: { base: 1500, variation: 1500 },
          confused: { base: 1500, variation: 2000 },
          friendly: { base: 1500, variation: 1000 }
        },
        variables: {
          "[time]": "dynamic_time",
          "[date]": "dynamic_date", 
          "[amount]": "dynamic_amount",
          "[number]": "dynamic_number",
          "[location]": ["the grocery store", "a gas station", "Target"],
          "[merchant]": ["Amazon", "Walmart", "Target"],
          "[years]": "dynamic_years",
          "[error]": "Error Code 500: Internal Server Error"
        }
      }
    }
  }
  return chatResponsesConfig
}

function getRandomResponse(responses: string[]): string {
  return responses[Math.floor(Math.random() * responses.length)]
}

function replaceVariables(response: string, customer: Customer): string {
  const variables = {
    '[time]': new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }),
    '[date]': new Date().toLocaleDateString('en-US'),
    '[amount]': `$${(Math.random() * 500 + 50).toFixed(2)}`,
    '[number]': Math.floor(1000 + Math.random() * 9000).toString(),
    '[location]': ['the grocery store', 'a gas station', 'Target', 'Amazon', 'the mall'][Math.floor(Math.random() * 5)],
    '[merchant]': ['Amazon', 'Walmart', 'Target', 'Starbucks', 'Shell Gas'][Math.floor(Math.random() * 5)],
    '[years]': Math.floor(2 + Math.random() * 8).toString(),
    '[error]': 'Error Code 500: Internal Server Error'
  }
  
  let result = response
  Object.entries(variables).forEach(([key, value]) => {
    result = result.replace(new RegExp(key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), value)
  })
  
  return result
}

function determineConversationStage(messages: ChatMessage[]): 'greeting' | 'problem_identification' | 'troubleshooting' | 'resolution' | 'closing' {
  const messageCount = messages.length
  
  if (messageCount <= 2) return 'greeting'
  if (messageCount <= 4) return 'problem_identification'
  if (messageCount <= 8) return 'troubleshooting'
  if (messageCount <= 10) return 'resolution'
  return 'closing'
}

function analyzeAgentMessage(message: string): {
  isGreeting: boolean
  isAsking: boolean
  isOffering: boolean
  isClosing: boolean
} {
  const lowerMessage = message.toLowerCase()
  
  return {
    isGreeting: /^(hi|hello|good|thank you|welcome)/.test(lowerMessage),
    isAsking: lowerMessage.includes('?') || /^(can you|could you|what|how|when|where|why)/.test(lowerMessage),
    isOffering: /^(i can|let me|i'll|i will)/.test(lowerMessage) || lowerMessage.includes('help you'),
    isClosing: lowerMessage.includes('resolved') || lowerMessage.includes('anything else') || lowerMessage.includes('goodbye')
  }
}

export function generateCustomerResponse(context: AIResponseContext): string {
  const { customer, conversation, lastAgentMessage } = context
  const stage = determineConversationStage(conversation)
  const agentAnalysis = analyzeAgentMessage(lastAgentMessage)
  
  // Try to load config if not available (synchronous fallback for first call)
  if (!chatResponsesConfig) {
    // Initialize config asynchronously in background, but use fallback for this call
    loadChatResponsesConfig().catch(() => {})
  }
  
  // Get personality-based responses from config (with fallbacks)
  const config = chatResponsesConfig || {}
  const personalityResponses = config.personalityResponses?.[customer.personality]
  
  if (!personalityResponses) {
    // Simple fallback responses if config not loaded
    const fallbackResponses = {
      greeting: "Hello, I need help with my account.",
      clarification: "Let me provide more details about that.",
      solution_positive: "Thank you, that helps!",
      solution_negative: "I'm not sure that works for me."
    }
    return fallbackResponses.greeting
  }
  
  // Determine response type based on conversation stage and agent message
  let responseCategory: keyof typeof personalityResponses
  
  if (stage === 'greeting' || agentAnalysis.isGreeting) {
    responseCategory = 'greeting'
  } else if (agentAnalysis.isAsking || stage === 'problem_identification') {
    // Provide issue details
    if (Math.random() < 0.7) {
      const issueDetails = config.issueResponses[customer.issueCategory]?.details
      if (issueDetails) {
        return replaceVariables(getRandomResponse(issueDetails), customer)
      }
    }
    responseCategory = 'clarification'
  } else if (stage === 'resolution' || agentAnalysis.isOffering) {
    // Randomly decide if customer accepts the solution
    const isPositive = Math.random() < 0.75 // 75% chance of positive response
    responseCategory = isPositive ? 'solution_positive' : 'solution_negative'
  } else if (stage === 'closing' || agentAnalysis.isClosing) {
    // Closing responses from config
    return getRandomResponse(config.closingResponses)
  } else {
    // Default to clarification responses
    responseCategory = 'clarification'
  }
  
  let baseResponse = getRandomResponse(personalityResponses[responseCategory])
  
  // Add issue-specific context occasionally
  if (Math.random() < 0.3 && config.issueResponses[customer.issueCategory]) {
    const issueContext = getRandomResponse(config.issueResponses[customer.issueCategory].details)
    baseResponse += ` ${replaceVariables(issueContext, customer)}`
  }
  
  return replaceVariables(baseResponse, customer)
}

export function getResponseDelay(personality: CustomerPersonality): number {
  // Use fallback delays if config not loaded yet
  const fallbackDelays = {
    frustrated: { base: 1500, variation: 500 },
    impatient: { base: 1500, variation: 300 },
    polite: { base: 1500, variation: 1500 },
    confused: { base: 1500, variation: 2000 },
    friendly: { base: 1500, variation: 1000 }
  }
  
  const delayConfig = chatResponsesConfig?.responseDelays?.[personality] || fallbackDelays[personality]
  
  if (!delayConfig) {
    return 1500 + Math.random() * 1000 // Default delay
  }
  
  return delayConfig.base + Math.random() * delayConfig.variation
}

export function shouldCustomerEndConversation(
  conversation: ChatMessage[],
  customer: Customer
): boolean {
  const messageCount = conversation.length
  
  // Never end too early
  if (messageCount < 6) return false
  
  // Higher chance to end for impatient customers
  if (customer.personality === 'impatient' && messageCount > 8) {
    return Math.random() < 0.4
  }
  
  // Standard ending chance based on conversation length
  if (messageCount > 10) {
    return Math.random() < 0.3
  }
  
  if (messageCount > 15) {
    return Math.random() < 0.6
  }
  
  return false
}

export function generateThankYouMessage(customer: Customer): string {
  // Try to load config if not available (synchronous fallback for first call)
  if (!chatResponsesConfig) {
    loadChatResponsesConfig().catch(() => {})
  }
  
  const config = chatResponsesConfig || {}
  const thankYouMessages = config.thankYouMessages?.[customer.personality]
  
  if (!thankYouMessages) {
    return "Thank you for your help."
  }
  
  return getRandomResponse(thankYouMessages)
}
===END FILE===

===BEGIN FILE: src/utils/debug.ts===
/**
 * Debug Utility - Environment-based conditional logging
 * Controls verbose debug output based on VITE_ENABLE_DEBUG_LOGGING environment variable
 */

// Check if debug logging is enabled via environment variable
const isDebugEnabled = import.meta.env.VITE_ENABLE_DEBUG_LOGGING === 'true'

/**
 * Conditional console.log that only outputs in debug mode
 */
export function debugLog(message: string, data?: any): void {
  if (isDebugEnabled) {
    if (data !== undefined) {
      console.log(message, data)
    } else {
      console.log(message)
    }
  }
}

/**
 * Conditional console.log for trace-level debugging (most verbose)
 * Only outputs when debug logging is explicitly enabled
 */
export function traceLog(message: string, data?: any): void {
  if (isDebugEnabled) {
    if (data !== undefined) {
      console.log(message, data)
    } else {
      console.log(message)
    }
  }
}

/**
 * Info-level logging that always outputs (for important information)
 */
export function infoLog(message: string, data?: any): void {
  if (data !== undefined) {
    console.log(message, data)
  } else {
    console.log(message)
  }
}

/**
 * Warning-level logging that always outputs
 */
export function warnLog(message: string, data?: any): void {
  if (data !== undefined) {
    console.warn(message, data)
  } else {
    console.warn(message)
  }
}

/**
 * Error-level logging that always outputs
 */
export function errorLog(message: string, data?: any): void {
  if (data !== undefined) {
    console.error(message, data)
  } else {
    console.error(message)
  }
}

/**
 * Check if debug mode is currently enabled
 */
export function isDebugMode(): boolean {
  return isDebugEnabled
}
===END FILE===

===BEGIN FILE: src/utils/mock-customers.ts===
import { Customer, CustomerPriority, CustomerPersonality, IssueCategory } from '../types/chat-types'

const CUSTOMER_NAMES = [
  'Sarah Johnson', 'Michael Chen', 'Emily Rodriguez', 'David Williams', 'Jessica Lee',
  'Robert Thompson', 'Amanda Davis', 'Christopher Brown', 'Jennifer Wilson', 'Matthew Garcia',
  'Lisa Anderson', 'Kevin Martinez', 'Rachel Taylor', 'James Moore', 'Ashley Jackson',
  'Daniel White', 'Nicole Harris', 'Ryan Clark', 'Stephanie Lewis', 'Andrew Walker'
]

const CUSTOMER_EMAILS = [
  'sarah.j@email.com', 'michael.c@gmail.com', 'emily.r@yahoo.com', 'david.w@outlook.com',
  'jessica.l@email.com', 'robert.t@gmail.com', 'amanda.d@yahoo.com', 'chris.b@outlook.com',
  'jennifer.w@email.com', 'matthew.g@gmail.com', 'lisa.a@yahoo.com', 'kevin.m@outlook.com',
  'rachel.t@email.com', 'james.m@gmail.com', 'ashley.j@yahoo.com', 'daniel.w@outlook.com',
  'nicole.h@email.com', 'ryan.c@gmail.com', 'stephanie.l@yahoo.com', 'andrew.w@outlook.com'
]

const BANKING_ISSUES = {
  account: {
    titles: [
      'Account Balance Discrepancy',
      'Unauthorized Transaction',
      'Account Locked',
      'Statement Not Received',
      'Account Closure Request',
      'Direct Deposit Issue'
    ],
    descriptions: [
      'I see transactions on my account that I didn\'t make. Need help understanding these charges.',
      'My account balance doesn\'t match what I expected. There\'s a difference of $150.',
      'I can\'t access my account online. It says it\'s been locked due to security reasons.',
      'I haven\'t received my monthly statement for two months now. Can you help me get it?',
      'I want to close my savings account and transfer the funds to my checking account.',
      'My salary should have been deposited yesterday but I don\'t see it in my account.'
    ]
  },
  payments: {
    titles: [
      'Payment Not Processed',
      'Automatic Payment Setup',
      'Failed Wire Transfer',
      'Bill Pay Issue',
      'Refund Request',
      'Payment Declined'
    ],
    descriptions: [
      'I made a payment three days ago but it\'s still showing as pending. When will it clear?',
      'I want to set up automatic payments for my mortgage. Can you help me with that?',
      'My wire transfer to my business partner failed. I need to understand why and resend it.',
      'The bill pay feature isn\'t working. It keeps giving me an error message.',
      'I was charged twice for the same service. I need a refund for the duplicate charge.',
      'My card was declined at the store but I have sufficient funds. What\'s wrong?'
    ]
  },
  loans: {
    titles: [
      'Mortgage Payment Question',
      'Loan Application Status',
      'Interest Rate Inquiry',
      'Early Payment Options',
      'Loan Document Request',
      'Payment Extension Request'
    ],
    descriptions: [
      'I want to know if I can change my mortgage payment date to better align with my salary.',
      'I applied for a personal loan two weeks ago. Can you check the status of my application?',
      'I heard interest rates have dropped. Can I refinance my existing loan at a lower rate?',
      'I want to make an extra payment toward my car loan principal. How do I do that?',
      'I need copies of my loan documents for tax purposes. Can you email them to me?',
      'I\'m facing temporary financial difficulty. Can I get an extension on my loan payment?'
    ]
  },
  technical: {
    titles: [
      'Mobile App Login Issues',
      'Online Banking Error',
      'Card Not Working',
      'PIN Reset Request',
      'App Feature Not Working',
      'Security Alert Question'
    ],
    descriptions: [
      'I can\'t log into the mobile app. It keeps saying my credentials are incorrect.',
      'When I try to transfer money online, I get an error message. Can you help?',
      'My debit card isn\'t working at ATMs. It keeps getting rejected.',
      'I forgot my PIN and need to reset it. What\'s the process for that?',
      'The mobile deposit feature in the app isn\'t working. Photos won\'t upload.',
      'I received a security alert about my account. Is this legitimate or a scam?'
    ]
  },
  cards: {
    titles: [
      'Credit Card Application',
      'Card Replacement Request',
      'Dispute Transaction',
      'Credit Limit Increase',
      'Rewards Points Question',
      'Card Activation Issue'
    ],
    descriptions: [
      'I\'d like to apply for a rewards credit card. What options do you have available?',
      'My credit card is damaged and won\'t swipe. I need a replacement card urgently.',
      'There\'s a charge on my card for $89.99 that I didn\'t authorize. I want to dispute it.',
      'I\'d like to request a credit limit increase on my current card. What\'s required?',
      'I have accumulated rewards points but don\'t know how to redeem them. Can you help?',
      'I received my new card but the activation process isn\'t working online.'
    ]
  },
  general: {
    titles: [
      'Branch Hours Question',
      'Service Fee Inquiry',
      'Account Upgrade Options',
      'International Transfer',
      'Tax Document Request',
      'Account Security Review'
    ],
    descriptions: [
      'What are the hours for the downtown branch? I need to visit in person.',
      'I was charged a service fee on my account. Can you explain what this is for?',
      'I want to upgrade from basic checking to premium. What are the benefits?',
      'I need to send money to my family overseas. What are my options and fees?',
      'I need my tax documents from last year for filing. How can I get copies?',
      'I want to review the security settings on my account to make sure it\'s protected.'
    ]
  }
}

function getRandomElement<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)]
}


function generateAccountNumber(): string {
  return Math.floor(100000000 + Math.random() * 900000000).toString()
}

function generatePhoneNumber(): string {
  const area = Math.floor(200 + Math.random() * 800)
  const exchange = Math.floor(200 + Math.random() * 800)
  const number = Math.floor(1000 + Math.random() * 9000)
  return `(${area}) ${exchange}-${number}`
}

function getRandomWaitTime(): number {
  const weights = [
    { min: 1, max: 5, weight: 40 },    // 1-5 minutes (40% chance)
    { min: 6, max: 15, weight: 35 },   // 6-15 minutes (35% chance)
    { min: 16, max: 30, weight: 20 },  // 16-30 minutes (20% chance)
    { min: 31, max: 60, weight: 5 }    // 31-60 minutes (5% chance)
  ]
  
  const random = Math.random() * 100
  let cumulative = 0
  
  for (const range of weights) {
    cumulative += range.weight
    if (random <= cumulative) {
      return Math.floor(Math.random() * (range.max - range.min + 1)) + range.min
    }
  }
  
  return 5 // fallback
}

function getPriorityFromWaitTime(waitTime: number, issueCategory: IssueCategory): CustomerPriority {
  if (issueCategory === 'account' && waitTime > 20) return 'high'
  if (issueCategory === 'technical' && waitTime > 30) return 'high'
  if (waitTime > 45) return 'high'
  if (waitTime > 20) return 'medium'
  return 'low'
}

function getPersonalityFromPriorityAndWaitTime(priority: CustomerPriority, waitTime: number): CustomerPersonality {
  const personalities: CustomerPersonality[] = ['frustrated', 'polite', 'confused', 'impatient', 'friendly']
  
  if (priority === 'high' || waitTime > 30) {
    return Math.random() < 0.6 ? 'frustrated' : (Math.random() < 0.7 ? 'impatient' : 'polite')
  }
  
  if (priority === 'medium') {
    return Math.random() < 0.3 ? 'confused' : (Math.random() < 0.5 ? 'polite' : 'friendly')
  }
  
  return getRandomElement(['polite', 'friendly', 'confused'])
}

export function generateMockCustomer(): Customer {
  const id = `customer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  const name = getRandomElement(CUSTOMER_NAMES)
  const email = getRandomElement(CUSTOMER_EMAILS)
  const phone = generatePhoneNumber()
  const accountNumber = generateAccountNumber()
  const issueCategory = getRandomElement(Object.keys(BANKING_ISSUES)) as IssueCategory
  const categoryData = BANKING_ISSUES[issueCategory]
  const issueIndex = Math.floor(Math.random() * categoryData.titles.length)
  const issueTitle = categoryData.titles[issueIndex]
  const issueDescription = categoryData.descriptions[issueIndex]
  const waitTime = getRandomWaitTime()
  const priority = getPriorityFromWaitTime(waitTime, issueCategory)
  const personality = getPersonalityFromPriorityAndWaitTime(priority, waitTime)
  const joinedAt = new Date(Date.now() - waitTime * 60 * 1000)
  
  // Estimated resolution time based on issue complexity
  const estimatedResolutionTime = issueCategory === 'account' ? 
    Math.floor(10 + Math.random() * 15) : // 10-25 minutes for account issues
    issueCategory === 'loans' ?
    Math.floor(15 + Math.random() * 20) : // 15-35 minutes for loan issues
    Math.floor(5 + Math.random() * 10)    // 5-15 minutes for other issues

  return {
    id,
    name,
    email,
    phone,
    accountNumber,
    status: 'waiting',
    priority,
    personality,
    issueCategory,
    issueTitle,
    issueDescription,
    waitTime,
    joinedAt,
    estimatedResolutionTime
  }
}

export function generateInitialCustomerQueue(size: number = 8): Customer[] {
  const customers: Customer[] = []
  
  for (let i = 0; i < size; i++) {
    customers.push(generateMockCustomer())
  }
  
  // Sort by priority (high first), then by wait time (longest first)
  return customers.sort((a, b) => {
    const priorityOrder = { high: 3, medium: 2, low: 1 }
    if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
      return priorityOrder[b.priority] - priorityOrder[a.priority]
    }
    return b.waitTime - a.waitTime
  })
}

export function getCustomerAvatarInitials(name: string): string {
  return name.split(' ').map(n => n.charAt(0)).join('').toUpperCase()
}

export function getPriorityColor(priority: CustomerPriority): string {
  switch (priority) {
    case 'high':
      return 'bg-red-100 text-red-800 border-red-200'
    case 'medium':
      return 'bg-yellow-100 text-yellow-800 border-yellow-200'
    case 'low':
      return 'bg-green-100 text-green-800 border-green-200'
  }
}

export function getPriorityIcon(priority: CustomerPriority): 'alert-triangle' | 'alert-circle' | 'check-circle' {
  switch (priority) {
    case 'high':
      return 'alert-triangle'
    case 'medium':
      return 'alert-circle'
    case 'low':
      return 'check-circle'
  }
}

export function getCategoryIcon(category: IssueCategory): 'building-2' | 'credit-card' | 'home' | 'monitor' | 'help-circle' {
  switch (category) {
    case 'account':
      return 'building-2'
    case 'payments':
      return 'credit-card'
    case 'loans':
      return 'home'
    case 'technical':
      return 'monitor'
    case 'cards':
      return 'credit-card'
    case 'general':
      return 'help-circle'
  }
}
===END FILE===

===BEGIN FILE: src/utils/mock-data.ts===
/**
 * Mock data service - provides fallback data when WebSocket is not connected
 * Removed configuration file dependencies - uses WebSocket data primarily
 */

/**
 * Initialize mock data - simplified fallback when WebSocket data is unavailable
 */
export const initializeMockData = async () => {
  // Using fallback mock data (WebSocket not connected)
  
  // Simplified fallback data - no config file dependencies
  return {
    customer: {
      name: 'Demo Customer',
      id: 'demo-001',
      cin: 'CIN-DEMO-001',
      tier: 'Premier Banking',
      accountNumber: 'HSBC000DEMO',
      email: 'demo.customer@email.com',
      phone: '+44-20-7946-0000',
      location: 'London, UK',
      joinDate: '2020-01-01',
      totalInteractions: 5,
      lastCCAASDate: new Date().toISOString().split('T')[0],
      segment: 'Premier',
      gender: 'Unknown',
      careNeed: false,
      verificationStatus: 'verified',
      interactionHistory: [
        {
          interaction_type: 'call',
          channel: 'phone',
          subject: 'Account Balance Inquiry', 
          date: '2025-01-10',
          status: 'resolved',
          description: 'Customer called to check account balance and recent transactions.'
        },
        {
          interaction_type: 'chat',
          channel: 'web_portal',
          interaction_medium: 'web_portal',
          subject: 'Mobile Banking Setup',
          date: '2025-01-08', 
          status: 'resolved',
          description: 'Assisted customer with mobile banking app setup and biometric authentication.'
        }
      ]
    },
    transcript: [
      {
        id: 'demo-1',
        timestamp: new Date(Date.now() - 120000), // 2 minutes ago
        speaker: 'customer' as const,
        text: 'Hello, I need help with my account balance.'
      },
      {
        id: 'demo-2', 
        timestamp: new Date(Date.now() - 60000), // 1 minute ago
        speaker: 'agent' as const,
        text: 'Of course! I can help you check your account balance. Let me pull up your account details.'
      }
    ],
    actions: [
      {
        id: 'demo-action-1',
        action: 'Verify customer identity',
        priority: 'high' as const,
        completed: true,
        details: 'Customer identity verified successfully'
      },
      {
        id: 'demo-action-2', 
        action: 'Check account balance',
        priority: 'medium' as const,
        completed: false,
        details: 'Retrieve current account balance and recent transactions'
      }
    ],
    knowledgeArticles: [
      {
        id: 'demo-kb-1',
        title: 'Account Balance Inquiry Process',
        category: 'Account Management',
        relevance: 95,
        excerpt: 'Step-by-step guide for checking customer account balances',
        url: '/knowledge/account-balance',
        content: 'To check account balance: 1. Verify customer identity, 2. Access account system, 3. Provide balance information',
        lastUpdated: new Date().toISOString(),
        tags: ['account', 'balance', 'inquiry']
      }
    ],
    interactions: [],
    callerId: 'demo-caller-123',
    status: 'active' as const,
    agentId: 'agent-demo',
    agentName: 'Demo Agent',
    department: 'Customer Service',
    sentiment: {
      score: 75,
      label: 'positive' as const,
      trend: 'stable' as const,
      change: 0.05
    },
    summary: {
      text: 'Customer inquiring about account balance and recent transaction history.',
      category: 'Account Management',
      lastUpdated: new Date(),
      confidence: 0.85
    },
    intent: {
      type: 'account_balance',
      confidence: 90,
      detectionMs: 800,
      accuracy: 0.90
    },
    priority: {
      level: 'MEDIUM' as const,
      waitTime: 120,
      estimatedResolution: 300,
      escalation: false
    }
  }
}
===END FILE===

===BEGIN FILE: src/vite-env.d.ts===
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_WS_URL: string
  readonly VITE_API_URL: string
  readonly VITE_KB_URL: string
  readonly VITE_AI_SERVICE_URL: string
  // Add more env variables as needed
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
===END FILE===

===BEGIN FILE: vite.config.js===
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    hmr: {
      overlay: false,
      timeout: 60000,
    },
    proxy: {
      '/api/search': {
        target: 'http://localhost:8091',
        changeOrigin: true,
        secure: false,
      },
    },
  },
  test: {
    environment: 'jsdom',
    setupFiles: './src/test/setup.js',
    globals: true,
  },
  // Using Vite 6.x to avoid crypto.hash error on Node < 20.12.0
  // If you upgrade Node to 20.12.0+, you can upgrade back to Vite 7.x
})
===END FILE===

